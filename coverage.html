
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>slots: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">zeno/internal/slots/auth.go (41.0%)</option>
				
				<option value="file1">zeno/internal/slots/blade.go (86.7%)</option>
				
				<option value="file2">zeno/internal/slots/cache.go (100.0%)</option>
				
				<option value="file3">zeno/internal/slots/captcha.go (81.2%)</option>
				
				<option value="file4">zeno/internal/slots/collections.go (50.4%)</option>
				
				<option value="file5">zeno/internal/slots/database.go (78.3%)</option>
				
				<option value="file6">zeno/internal/slots/excel.go (9.4%)</option>
				
				<option value="file7">zeno/internal/slots/filesystem.go (65.3%)</option>
				
				<option value="file8">zeno/internal/slots/functions.go (83.3%)</option>
				
				<option value="file9">zeno/internal/slots/http.go (40.5%)</option>
				
				<option value="file10">zeno/internal/slots/http_client.go (76.7%)</option>
				
				<option value="file11">zeno/internal/slots/image.go (82.4%)</option>
				
				<option value="file12">zeno/internal/slots/inertia.go (81.0%)</option>
				
				<option value="file13">zeno/internal/slots/job.go (42.5%)</option>
				
				<option value="file14">zeno/internal/slots/json.go (88.2%)</option>
				
				<option value="file15">zeno/internal/slots/logic.go (56.9%)</option>
				
				<option value="file16">zeno/internal/slots/mail.go (97.4%)</option>
				
				<option value="file17">zeno/internal/slots/math.go (82.2%)</option>
				
				<option value="file18">zeno/internal/slots/meta.go (33.3%)</option>
				
				<option value="file19">zeno/internal/slots/network.go (81.2%)</option>
				
				<option value="file20">zeno/internal/slots/orm.go (30.9%)</option>
				
				<option value="file21">zeno/internal/slots/plugin.go (4.2%)</option>
				
				<option value="file22">zeno/internal/slots/query_builder.go (49.9%)</option>
				
				<option value="file23">zeno/internal/slots/router.go (45.0%)</option>
				
				<option value="file24">zeno/internal/slots/schema_builder.go (67.8%)</option>
				
				<option value="file25">zeno/internal/slots/security.go (18.1%)</option>
				
				<option value="file26">zeno/internal/slots/security_ip.go (78.0%)</option>
				
				<option value="file27">zeno/internal/slots/session.go (0.0%)</option>
				
				<option value="file28">zeno/internal/slots/sse.go (66.1%)</option>
				
				<option value="file29">zeno/internal/slots/test.go (74.1%)</option>
				
				<option value="file30">zeno/internal/slots/time.go (62.3%)</option>
				
				<option value="file31">zeno/internal/slots/transaction.go (82.4%)</option>
				
				<option value="file32">zeno/internal/slots/upload.go (87.5%)</option>
				
				<option value="file33">zeno/internal/slots/utils.go (54.8%)</option>
				
				<option value="file34">zeno/internal/slots/validator.go (54.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package slots

import (
        "context"
        "database/sql"
        "fmt"
        "net/http"
        "os"
        "strings"
        "time"
        "zeno/pkg/dbmanager"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"

        "github.com/golang-jwt/jwt/v5"
        "golang.org/x/crypto/bcrypt"
)

func RegisterAuthSlots(eng *engine.Engine, dbMgr *dbmanager.DBManager) <span class="cov8" title="1">{

        // 1. AUTH.LOGIN
        eng.Register("auth.login", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var username, password string
                table := "users"
                colUser := "email"
                colPass := "password"
                jwtSecret := "458127c2cffdd41a448b5d37b825188bf12db10e5c98cb03b681da667ac3b294_pekalongan_kota_2025_!@#_jgn_disebar" // Default from .env
                target := "token"
                dbName := "default"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "username" || c.Name == "email" </span><span class="cov8" title="1">{
                                username = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "password" </span><span class="cov8" title="1">{
                                password = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "table" </span><span class="cov0" title="0">{
                                table = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "col_user" </span><span class="cov8" title="1">{
                                colUser = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "col_pass" </span><span class="cov0" title="0">{
                                colPass = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "secret" </span><span class="cov0" title="0">{
                                jwtSecret = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "db" </span><span class="cov0" title="0">{
                                dbName = coerce.ToString(val)
                        }</span>
                }

                <span class="cov8" title="1">if username == "" || password == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("auth.login: username and password required")
                }</span>

                // DB Lookup
                <span class="cov8" title="1">db := dbMgr.GetConnection(dbName)
                dialect := dbMgr.GetDialect(dbName)
                if db == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("auth.login: database connection '%s' not found", dbName)
                }</span>

                <span class="cov8" title="1">query := fmt.Sprintf("SELECT %s, %s, %s, %s FROM %s WHERE %s = %s%s",
                        dialect.QuoteIdentifier("id"),
                        dialect.QuoteIdentifier("username"),
                        dialect.QuoteIdentifier(colUser),
                        dialect.QuoteIdentifier(colPass),
                        dialect.QuoteIdentifier(table),
                        dialect.QuoteIdentifier(colUser),
                        dialect.Placeholder(1),
                        dialect.Limit(1, 0))

                fmt.Printf("[AUTH DEBUG] Query: %s\n", query)
                fmt.Printf("[AUTH DEBUG] Username: %s, Table: %s, DB: %s\n", username, table, dbName)

                var id int
                var dbUsername, dbUser, dbPass string

                err := db.QueryRowContext(ctx, query, username).Scan(&amp;id, &amp;dbUsername, &amp;dbUser, &amp;dbPass)
                if err != nil </span><span class="cov8" title="1">{
                        fmt.Printf("[AUTH DEBUG] DB Query Error: %v\n", err)
                        return fmt.Errorf("auth.login: invalid credentials")
                }</span>

                <span class="cov8" title="1">fmt.Printf("[AUTH DEBUG] User found: ID=%d, Username=%s, Email=%s\n", id, dbUsername, dbUser)

                // Verify Password
                if err := bcrypt.CompareHashAndPassword([]byte(dbPass), []byte(password)); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[AUTH DEBUG] Password mismatch: %v\n", err)
                        return fmt.Errorf("auth.login: invalid credentials")
                }</span>

                <span class="cov8" title="1">fmt.Printf("[AUTH DEBUG] Password verified successfully\n")

                // Generate JWT
                token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                        "user_id":  id,
                        "username": dbUsername,
                        "email":    dbUser,
                        "exp":      time.Now().Add(time.Hour * 72).Unix(),
                })

                tokenString, err := token.SignedString([]byte(jwtSecret))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">scope.Set(target, tokenString)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Verify user credentials and return a JWT token.",
                Example:     "auth.login\n  username: $user\n  password: $pass\n  as: $token",
                Inputs: map[string]engine.InputMeta{
                        "username": {Description: "Email or Username", Required: false},
                        "email":    {Description: "Alias for username", Required: false},
                        "password": {Description: "Password", Required: true},
                        "table":    {Description: "User table name (Default: 'users')", Required: false},
                        "col_user": {Description: "Email/Username column (Default: 'email')", Required: false},
                        "col_pass": {Description: "Password column (Default: 'password')", Required: false},
                        "secret":   {Description: "JWT Secret key", Required: false},
                        "db":       {Description: "Database connection name (Default: 'default')", Required: false},
                        "as":       {Description: "Variable to store token", Required: false},
                },
        })

        // 2. AUTH.MIDDLEWARE (Guard) - Auto Multi-Tenant Detection
        <span class="cov8" title="1">eng.Register("auth.middleware", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                jwtSecret := "458127c2cffdd41a448b5d37b825188bf12db10e5c98cb03b681da667ac3b294_pekalongan_kota_2025_!@#_jgn_disebar" // Default from .env
                var doNode *engine.Node

                // Parse parameters
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "secret" </span><span class="cov0" title="0">{
                                jwtSecret = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "do" </span><span class="cov0" title="0">{
                                doNode = c
                        }</span>
                }

                // Get HTTP request
                <span class="cov0" title="0">reqVal := ctx.Value("httpRequest")
                if reqVal == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("auth.middleware: not in http context")
                }</span>
                <span class="cov0" title="0">r := reqVal.(*http.Request)

                // [AUTO] Multi-Tenant Detection (ALWAYS enabled for POS API compatibility)
                // Check X-Tenant-ID header first, fallback to subdomain
                tenantID := r.Header.Get("X-Tenant-ID")
                if tenantID == "" </span><span class="cov0" title="0">{
                        // Fallback to subdomain
                        host := r.Host
                        parts := strings.Split(host, ".")
                        if len(parts) &gt;= 2 &amp;&amp; parts[0] != "localhost" &amp;&amp; parts[0] != "127" </span><span class="cov0" title="0">{
                                tenantID = parts[0]
                        }</span>
                }

                // [AUTO] Validate tenant from system database if tenant detected
                <span class="cov0" title="0">if tenantID != "" </span><span class="cov0" title="0">{
                        dbVal := ctx.Value("database")
                        if dbVal != nil </span><span class="cov0" title="0">{
                                db := dbVal.(*sql.DB)

                                var dbConnectionName, tenantName, tenantCode string
                                var isActive bool
                                query := "SELECT code, name, db_connection_name, is_active FROM tenants WHERE code = ? AND is_active = 1 LIMIT 1"
                                err := db.QueryRowContext(ctx, query, tenantID).Scan(&amp;tenantCode, &amp;tenantName, &amp;dbConnectionName, &amp;isActive)

                                if err == nil &amp;&amp; isActive </span><span class="cov0" title="0">{
                                        // Set tenant info in scope (for POS API)
                                        scope.Set("CURRENT_TENANT_DB", dbConnectionName)
                                        scope.Set("CURRENT_TENANT_NAME", tenantName)
                                        scope.Set("CURRENT_TENANT_ID", tenantCode)
                                }</span>
                                // If tenant validation fails, continue anyway (for single-tenant apps)
                        }
                }

                // Get Authorization header
                <span class="cov0" title="0">authHeader := r.Header.Get("Authorization")

                if authHeader == "" </span><span class="cov0" title="0">{
                        // Support Cookie fallback (check 'token' or 'auth_token')
                        if cookie, err := r.Cookie("token"); err == nil </span><span class="cov0" title="0">{
                                authHeader = "Bearer " + cookie.Value
                        }</span> else<span class="cov0" title="0"> if cookie, err := r.Cookie("auth_token"); err == nil </span><span class="cov0" title="0">{
                                authHeader = "Bearer " + cookie.Value
                        }</span>
                }

                // Check Redirect
                <span class="cov0" title="0">redirectURL := ""
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "redirect" </span><span class="cov0" title="0">{
                                redirectURL = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                <span class="cov0" title="0">if authHeader == "" </span><span class="cov0" title="0">{
                        if redirectURL != "" </span><span class="cov0" title="0">{
                                wVal := ctx.Value("httpWriter")
                                if w, ok := wVal.(http.ResponseWriter); ok </span><span class="cov0" title="0">{
                                        http.Redirect(w, r, redirectURL, http.StatusFound)
                                        return ErrReturn // Stop execution
                                }</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("unauthorized: missing token")</span>
                }

                <span class="cov0" title="0">tokenString := strings.TrimPrefix(authHeader, "Bearer ")
                token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        return []byte(jwtSecret), nil
                }</span>)

                <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                        if redirectURL != "" </span><span class="cov0" title="0">{
                                wVal := ctx.Value("httpWriter")
                                if w, ok := wVal.(http.ResponseWriter); ok </span><span class="cov0" title="0">{
                                        http.Redirect(w, r, redirectURL, http.StatusFound)
                                        return ErrReturn // Stop execution
                                }</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("unauthorized: invalid token")</span>
                }

                // Set User to Scope
                <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok </span><span class="cov0" title="0">{
                        scope.Set("session", claims) // Existing behavior for backward compatibility

                        // [AUTO] ALWAYS set $auth object for POS API compatibility
                        authObj := make(map[string]interface{})
                        if userID, ok := claims["user_id"]; ok </span><span class="cov0" title="0">{
                                authObj["user_id"] = userID
                        }</span>
                        <span class="cov0" title="0">if email, ok := claims["email"]; ok </span><span class="cov0" title="0">{
                                authObj["email"] = email
                        }</span>
                        <span class="cov0" title="0">if tid, ok := claims["tenant_id"]; ok </span><span class="cov0" title="0">{
                                authObj["tenant_id"] = tid
                        }</span>
                        <span class="cov0" title="0">if role, ok := claims["role"]; ok </span><span class="cov0" title="0">{
                                authObj["role"] = role
                        }</span>
                        <span class="cov0" title="0">scope.Set("auth", authObj)</span>
                }

                // Exec 'do' block (Protected Routes)
                <span class="cov0" title="0">if doNode != nil </span><span class="cov0" title="0">{
                        for _, child := range doNode.Children </span><span class="cov0" title="0">{
                                if err := eng.Execute(ctx, child, scope); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Protect routes with JWT verification. Supports multi-tenant with subdomain detection.",
                Example:     "auth.middleware {\n  do: {\n     log: 'Hello Admin'\n  }\n}\n\n// Multi-tenant:\nauth.middleware {\n  tenant_header: \"X-Tenant-ID\"\n  tenant_db_lookup: true\n  set_auth_object: true\n  do: { ... }\n}",
                Inputs: map[string]engine.InputMeta{
                        "secret":           {Description: "JWT Secret key", Required: false},
                        "redirect":         {Description: "Login URL for redirect on failure", Required: false},
                        "tenant_header":    {Description: "Header name for tenant ID (fallback to subdomain)", Required: false},
                        "tenant_db_lookup": {Description: "Enable tenant validation from system DB", Required: false},
                        "set_auth_object":  {Description: "Set $auth object with user_id, email, etc", Required: false},
                },
        })

        // 3. AUTH.USER
        <span class="cov8" title="1">eng.Register("auth.user", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                target := "user"

                // auth.user: $current_user
                if node.Value != nil </span><span class="cov0" title="0">{
                        target = strings.TrimPrefix(coerce.ToString(node.Value), "$")
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if val, ok := scope.Get("session"); ok </span><span class="cov8" title="1">{
                        scope.Set(target, val)
                        return nil
                }</span>

                // Fallback: Check cookies and decode JWT
                <span class="cov0" title="0">reqVal := ctx.Value("httpRequest")
                if req, ok := reqVal.(*http.Request); ok </span><span class="cov0" title="0">{
                        var tokenString string
                        if cookie, err := req.Cookie("auth_token"); err == nil </span><span class="cov0" title="0">{
                                tokenString = cookie.Value
                        }</span> else<span class="cov0" title="0"> if cookie, err := req.Cookie("token"); err == nil </span><span class="cov0" title="0">{
                                tokenString = cookie.Value
                        }</span>

                        <span class="cov0" title="0">if tokenString != "" </span><span class="cov0" title="0">{
                                // We need the secret. Since it's not passed here, we use the default
                                // or we could try to find it from env.
                                jwtSecret := os.Getenv("JWT_SECRET")
                                if jwtSecret == "" </span><span class="cov0" title="0">{
                                        jwtSecret = "458127c2cffdd41a448b5d37b825188bf12db10e5c98cb03b681da667ac3b294_pekalongan_kota_2025_!@#_jgn_disebar"
                                }</span>

                                <span class="cov0" title="0">token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                                        return []byte(jwtSecret), nil
                                }</span>)

                                <span class="cov0" title="0">if err == nil &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                                        if claims, ok := token.Claims.(jwt.MapClaims); ok </span><span class="cov0" title="0">{
                                                scope.Set(target, claims)
                                                return nil
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">scope.Set(target, nil)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Retrieve user data from current session.",
                Example:     "auth.user: $current_user",
                Inputs: map[string]engine.InputMeta{
                        "as": {Description: "Variable to store user data", Required: false},
                },
        })

        // 4. JWT.SIGN
        <span class="cov8" title="1">eng.Register("jwt.sign", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var secret string
                expiresIn := int64(86400) // 24 hours default
                target := "token"
                claims := make(map[string]interface{})

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "secret" </span><span class="cov8" title="1">{
                                secret = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "expires_in" || c.Name == "expiry" </span><span class="cov0" title="0">{
                                expiresIn, _ = coerce.ToInt64(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "claims" </span><span class="cov8" title="1">{
                                // Parse claims as map
                                if claimsVal := parseNodeValue(c, scope); claimsVal != nil </span><span class="cov8" title="1">{
                                        if claimsMap, ok := claimsVal.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                                claims = claimsMap
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">if secret == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("jwt.sign: secret is required")
                }</span>

                // Add expiry to claims
                <span class="cov8" title="1">claims["exp"] = time.Now().Add(time.Duration(expiresIn) * time.Second).Unix()
                claims["iat"] = time.Now().Unix()

                // Generate JWT
                token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims(claims))
                tokenString, err := token.SignedString([]byte(secret))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("jwt.sign: failed to sign token: %v", err)
                }</span>

                <span class="cov8" title="1">scope.Set(target, tokenString)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Generate JWT token with custom claims",
                Example:     "jwt.sign:\n  secret: env(\"JWT_SECRET\")\n  claims: { user_id: $user.id }\n  expires_in: 86400\n  as: $token",
                Inputs: map[string]engine.InputMeta{
                        "secret":     {Description: "JWT Secret key", Required: true},
                        "claims":     {Description: "Token claims as map", Required: true},
                        "expires_in": {Description: "Expiry in seconds (default: 86400)", Required: false},
                        "as":         {Description: "Variable to store token", Required: false},
                },
        })

        // 5. JWT.VERIFY
        <span class="cov8" title="1">eng.Register("jwt.verify", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var tokenString, secret string
                target := "claims"

                // Support direct value: jwt.verify: $token
                if node.Value != nil </span><span class="cov0" title="0">{
                        tokenString = coerce.ToString(resolveValue(node.Value, scope))
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "token" || c.Name == "val" </span><span class="cov8" title="1">{
                                tokenString = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "secret" </span><span class="cov8" title="1">{
                                secret = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                // Jika secret kosong, cari dari environment global atau default
                <span class="cov8" title="1">if secret == "" </span><span class="cov0" title="0">{
                        secret = "458127c2cffdd41a448b5d37b825188bf12db10e5c98cb03b681da667ac3b294_pekalongan_kota_2025_!@#_jgn_disebar" // Default from .env
                }</span>

                <span class="cov8" title="1">token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        return []byte(secret), nil
                }</span>)

                <span class="cov8" title="1">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                        return fmt.Errorf("jwt.verify: invalid token or expired")
                }</span>

                <span class="cov8" title="1">if claims, ok := token.Claims.(jwt.MapClaims); ok </span><span class="cov8" title="1">{
                        scope.Set(target, claims)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("jwt.verify: invalid claims structure")
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Explicitly verify a JWT token and retrieve its claims.",
                Example:     "jwt.verify: $token\n  secret: 'shhh'\n  as: $user_data",
                Inputs: map[string]engine.InputMeta{
                        "token":  {Description: "Token String", Required: false},
                        "secret": {Description: "Secret Key", Required: false},
                        "as":     {Description: "Resulting claims", Required: false},
                },
        })

        // 5. JWT.REFRESH
        <span class="cov8" title="1">eng.Register("jwt.refresh", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                // Disclaimer: Simple refresh (create new token with new expiry based on old claims)
                // NOT implementing refresh token rotation with DB lookup in this slot for simplicity.
                var tokenString, secret string
                expirySeconds := int64(86400) // 24 Hours default
                target := "new_token"

                if node.Value != nil </span><span class="cov0" title="0">{
                        tokenString = coerce.ToString(resolveValue(node.Value, scope))
                }</span>

                <span class="cov0" title="0">for _, c := range node.Children </span><span class="cov0" title="0">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "token" </span><span class="cov0" title="0">{
                                tokenString = coerce.ToString(val)
                        }</span>
                        <span class="cov0" title="0">if c.Name == "secret" </span><span class="cov0" title="0">{
                                secret = coerce.ToString(val)
                        }</span>
                        <span class="cov0" title="0">if c.Name == "expiry" </span><span class="cov0" title="0">{
                                expirySeconds, _ = coerce.ToInt64(val)
                        }</span>
                        <span class="cov0" title="0">if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">if secret == "" </span><span class="cov0" title="0">{
                        secret = "458127c2cffdd41a448b5d37b825188bf12db10e5c98cb03b681da667ac3b294_pekalongan_kota_2025_!@#_jgn_disebar" // Default from .env
                }</span>

                // Parse token (even if expired, we might want to allow refresh if within grace period - but here we require valid signature)
                <span class="cov0" title="0">token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        return []byte(secret), nil
                }</span>)

                // Note: jwt.Parse usually errors if expired.
                // For refresh flow, we might need ParseUnverified or custom checking.
                // Here we assume client sends a STILL VALID token to get a new one (short lived rotation).

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        // Try parsing without validation to extract claims if it's just expired
                        // But for security, let's stick to requiring a valid token or handle error externally.
                        return fmt.Errorf("jwt.refresh: invalid source token")
                }</span>

                <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok </span><span class="cov0" title="0">{
                        // Update Exp
                        claims["exp"] = time.Now().Add(time.Duration(expirySeconds) * time.Second).Unix()

                        newToken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
                        signedStr, err := newToken.SignedString([]byte(secret))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">scope.Set(target, signedStr)</span>
                }

                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Refresh JWT token with a new expiration.",
                Example:     "jwt.refresh: $old_token\n  as: $new_token",
        })
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package slots

import (
        "context"
        "fmt"
        "net/http"
        "net/http/httptest"
        "os"
        "path/filepath"
        "sync"
        "time"

        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"

        "html"

        "github.com/gorilla/csrf"
)

// Blade Template Cache
var (
        bladeCache sync.Map // map[string]*cachedTemplate
)

type cachedTemplate struct {
        ast     *engine.Node
        modTime time.Time
}

func ensureBladeExt(path string) string <span class="cov8" title="1">{
        if !strings.HasSuffix(path, ".blade.zl") </span><span class="cov8" title="1">{
                return path + ".blade.zl"
        }</span>
        <span class="cov8" title="1">return path</span>
}

func RegisterBladeSlots(eng *engine.Engine) <span class="cov8" title="1">{
        RegisterLogicSlots(eng)

        // 1. Helper Slot for Writing to Response (Internal)
        eng.Register("__native_write", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">val := resolveValue(node.Value, scope)
                str := coerce.ToString(val)
                w.Write([]byte(str))
                return nil</span>
        }, engine.SlotMeta{Description: "Internal write for native blade"})

        <span class="cov8" title="1">eng.Register("__native_write_safe", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">val := resolveValue(node.Value, scope)
                str := coerce.ToString(val)
                safeStr := html.EscapeString(str)
                w.Write([]byte(safeStr))
                return nil</span>
        }, engine.SlotMeta{Description: "Internal safe write for native blade"})

        // 2. Slot Utama: view.blade
        <span class="cov8" title="1">eng.Register("view.blade", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // Set Content-Type header for HTML responses
                if w, ok := ctx.Value("httpWriter").(http.ResponseWriter); ok </span><span class="cov8" title="1">{
                        w.Header().Set("Content-Type", "text/html; charset=utf-8")
                }</span>

                // Inject CSRF if available
                <span class="cov8" title="1">if r, ok := ctx.Value("httpRequest").(*http.Request); ok </span><span class="cov0" title="0">{
                        scope.Set("csrf_field", csrf.TemplateField(r))
                        scope.Set("csrf_token", csrf.Token(r))
                }</span>

                <span class="cov8" title="1">var viewFile string
                if node.Value != nil </span><span class="cov8" title="1">{
                        viewFile = coerce.ToString(resolveValue(node.Value, scope))
                }</span>

                // Fallback check children
                <span class="cov8" title="1">if viewFile == "" </span><span class="cov0" title="0">{
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "file" </span><span class="cov0" title="0">{
                                        viewFile = coerce.ToString(resolveValue(c.Value, scope))
                                        continue</span>
                                }
                                // Bind attribute to scope
                                <span class="cov0" title="0">val := parseNodeValue(c, scope)
                                scope.Set(c.Name, val)</span>
                        }
                } else<span class="cov8" title="1"> {
                        // Extract other children if viewFile was set by Value
                        for _, c := range node.Children </span><span class="cov8" title="1">{
                                // Bind attribute to scope
                                val := parseNodeValue(c, scope)
                                scope.Set(c.Name, val)
                        }</span>
                }

                <span class="cov8" title="1">if viewFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("view.blade.native: file required")
                }</span>

                <span class="cov8" title="1">fullPath := filepath.Join("views", ensureBladeExt(viewFile))

                // Use cache for performance
                programNode, err := getCachedOrParse(fullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Execute normally
                <span class="cov8" title="1">return eng.Execute(ctx, programNode, scope)</span>

        }, engine.SlotMeta{Description: "Render Blade natively using ZenoLang AST."})

        // 3. Section System (Layouts)
        <span class="cov8" title="1">eng.Register("section.define", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                name := coerce.ToString(resolveValue(node.Value, scope))
                var body *engine.Node

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "do" </span><span class="cov8" title="1">{
                                body = c
                        }</span>
                }

                <span class="cov8" title="1">if body != nil </span><span class="cov8" title="1">{
                        sectionsRaw, ok := scope.Get("__sections")
                        var sections map[string]*engine.Node
                        if !ok || sectionsRaw == nil </span><span class="cov8" title="1">{
                                sections = make(map[string]*engine.Node)
                        }</span> else<span class="cov0" title="0"> {
                                sections = sectionsRaw.(map[string]*engine.Node)
                        }</span>
                        <span class="cov8" title="1">sections[name] = body
                        scope.Set("__sections", sections)</span>
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{Description: "Define a layout section"})

        <span class="cov8" title="1">eng.Register("section.yield", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                name := coerce.ToString(resolveValue(node.Value, scope))

                sectionsRaw, ok := scope.Get("__sections")
                if !ok || sectionsRaw == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">sections := sectionsRaw.(map[string]*engine.Node)
                if body, found := sections[name]; found </span><span class="cov8" title="1">{
                        for _, child := range body.Children </span><span class="cov8" title="1">{
                                if err := eng.Execute(ctx, child, scope); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{Description: "Yield a layout section"})

        <span class="cov8" title="1">eng.Register("view.extends", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                layoutFile := coerce.ToString(resolveValue(node.Value, scope))
                if layoutFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("view.extends: file required")
                }</span>

                <span class="cov8" title="1">fullPath := filepath.Join("views", ensureBladeExt(layoutFile))

                // Use cache for performance
                layoutRoot, err := getCachedOrParse(fullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return eng.Execute(ctx, layoutRoot, scope)</span>
        }, engine.SlotMeta{Description: "Extend a layout"})

        <span class="cov8" title="1">eng.Register("view.component", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // Value: "component-name"
                compName := coerce.ToString(resolveValue(node.Value, scope))
                if compName == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Map name to path: x-alert -&gt; components/alert.blade.zl
                // x-user.profile -&gt; components/user/profile.blade.zl
                // Logic: replace . with /
                <span class="cov8" title="1">compPath := strings.ReplaceAll(compName, ".", "/")
                fullPath := filepath.Join("views", "components", compPath+".blade.zl")

                // 1. Prepare Component Scope
                // Use empty scope for isolation (Components must declare props)
                newScope := engine.NewScope(nil)

                // 2. Process Attributes
                // Attributes are children with Name="attr" or similar?
                // In transpile, we will map attributes to children nodes.
                // e.g. &lt;x-alert type="error"&gt; -&gt; Children: [ {Name:"type", Value:"error"} ]
                // Also slots.

                var slotContent string
                slots := make(map[string]string)

                for _, child := range node.Children </span><span class="cov8" title="1">{
                        if child.Name == "slot" </span><span class="cov8" title="1">{
                                // Named Slot
                                // Render it to string
                                // It shouldn't execute "do" immediately?
                                // We need to capture the output of this block.
                                // We can use a temporary recorder.
                                rec := httptest.NewRecorder()
                                subCtx := context.WithValue(ctx, "httpWriter", http.ResponseWriter(rec))

                                // Execute children of slot
                                for _, c := range child.Children </span><span class="cov8" title="1">{
                                        eng.Execute(subCtx, c, scope) // Use OUTER scope for slot content! (Important: lexical scoping)
                                }</span>
                                <span class="cov8" title="1">slots[child.Value.(string)] = rec.Body.String()</span>

                        } else<span class="cov8" title="1"> if child.Name == "default_slot" </span><span class="cov8" title="1">{
                                rec := httptest.NewRecorder()
                                subCtx := context.WithValue(ctx, "httpWriter", http.ResponseWriter(rec))
                                for _, c := range child.Children </span><span class="cov8" title="1">{
                                        eng.Execute(subCtx, c, scope)
                                }</span>
                                <span class="cov8" title="1">slotContent = rec.Body.String()</span>

                        } else<span class="cov8" title="1"> {
                                // Attribute
                                // Name=VarName, Value=Val
                                // Resolve Value
                                val := resolveValue(child.Value, scope)
                                newScope.Set(child.Name, val)
                        }</span>
                }

                // Bind Slots
                <span class="cov8" title="1">newScope.Set("slot", slotContent) // Htmlable technically, but string here.
                for k, v := range slots </span><span class="cov8" title="1">{
                        newScope.Set(k, v) // $header, $footer
                }</span>

                // 3. Render View (with caching)
                <span class="cov8" title="1">compRoot, err := getCachedOrParse(fullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return eng.Execute(ctx, compRoot, newScope)</span>

        }, engine.SlotMeta{Description: "Render a Blade Component"})

        <span class="cov8" title="1">eng.Register("view.include", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                viewFile := coerce.ToString(resolveValue(node.Value, scope))
                if viewFile == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">fullPath := filepath.Join("views", ensureBladeExt(viewFile))

                // Parse Child Data
                var includeData map[string]interface{}

                if len(node.Children) &gt; 0 </span><span class="cov8" title="1">{
                        dataNode := node.Children[0]
                        if dataNode.Name == "data_map" </span><span class="cov8" title="1">{
                                includeData = make(map[string]interface{})
                                for _, child := range dataNode.Children </span><span class="cov8" title="1">{
                                        valStr := coerce.ToString(child.Value)
                                        if strings.HasPrefix(valStr, "$") </span><span class="cov0" title="0">{
                                                resolved, _ := scope.Get(strings.TrimPrefix(valStr, "$"))
                                                includeData[child.Name] = resolved
                                        }</span> else<span class="cov8" title="1"> {
                                                includeData[child.Name] = valStr
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> if dataNode.Name == "data_var" </span><span class="cov0" title="0">{
                                val := resolveValue(dataNode.Value, scope)
                                if m, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        includeData = m
                                }</span>
                        }
                }

                // Create Inner Scope
                <span class="cov8" title="1">innerScope := scope.Clone()
                for k, v := range includeData </span><span class="cov8" title="1">{
                        innerScope.Set(k, v)
                }</span>

                // Use cache for performance
                <span class="cov8" title="1">transpiled, err := getCachedOrParse(fullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return eng.Execute(ctx, transpiled, innerScope)</span>
        }, engine.SlotMeta{Description: "Include a partial view"})

        <span class="cov8" title="1">eng.Register("view.push", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                name := coerce.ToString(resolveValue(node.Value, scope))
                var body *engine.Node
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "do" </span><span class="cov8" title="1">{
                                body = c
                        }</span>
                }

                <span class="cov8" title="1">if body != nil </span><span class="cov8" title="1">{
                        stacksRaw, ok := scope.Get("__stacks")
                        var stacks map[string][]*engine.Node
                        if !ok || stacksRaw == nil </span><span class="cov8" title="1">{
                                stacks = make(map[string][]*engine.Node)
                        }</span> else<span class="cov0" title="0"> {
                                stacks = stacksRaw.(map[string][]*engine.Node)
                        }</span>

                        // Append Body to Stack List
                        <span class="cov8" title="1">stacks[name] = append(stacks[name], body)
                        scope.Set("__stacks", stacks)</span>
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{Description: "Push content to stack"})

        <span class="cov8" title="1">eng.Register("view.stack", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                name := coerce.ToString(resolveValue(node.Value, scope))

                stacksRaw, ok := scope.Get("__stacks")
                if !ok || stacksRaw == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">stacks := stacksRaw.(map[string][]*engine.Node)
                if nodes, found := stacks[name]; found </span><span class="cov8" title="1">{
                        for _, n := range nodes </span><span class="cov8" title="1">{
                                // Execute the pushed block
                                // Since push block is "do", iterate children
                                for _, child := range n.Children </span><span class="cov8" title="1">{
                                        if err := eng.Execute(ctx, child, scope); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{Description: "Render stack content"})

        <span class="cov8" title="1">eng.Register("view.class", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">var classes []string

                if len(node.Children) &gt; 0 </span><span class="cov8" title="1">{
                        dataNode := node.Children[0]
                        if dataNode.Name == "data_map" </span><span class="cov8" title="1">{
                                for _, child := range dataNode.Children </span><span class="cov8" title="1">{
                                        valStr := coerce.ToString(child.Value)
                                        var cond bool
                                        if strings.HasPrefix(valStr, "$") </span><span class="cov8" title="1">{
                                                resolved, _ := scope.Get(strings.TrimPrefix(valStr, "$"))
                                                cond, _ = coerce.ToBool(resolved)
                                        }</span> else<span class="cov8" title="1"> {
                                                if valStr == "true" </span><span class="cov8" title="1">{
                                                        cond = true
                                                }</span> else<span class="cov8" title="1"> {
                                                        cond, _ = coerce.ToBool(valStr)
                                                }</span>
                                        }

                                        <span class="cov8" title="1">if cond </span><span class="cov8" title="1">{
                                                classes = append(classes, child.Name)
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">if len(classes) &gt; 0 </span><span class="cov8" title="1">{
                        out := fmt.Sprintf(`class="%s"`, strings.Join(classes, " "))
                        w.Write([]byte(out))
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{Description: "Render Blade @class"})
}

// ==========================================
// BLADE TEMPLATE CACHE HELPERS
// ==========================================

// getCachedOrParse retrieves a cached template or parses it if not cached/outdated
func getCachedOrParse(fullPath string) (*engine.Node, error) <span class="cov8" title="1">{
        // Check cache
        if cached, ok := bladeCache.Load(fullPath); ok </span><span class="cov8" title="1">{
                ct := cached.(*cachedTemplate)

                // In production, always use cache
                if os.Getenv("APP_ENV") == "production" </span><span class="cov0" title="0">{
                        return ct.ast, nil
                }</span>

                // In development, check if file changed
                <span class="cov8" title="1">fileInfo, err := os.Stat(fullPath)
                if err == nil &amp;&amp; fileInfo.ModTime().Equal(ct.modTime) </span><span class="cov8" title="1">{
                        return ct.ast, nil // Cache hit
                }</span>
        }

        // Cache miss or file changed - parse
        <span class="cov8" title="1">return parseAndCache(fullPath)</span>
}

// parseAndCache reads, parses, and caches a Blade template
func parseAndCache(fullPath string) (*engine.Node, error) <span class="cov8" title="1">{
        contentBytes, err := os.ReadFile(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("view not found: %s", fullPath)
        }</span>

        <span class="cov8" title="1">programNode, err := transpileBladeNative(string(contentBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get file mod time
        <span class="cov8" title="1">fileInfo, _ := os.Stat(fullPath)

        // Store in cache
        bladeCache.Store(fullPath, &amp;cachedTemplate{
                ast:     programNode,
                modTime: fileInfo.ModTime(),
        })

        return programNode, nil</span>
}

// ClearBladeCache clears all cached Blade templates
// This should be called when view files change during development
func ClearBladeCache() <span class="cov8" title="1">{
        bladeCache.Range(func(key, value interface{}) bool </span><span class="cov8" title="1">{
                bladeCache.Delete(key)
                return true
        }</span>)
}

// === NATIVE TRANSPILER ===
// Converts Blade string to *engine.Node (Root "do" block)
func transpileBladeNative(content string) (*engine.Node, error) <span class="cov8" title="1">{
        root := &amp;engine.Node{
                Name:     "do",
                Children: []*engine.Node{},
        }

        // Simple: Tokenize based on {{ }} and @if/@endif
        // Since it's a nested structure, we need parser state.

        // Use a simple scanner approach.
        // 1. Scan Text until {{ or @ is found
        // 2. If {{ -&gt; parse variable -&gt; add __native_write node
        // 3. If @if -&gt; parse condition -&gt; recursive parse body -&gt; add if node
        // 4. If @foreach -&gt; parse loop -&gt; recursive parse body -&gt; add foreach/range node

        // Cursor position
        pos := 0
        length := len(content)

        // Extensions
        var extendsFile string

        for pos &lt; length </span><span class="cov8" title="1">{
                // Find Logic Start
                nextTag := strings.IndexAny(content[pos:], "@{\n&lt;")
                if nextTag == -1 </span><span class="cov8" title="1">{
                        // Sisa text
                        text := content[pos:]
                        if text != "" </span><span class="cov8" title="1">{
                                root.Children = append(root.Children, createWriteNode(text))
                        }</span>
                        <span class="cov8" title="1">break</span>
                }

                // Text before tag
                <span class="cov8" title="1">offset := pos + nextTag
                if offset &gt; pos </span><span class="cov8" title="1">{
                        text := content[pos:offset]
                        root.Children = append(root.Children, createWriteNode(text))
                }</span>

                <span class="cov8" title="1">pos = offset

                // Check tag type
                if strings.HasPrefix(content[pos:], "{{--") </span><span class="cov0" title="0">{
                        // Comment
                        endComment := strings.Index(content[pos:], "--}}")
                        if endComment != -1 </span><span class="cov0" title="0">{
                                pos += endComment + 4
                        }</span> else<span class="cov0" title="0"> {
                                pos = length // Unterminated
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "{!!") </span><span class="cov8" title="1">{
                        // Unescaped Echo
                        endEcho := strings.Index(content[pos:], "!!}")
                        if endEcho != -1 </span><span class="cov8" title="1">{
                                raw := content[pos+3 : pos+endEcho]
                                varVal := strings.TrimSpace(raw)

                                // Standard __native_write (Raw)
                                root.Children = append(root.Children, &amp;engine.Node{
                                        Name:  "__native_write",
                                        Value: varVal,
                                })

                                pos += endEcho + 3
                        }</span> else<span class="cov0" title="0"> {
                                root.Children = append(root.Children, createWriteNode("{!!"))
                                pos += 3
                        }</span>

                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "{{") </span><span class="cov8" title="1">{
                        // ... Echo (Existing) ...
                        endEcho := strings.Index(content[pos:], "}}")
                        if endEcho != -1 </span><span class="cov8" title="1">{
                                raw := content[pos+2 : pos+endEcho]
                                varVal := strings.TrimSpace(raw)

                                // Check for function call: Name(...)
                                if strings.Contains(varVal, "(") &amp;&amp; strings.HasSuffix(varVal, ")") </span><span class="cov8" title="1">{
                                        // Parse Function Call
                                        funcName := varVal[:strings.Index(varVal, "(")]
                                        argsRaw := varVal[strings.Index(varVal, "(")+1 : len(varVal)-1]

                                        // Split args by comma (simple split, assumes no commas in strings for now)
                                        // TODO: Robust arg parsing
                                        args := strings.Split(argsRaw, ",")
                                        var children []*engine.Node

                                        for _, arg := range args </span><span class="cov8" title="1">{
                                                arg = strings.TrimSpace(arg)
                                                if arg == "" </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }

                                                // Determine type
                                                <span class="cov8" title="1">if strings.HasPrefix(arg, "\"") || strings.HasPrefix(arg, "'") </span><span class="cov8" title="1">{
                                                        // String literal
                                                        val := strings.Trim(arg, "\"'")
                                                        children = append(children, &amp;engine.Node{Name: "arg", Value: val}) // Literal
                                                }</span> else<span class="cov8" title="1"> {
                                                        // Variable
                                                        children = append(children, &amp;engine.Node{Name: "arg", Value: arg}) // Variable
                                                }</span>
                                        }

                                        // If function, we MIGHT want to escape result too?
                                        // Standard Blade escapes result of function calls unless they return HtmlString.
                                        // For now, let's wrap result in Escape?
                                        // But we are returning an engine.Node which executes a slot.
                                        // If the slot writes to writer directly, we can't capture and escape easily here unless we wrap execution.
                                        // OR we assume Function Slots are responsible for safety if called directly?
                                        // Safest approach: The Function Slot executes logic.
                                        // Ideally we should use __native_write_safe with value as function execution result.
                                        // But current AST structure is: Node(Name=FuncName).
                                        // The FuncName slot executes.
                                        // If we want to escape, we need: Node(Name=__native_write_safe, Value=Node(Name=FuncName...))?
                                        // But our engine doesn't resolve Node as Value recursively like that easily for slots that don't return values but write to stream.
                                        // Many Zeno slots write to stream directly (echo, logic.json).
                                        // If the function slot writes to stream, we can't intercept easily without capturing.
                                        //
                                        // ALLOWANCE: For function calls inside {{ }}, we will KEEP existing behavior (direct execution) for now
                                        // to avoid breaking custom slots that expect to write HTML (like form builders).
                                        // Users should use __native_write_safe concept manually if needed or we upgrade engine later.
                                        // BUT standard variables MUST be escaped.

                                        <span class="cov8" title="1">root.Children = append(root.Children, &amp;engine.Node{
                                                Name:     funcName,
                                                Children: children,
                                        })</span>
                                } else<span class="cov8" title="1"> {
                                        root.Children = append(root.Children, &amp;engine.Node{
                                                Name:  "__native_write_safe", // CHANGED TO SAFE
                                                Value: varVal,
                                        })
                                }</span>
                                <span class="cov8" title="1">pos += endEcho + 2</span>
                        } else<span class="cov0" title="0"> {
                                root.Children = append(root.Children, createWriteNode("{{"))
                                pos += 2
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@csrf") </span><span class="cov8" title="1">{
                        // @csrf -&gt; {{ $.csrf_field }}
                        // We can emit a write node that will be resolved at runtime
                        // if we assume $.csrf_field is in scope.
                        // Or explicitly fetch csrf token?
                        // "view.blade" handler puts csrf_field in scope?
                        // Let's check view.blade (formerly view.blade.native) implementation.
                        // It calls `ctx.Value("httpRequest")`... wait?
                        // The OLD view.blade did.
                        // The NEW view.blade (native) does NOT seems to inject CSRF yet!
                        // I need to fix that too.
                        // For now, transpile to echo variable.
                        root.Children = append(root.Children, &amp;engine.Node{
                                Name:  "__native_write", // CSRF field is HTML, must be raw
                                Value: "$csrf_field",
                        })
                        pos += 5
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@method") </span><span class="cov8" title="1">{
                        // @method('PUT')
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])

                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                methodRaw := content[pos+startParen+1 : pos+endParen]
                                methodVal := strings.Trim(methodRaw, "'\" ")

                                htmlOutput := fmt.Sprintf(`&lt;input type="hidden" name="_method" value="%s"&gt;`, methodVal)
                                root.Children = append(root.Children, createWriteNode(htmlOutput))

                                pos += endParen + 1
                        }</span> else<span class="cov0" title="0"> {
                                pos += 7
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@include") </span><span class="cov8" title="1">{
                        // @include('view.name', ['key' =&gt; 'val'])
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])

                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                argsRaw := content[pos+startParen+1 : pos+endParen]
                                // Parse Args: ViewName, Data
                                args := splitBladeArgs(argsRaw)

                                viewNameRaw := strings.Trim(args[0], "'\" ")

                                includeNode := &amp;engine.Node{
                                        Name:  "view.include",
                                        Value: viewNameRaw,
                                }

                                if len(args) &gt; 1 </span><span class="cov8" title="1">{
                                        dataRaw := strings.TrimSpace(args[1])
                                        // Parse Data Dict ['k'=&gt;'v'] or variable $data
                                        dataNode := parseBladeData(dataRaw)
                                        if dataNode != nil </span><span class="cov8" title="1">{
                                                includeNode.Children = append(includeNode.Children, dataNode)
                                        }</span>
                                }

                                <span class="cov8" title="1">root.Children = append(root.Children, includeNode)
                                pos += endParen + 1</span>
                        } else<span class="cov0" title="0"> {
                                pos += 8 // @include
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@class") </span><span class="cov8" title="1">{
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])

                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                argsRaw := content[pos+startParen+1 : pos+endParen]
                                dataNode := parseBladeData(argsRaw)
                                if dataNode != nil </span><span class="cov8" title="1">{
                                        classNode := &amp;engine.Node{
                                                Name:     "view.class",
                                                Children: []*engine.Node{dataNode},
                                        }
                                        root.Children = append(root.Children, classNode)
                                }</span>
                                <span class="cov8" title="1">pos += endParen + 1</span>
                        } else<span class="cov0" title="0"> {
                                pos += 6
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@zeno") </span><span class="cov8" title="1">{
                        blockStart := pos + 5
                        blockEnd := strings.Index(content[blockStart:], "@endzeno")
                        if blockEnd == -1 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unclosed @zeno")
                        }</span>
                        <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                        codeRaw := content[blockStart:absoluteBlockEnd]

                        parsedNode, err := engine.ParseString(codeRaw, "blade_zeno_block")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("compile error in @zeno block: %v", err)
                        }</span>
                        <span class="cov8" title="1">if parsedNode != nil </span><span class="cov8" title="1">{
                                root.Children = append(root.Children, parsedNode.Children...)
                        }</span>
                        <span class="cov8" title="1">pos = absoluteBlockEnd + 8</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@php") </span><span class="cov8" title="1">{
                        blockStart := pos + 4
                        blockEnd := strings.Index(content[blockStart:], "@endphp")
                        if blockEnd == -1 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unclosed @php")
                        }</span>
                        <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                        codeRaw := content[blockStart:absoluteBlockEnd]

                        parsedNode, err := engine.ParseString(codeRaw, "blade_php_block")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("compile error in @php block: %v", err)
                        }</span>
                        <span class="cov8" title="1">if parsedNode != nil </span><span class="cov8" title="1">{
                                root.Children = append(root.Children, parsedNode.Children...)
                        }</span>
                        <span class="cov8" title="1">pos = absoluteBlockEnd + 7</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@extends") </span><span class="cov8" title="1">{
                        // @extends('layout')
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])
                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                valRaw := content[pos+startParen+1 : pos+endParen]
                                // Strip quotes
                                valRaw = strings.Trim(valRaw, "'\"")
                                extendsFile = valRaw
                                pos += endParen + 1 // Skip )
                        }</span> else<span class="cov0" title="0"> {
                                pos += 8
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@section") </span><span class="cov8" title="1">{
                        // @section('name') ... @endsection
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])

                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                nameRaw := content[pos+startParen+1 : pos+endParen]
                                nameRaw = strings.Trim(nameRaw, "'\"")

                                blockStart := pos + endParen + 1
                                blockEnd := findEndSection(content[blockStart:])

                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("unclosed @section")
                                }</span>

                                <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                bodyContent := content[blockStart:absoluteBlockEnd]
                                bodyNode, err := transpileBladeNative(bodyContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                // section.define node
                                <span class="cov8" title="1">sectionNode := &amp;engine.Node{
                                        Name:  "section.define",
                                        Value: nameRaw,
                                        Children: []*engine.Node{
                                                {Name: "do", Children: bodyNode.Children},
                                        },
                                }
                                root.Children = append(root.Children, sectionNode)

                                pos = absoluteBlockEnd + 11</span> // @endsection
                        } else<span class="cov0" title="0"> {
                                pos += 8
                        }</span>

                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@isset") </span><span class="cov8" title="1">{
                        // @isset($var)
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])

                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                valRaw := content[pos+startParen+1 : pos+endParen]

                                blockStart := pos + endParen + 1
                                blockEnd := findEndIsset(content[blockStart:])

                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("unclosed @isset")
                                }</span>

                                <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                bodyContent := content[blockStart:absoluteBlockEnd]
                                bodyNode, err := transpileBladeNative(bodyContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">node := &amp;engine.Node{
                                        Name:  "isset",
                                        Value: valRaw,
                                        Children: []*engine.Node{
                                                {Name: "do", Children: bodyNode.Children},
                                        },
                                }
                                root.Children = append(root.Children, node)
                                pos = absoluteBlockEnd + 9</span> // @endisset
                        } else<span class="cov0" title="0"> {
                                pos += 6
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@empty") </span><span class="cov8" title="1">{
                        // @empty($var)
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])

                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                valRaw := content[pos+startParen+1 : pos+endParen]

                                blockStart := pos + endParen + 1
                                blockEnd := findEndEmpty(content[blockStart:])

                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("unclosed @empty")
                                }</span>

                                <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                bodyContent := content[blockStart:absoluteBlockEnd]
                                bodyNode, err := transpileBladeNative(bodyContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">node := &amp;engine.Node{
                                        Name:  "empty",
                                        Value: valRaw,
                                        Children: []*engine.Node{
                                                {Name: "do", Children: bodyNode.Children},
                                        },
                                }
                                root.Children = append(root.Children, node)
                                pos = absoluteBlockEnd + 9</span> // @endempty
                        } else<span class="cov0" title="0"> {
                                pos += 6
                        }</span>

                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@auth") </span><span class="cov8" title="1">{
                        // @auth ... @endauth
                        // @auth('guard') supported? Usually yes.
                        // Simple version for now

                        // Optional parens
                        // Check if ( follows immediately
                        blockStart := pos + 5
                        if strings.HasPrefix(content[pos:], "@auth(") </span><span class="cov0" title="0">{
                                // Has guard arg, ignore for now but parse parens
                                endParen := findBalancedParen(content[pos:])
                                if endParen != -1 </span><span class="cov0" title="0">{
                                        blockStart = pos + endParen + 1
                                }</span>
                        }

                        <span class="cov8" title="1">blockEnd := findEndAuth(content[blockStart:])
                        if blockEnd == -1 </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("unclosed @auth")
                        }</span>

                        <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                        bodyContent := content[blockStart:absoluteBlockEnd]
                        bodyNode, err := transpileBladeNative(bodyContent)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">node := &amp;engine.Node{
                                Name: "auth",
                                Children: []*engine.Node{
                                        {Name: "do", Children: bodyNode.Children},
                                },
                        }
                        root.Children = append(root.Children, node)
                        pos = absoluteBlockEnd + 8</span> // @endauth

                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@guest") </span><span class="cov8" title="1">{
                        // @guest ... @endguest
                        blockStart := pos + 6
                        if strings.HasPrefix(content[pos:], "@guest(") </span><span class="cov0" title="0">{
                                endParen := findBalancedParen(content[pos:])
                                if endParen != -1 </span><span class="cov0" title="0">{
                                        blockStart = pos + endParen + 1
                                }</span>
                        }

                        <span class="cov8" title="1">blockEnd := findEndGuest(content[blockStart:])
                        if blockEnd == -1 </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("unclosed @guest")
                        }</span>

                        <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                        bodyContent := content[blockStart:absoluteBlockEnd]
                        bodyNode, err := transpileBladeNative(bodyContent)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">node := &amp;engine.Node{
                                Name: "guest",
                                Children: []*engine.Node{
                                        {Name: "do", Children: bodyNode.Children},
                                },
                        }
                        root.Children = append(root.Children, node)
                        pos = absoluteBlockEnd + 9</span> // @endguest

                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@json") </span><span class="cov8" title="1">{
                        // @json($data)
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])

                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                valRaw := content[pos+startParen+1 : pos+endParen]

                                // Strip quotes? Variable mostly.
                                // If literal?

                                node := &amp;engine.Node{
                                        Name:  "json",
                                        Value: valRaw, // logic.json will resolve this
                                }
                                root.Children = append(root.Children, node)
                                pos = pos + endParen + 1
                        }</span> else<span class="cov0" title="0"> {
                                pos += 5
                        }</span>

                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@for") </span><span class="cov8" title="1">{
                        // Check for @foreach first!
                        if strings.HasPrefix(content[pos:], "@foreach") </span><span class="cov8" title="1">{
                                // ... Foreach Logic (Existing) ...
                                startParen := strings.Index(content[pos:], "(")
                                endParen := findBalancedParen(content[pos:])
                                if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                        defRaw := content[pos+startParen+1 : pos+endParen]
                                        parts := strings.Split(defRaw, " as ")
                                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                                listVar := strings.TrimSpace(parts[0])
                                                itemVar := strings.TrimSpace(parts[1])
                                                blockStart := pos + endParen + 1
                                                blockEnd := findEndForeach(content[blockStart:])
                                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                                        return nil, fmt.Errorf("unclosed @foreach")
                                                }</span>
                                                <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                                bodyContent := content[blockStart:absoluteBlockEnd]
                                                bodyNode, err := transpileBladeNative(bodyContent)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return nil, err
                                                }</span>
                                                <span class="cov8" title="1">itemVarClean := strings.TrimPrefix(itemVar, "$")
                                                foreachNode := &amp;engine.Node{Name: "for", Value: listVar, Children: []*engine.Node{{Name: "as", Value: itemVarClean}, {Name: "do", Children: bodyNode.Children}}}
                                                root.Children = append(root.Children, foreachNode)
                                                pos = absoluteBlockEnd + 11</span>
                                        } else<span class="cov0" title="0"> {
                                                pos += 8
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        pos += 8
                                }</span>
                        } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@forelse") </span><span class="cov8" title="1">{
                                // @forelse($list as $item) ... @empty ... @endforelse
                                startParen := strings.Index(content[pos:], "(")
                                endParen := findBalancedParen(content[pos:])
                                if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                        defRaw := content[pos+startParen+1 : pos+endParen] // $list as $item

                                        // Parse definition similarly to foreach
                                        parts := strings.Split(defRaw, " as ")
                                        if len(parts) != 2 </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("invalid @forelse format")
                                        }</span>

                                        <span class="cov8" title="1">listVar := strings.TrimSpace(parts[0])
                                        itemVar := strings.TrimSpace(parts[1])
                                        itemVarClean := strings.TrimPrefix(itemVar, "$")

                                        blockStart := pos + endParen + 1
                                        blockEnd := findEndForelse(content[blockStart:])
                                        if blockEnd == -1 </span><span class="cov8" title="1">{
                                                return nil, fmt.Errorf("unclosed @forelse")
                                        }</span>

                                        <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                        fullBlockContent := content[blockStart:absoluteBlockEnd]

                                        // Split into Body and Empty
                                        emptyPos := -1

                                        // Custom scan for @empty
                                        d := 0
                                        scanPos := 0
                                        for scanPos &lt; len(fullBlockContent) </span><span class="cov8" title="1">{
                                                if strings.HasPrefix(fullBlockContent[scanPos:], "@empty") </span><span class="cov8" title="1">{
                                                        if d == 0 </span><span class="cov8" title="1">{
                                                                emptyPos = scanPos
                                                                break</span>
                                                        }
                                                } else<span class="cov8" title="1"> if strings.HasPrefix(fullBlockContent[scanPos:], "@foreach") || strings.HasPrefix(fullBlockContent[scanPos:], "@forelse") </span><span class="cov0" title="0">{
                                                        d++
                                                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(fullBlockContent[scanPos:], "@endforeach") || strings.HasPrefix(fullBlockContent[scanPos:], "@endforelse") </span><span class="cov0" title="0">{
                                                        d--
                                                }</span>
                                                <span class="cov8" title="1">scanPos++</span>
                                        }

                                        <span class="cov8" title="1">var bodyContent, emptyContent string
                                        if emptyPos != -1 </span><span class="cov8" title="1">{
                                                bodyContent = fullBlockContent[:emptyPos]
                                                emptyContent = fullBlockContent[emptyPos+6:]
                                        }</span> else<span class="cov0" title="0"> {
                                                bodyContent = fullBlockContent
                                        }</span>

                                        <span class="cov8" title="1">bodyNode, err := transpileBladeNative(bodyContent)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>

                                        <span class="cov8" title="1">node := &amp;engine.Node{
                                                Name:  "forelse",
                                                Value: listVar,
                                                Children: []*engine.Node{
                                                        {Name: "as", Value: itemVarClean},
                                                        {Name: "do", Children: bodyNode.Children},
                                                },
                                        }

                                        if emptyPos != -1 </span><span class="cov8" title="1">{
                                                emptyNode, err := transpileBladeNative(emptyContent)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return nil, err
                                                }</span>
                                                <span class="cov8" title="1">node.Children = append(node.Children, &amp;engine.Node{
                                                        Name:     "forelse_empty",
                                                        Children: emptyNode.Children,
                                                })</span>
                                        }

                                        <span class="cov8" title="1">root.Children = append(root.Children, node)
                                        pos = absoluteBlockEnd + 11</span> // @endforelse
                                } else<span class="cov0" title="0"> {
                                        pos += 8
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // It IS @for
                                // @for($i=0;...)
                                startParen := strings.Index(content[pos:], "(")
                                endParen := findBalancedParen(content[pos:])

                                if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                        valRaw := content[pos+startParen+1 : pos+endParen]

                                        blockStart := pos + endParen + 1
                                        blockEnd := findEndFor(content[blockStart:])
                                        if blockEnd == -1 </span><span class="cov8" title="1">{
                                                return nil, fmt.Errorf("unclosed @for")
                                        }</span>

                                        <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                        bodyContent := content[blockStart:absoluteBlockEnd]
                                        bodyNode, err := transpileBladeNative(bodyContent)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>

                                        <span class="cov8" title="1">node := &amp;engine.Node{
                                                Name:  "for", // The new C-style slot
                                                Value: valRaw,
                                                Children: []*engine.Node{
                                                        {Name: "do", Children: bodyNode.Children},
                                                },
                                        }
                                        root.Children = append(root.Children, node)
                                        pos = absoluteBlockEnd + 7</span> // @endfor
                                } else<span class="cov0" title="0"> {
                                        pos += 4
                                }</span>
                        }

                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@unless") </span><span class="cov8" title="1">{
                        // @unless($var)
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])

                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                valRaw := content[pos+startParen+1 : pos+endParen]

                                blockStart := pos + endParen + 1
                                blockEnd := findEndUnless(content[blockStart:])

                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("unclosed @unless")
                                }</span>

                                <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                bodyContent := content[blockStart:absoluteBlockEnd]
                                bodyNode, err := transpileBladeNative(bodyContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">node := &amp;engine.Node{
                                        Name:  "unless",
                                        Value: valRaw,
                                        Children: []*engine.Node{
                                                {Name: "do", Children: bodyNode.Children},
                                        },
                                }
                                root.Children = append(root.Children, node)
                                pos = absoluteBlockEnd + 10</span> // @endunless
                        } else<span class="cov0" title="0"> {
                                pos += 7
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@switch") </span><span class="cov8" title="1">{
                        // @switch($val)
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])
                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                valRaw := content[pos+startParen+1 : pos+endParen]

                                blockStart := pos + endParen + 1
                                blockEnd := findEndSwitch(content[blockStart:])
                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("unclosed @switch")
                                }</span>

                                <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                bodyContent := content[blockStart:absoluteBlockEnd]

                                // Parse Cases
                                cases := splitSwitchCases(bodyContent)

                                switchNode := &amp;engine.Node{
                                        Name:  "switch",
                                        Value: valRaw,
                                }

                                for _, c := range cases </span><span class="cov8" title="1">{
                                        caseBodyNode, err := transpileBladeNative(c.Body)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>

                                        <span class="cov8" title="1">caseNode := &amp;engine.Node{
                                                Name:     c.Type, // "case" or "default"
                                                Value:    c.Value,
                                                Children: caseBodyNode.Children,
                                        }
                                        switchNode.Children = append(switchNode.Children, caseNode)</span>
                                }

                                <span class="cov8" title="1">root.Children = append(root.Children, switchNode)
                                pos = absoluteBlockEnd + 11</span> // @endswitch
                        } else<span class="cov0" title="0"> {
                                pos += 7
                        }</span>

                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@break") </span><span class="cov8" title="1">{
                        if len(content) &gt; pos+6 &amp;&amp; content[pos+6] == '(' </span><span class="cov8" title="1">{
                                startParen := strings.Index(content[pos:], "(")
                                endParen := findBalancedParen(content[pos:])
                                if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                        valRaw := content[pos+startParen+1 : pos+endParen]
                                        root.Children = append(root.Children, &amp;engine.Node{Name: "break", Value: valRaw})
                                        pos += endParen + 1
                                }</span> else<span class="cov0" title="0"> {
                                        root.Children = append(root.Children, &amp;engine.Node{Name: "break"})
                                        pos += 6
                                }</span>
                        } else<span class="cov8" title="1"> {
                                root.Children = append(root.Children, &amp;engine.Node{Name: "break"})
                                pos += 6
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@continue") </span><span class="cov8" title="1">{
                        if len(content) &gt; pos+9 &amp;&amp; content[pos+9] == '(' </span><span class="cov0" title="0">{
                                startParen := strings.Index(content[pos:], "(")
                                endParen := findBalancedParen(content[pos:])
                                if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov0" title="0">{
                                        valRaw := content[pos+startParen+1 : pos+endParen]
                                        root.Children = append(root.Children, &amp;engine.Node{Name: "continue", Value: valRaw})
                                        pos += endParen + 1
                                }</span> else<span class="cov0" title="0"> {
                                        root.Children = append(root.Children, &amp;engine.Node{Name: "continue"})
                                        pos += 9
                                }</span>
                        } else<span class="cov8" title="1"> {
                                root.Children = append(root.Children, &amp;engine.Node{Name: "continue"})
                                pos += 9
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@method") </span><span class="cov0" title="0">{
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])
                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov0" title="0">{
                                valRaw := content[pos+startParen+1 : pos+endParen]
                                verb := strings.Trim(valRaw, "'\"")
                                root.Children = append(root.Children, createWriteNode(fmt.Sprintf("&lt;input type=\"hidden\" name=\"_method\" value=\"%s\"&gt;", verb)))
                                pos += endParen + 1
                        }</span> else<span class="cov0" title="0"> {
                                pos += 7
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@dd") </span><span class="cov0" title="0">{
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])
                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov0" title="0">{
                                valRaw := content[pos+startParen+1 : pos+endParen]
                                root.Children = append(root.Children, &amp;engine.Node{Name: "dd", Value: valRaw})
                                pos += endParen + 1
                        }</span> else<span class="cov0" title="0"> {
                                pos += 3
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@while") </span><span class="cov8" title="1">{
                        // @while($cond)
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])
                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                valRaw := content[pos+startParen+1 : pos+endParen]

                                blockStart := pos + endParen + 1
                                blockEnd := findEndWhile(content[blockStart:])
                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("unclosed @while")
                                }</span>

                                <span class="cov0" title="0">absoluteBlockEnd := blockStart + blockEnd
                                bodyContent := content[blockStart:absoluteBlockEnd]
                                bodyNode, err := transpileBladeNative(bodyContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov0" title="0">node := &amp;engine.Node{
                                        Name:  "while",
                                        Value: valRaw,
                                        Children: []*engine.Node{
                                                {Name: "do", Children: bodyNode.Children},
                                        },
                                }
                                root.Children = append(root.Children, node)
                                pos = absoluteBlockEnd + 9</span> // @endwhile
                        } else<span class="cov0" title="0"> {
                                pos += 6
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@push") </span><span class="cov8" title="1">{
                        // @push('name')
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])

                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                nameRaw := content[pos+startParen+1 : pos+endParen]
                                nameRaw = strings.Trim(nameRaw, "'\"")

                                blockStart := pos + endParen + 1
                                blockEnd := findEndPush(content[blockStart:])

                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("unclosed @push")
                                }</span>

                                <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                bodyContent := content[blockStart:absoluteBlockEnd]
                                bodyNode, err := transpileBladeNative(bodyContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">pushNode := &amp;engine.Node{
                                        Name:  "view.push",
                                        Value: nameRaw,
                                        Children: []*engine.Node{
                                                {Name: "do", Children: bodyNode.Children},
                                        },
                                }
                                root.Children = append(root.Children, pushNode)

                                pos = absoluteBlockEnd + 8</span> // @endpush
                        } else<span class="cov0" title="0"> {
                                pos += 5
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@error") </span><span class="cov8" title="1">{
                        // @error('fieldname')
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])

                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                fieldRaw := content[pos+startParen+1 : pos+endParen]
                                fieldName := strings.Trim(fieldRaw, "'\"")

                                blockStart := pos + endParen + 1
                                blockEnd := findEndError(content[blockStart:])

                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("unclosed @error")
                                }</span>

                                <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                bodyContent := content[blockStart:absoluteBlockEnd]
                                bodyNode, err := transpileBladeNative(bodyContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">errorNode := &amp;engine.Node{
                                        Name:  "error",
                                        Value: fieldName,
                                        Children: []*engine.Node{
                                                {Name: "do", Children: bodyNode.Children},
                                        },
                                }
                                root.Children = append(root.Children, errorNode)

                                pos = absoluteBlockEnd + 9</span> // @enderror
                        } else<span class="cov0" title="0"> {
                                pos += 6
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@cannot") </span><span class="cov8" title="1">{
                        // @cannot('ability', $resource)
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])

                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                argsRaw := content[pos+startParen+1 : pos+endParen]

                                parts := strings.Split(argsRaw, ",")
                                ability := strings.Trim(strings.TrimSpace(parts[0]), "'\"")

                                var resourceValue interface{}
                                if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                                        resourceValue = strings.TrimSpace(parts[1])
                                }</span>

                                <span class="cov8" title="1">blockStart := pos + endParen + 1
                                blockEnd := findEndCannot(content[blockStart:])

                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("unclosed @cannot")
                                }</span>

                                <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                bodyContent := content[blockStart:absoluteBlockEnd]
                                bodyNode, err := transpileBladeNative(bodyContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">cannotNode := &amp;engine.Node{
                                        Name:  "cannot",
                                        Value: ability,
                                        Children: []*engine.Node{
                                                {Name: "do", Children: bodyNode.Children},
                                        },
                                }

                                if resourceValue != nil </span><span class="cov8" title="1">{
                                        cannotNode.Children = append([]*engine.Node{
                                                {Name: "resource", Value: resourceValue},
                                        }, cannotNode.Children...)
                                }</span>

                                <span class="cov8" title="1">root.Children = append(root.Children, cannotNode)
                                pos = absoluteBlockEnd + 10</span> // @endcannot
                        } else<span class="cov0" title="0"> {
                                pos += 7
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@can") </span><span class="cov8" title="1">{
                        // @can('ability', $resource) or @can('ability')
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])

                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                argsRaw := content[pos+startParen+1 : pos+endParen]

                                // Parse arguments: 'ability', $resource
                                parts := strings.Split(argsRaw, ",")
                                ability := strings.Trim(strings.TrimSpace(parts[0]), "'\"")

                                var resourceValue interface{}
                                if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                                        resourceValue = strings.TrimSpace(parts[1])
                                }</span>

                                <span class="cov8" title="1">blockStart := pos + endParen + 1
                                blockEnd := findEndCan(content[blockStart:])

                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("unclosed @can")
                                }</span>

                                <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                bodyContent := content[blockStart:absoluteBlockEnd]
                                bodyNode, err := transpileBladeNative(bodyContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">canNode := &amp;engine.Node{
                                        Name:  "can",
                                        Value: ability,
                                        Children: []*engine.Node{
                                                {Name: "do", Children: bodyNode.Children},
                                        },
                                }

                                // Add resource if provided
                                if resourceValue != nil </span><span class="cov8" title="1">{
                                        canNode.Children = append([]*engine.Node{
                                                {Name: "resource", Value: resourceValue},
                                        }, canNode.Children...)
                                }</span>

                                <span class="cov8" title="1">root.Children = append(root.Children, canNode)
                                pos = absoluteBlockEnd + 7</span> // @endcan
                        } else<span class="cov0" title="0"> {
                                pos += 4
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@stack") </span><span class="cov8" title="1">{
                        // @stack('name')
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])
                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                nameRaw := content[pos+startParen+1 : pos+endParen]
                                nameRaw = strings.Trim(nameRaw, "'\"")

                                stackNode := &amp;engine.Node{
                                        Name:  "view.stack",
                                        Value: nameRaw,
                                }
                                root.Children = append(root.Children, stackNode)
                                pos += endParen + 1
                        }</span> else<span class="cov0" title="0"> {
                                pos += 6
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@yield") </span><span class="cov8" title="1">{
                        // @yield('name')
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])
                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                nameRaw := content[pos+startParen+1 : pos+endParen]
                                nameRaw = strings.Trim(nameRaw, "'\"")

                                yieldNode := &amp;engine.Node{
                                        Name:  "section.yield",
                                        Value: nameRaw,
                                }
                                root.Children = append(root.Children, yieldNode)
                                pos += endParen + 1
                        }</span> else<span class="cov0" title="0"> {
                                pos += 6
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "@if") </span><span class="cov8" title="1">{
                        // ... If Logic (Existing) ...
                        startParen := strings.Index(content[pos:], "(")
                        endParen := findBalancedParen(content[pos:])
                        if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{

                                condRaw := content[pos+startParen+1 : pos+endParen]
                                blockStart := pos + endParen + 1

                                // Find End or Else
                                blockEnd, matchType := findEndIf(content[blockStart:])
                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("unclosed @if")
                                }</span>

                                <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                trueContent := content[blockStart:absoluteBlockEnd]
                                trueNode, err := transpileBladeNative(trueContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">var elseNode *engine.Node

                                if matchType == "else" </span><span class="cov8" title="1">{
                                        // We found an @else, now find the @endif
                                        elseStart := absoluteBlockEnd + 5 // length of @else
                                        elseEnd, matchType2 := findEndIf(content[elseStart:])
                                        if matchType2 != "endif" </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("unclosed @else (expected @endif)")
                                        }</span>
                                        <span class="cov8" title="1">absoluteElseEnd := elseStart + elseEnd
                                        elseContent := content[elseStart:absoluteElseEnd]
                                        elseBody, err := transpileBladeNative(elseContent)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>

                                        <span class="cov8" title="1">elseNode = &amp;engine.Node{
                                                Name:     "else",
                                                Children: elseBody.Children,
                                        }

                                        // Update pos to end of endif
                                        pos = absoluteElseEnd + 6</span> // @endif
                                } else<span class="cov8" title="1"> {
                                        // Found @endif directly
                                        pos = absoluteBlockEnd + 6 // @endif
                                }</span>

                                <span class="cov8" title="1">ifNode := &amp;engine.Node{
                                        Name:  "if",
                                        Value: condRaw,
                                        Children: []*engine.Node{
                                                {Name: "then", Children: trueNode.Children},
                                        },
                                }
                                if elseNode != nil </span><span class="cov8" title="1">{
                                        ifNode.Children = append(ifNode.Children, elseNode)
                                }</span>

                                <span class="cov8" title="1">root.Children = append(root.Children, ifNode)</span>
                        } else<span class="cov0" title="0"> {
                                pos += 3
                        }</span>

                } else<span class="cov8" title="1"> if strings.HasPrefix(content[pos:], "&lt;x-") </span><span class="cov8" title="1">{
                        // &lt;x-name attr="val" :attr="expr"&gt;
                        // &lt;x-slot name="header"&gt;

                        // 1. Extract Tag Content until &gt; or /&gt;
                        // Simple scan?
                        // Caveat: &gt; inside attribute quotes?
                        tagEnd := -1
                        inQuote := false
                        var quoteChar rune

                        for i, c := range content[pos:] </span><span class="cov8" title="1">{
                                if inQuote </span><span class="cov8" title="1">{
                                        if c == quoteChar </span><span class="cov8" title="1">{
                                                inQuote = false
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        if c == '"' || c == '\'' </span><span class="cov8" title="1">{
                                                inQuote = true
                                                quoteChar = c
                                        }</span>
                                        <span class="cov8" title="1">if c == '&gt;' </span><span class="cov8" title="1">{
                                                tagEnd = i
                                                break</span>
                                        }
                                }
                        }

                        <span class="cov8" title="1">if tagEnd == -1 </span><span class="cov0" title="0">{
                                // Malformed, treat as text
                                root.Children = append(root.Children, createWriteNode("&lt;"))
                                pos++
                                continue</span>
                        }

                        <span class="cov8" title="1">fullTag := content[pos : pos+tagEnd+1] // &lt;x-name ... &gt; or &lt;x-name ... /&gt;
                        isSelfClosing := strings.HasSuffix(fullTag, "/&gt;")

                        // Parse Name
                        // &lt;x-name ...
                        // Cut &lt;, &gt;/ /&gt;
                        inner := fullTag
                        if isSelfClosing </span><span class="cov0" title="0">{
                                inner = strings.TrimSuffix(inner, "/&gt;")
                        }</span> else<span class="cov8" title="1"> {
                                inner = strings.TrimSuffix(inner, "&gt;")
                        }</span>
                        <span class="cov8" title="1">inner = strings.TrimPrefix(inner, "&lt;")
                        inner = strings.TrimSpace(inner)

                        // Split name from attrs
                        parts := strings.SplitN(inner, " ", 2)
                        tagName := parts[0]

                        var attrsRaw string
                        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                                attrsRaw = parts[1]
                        }</span>

                        // Determine Node Type
                        <span class="cov8" title="1">nodeName := "view.component"
                        nodeValue := strings.TrimPrefix(tagName, "x-") // user.profile

                        if tagName == "x-slot" </span><span class="cov8" title="1">{
                                nodeName = "slot"
                                // Value will be extracted from name attribute later, or default to "" if missing?
                                // x-slot MUST have name?
                        }</span>

                        <span class="cov8" title="1">compNode := &amp;engine.Node{Name: nodeName, Value: nodeValue}

                        // Parse Attributes and append as children
                        // Helper: parseAttributes(attrsRaw) -&gt; []*engine.Node
                        attrNodes := parseBladeAttributes(attrsRaw)
                        compNode.Children = append(compNode.Children, attrNodes...)

                        if nodeName == "slot" </span><span class="cov8" title="1">{
                                // Fix Value from name attribute
                                for _, c := range attrNodes </span><span class="cov8" title="1">{
                                        if c.Name == "name" </span><span class="cov8" title="1">{
                                                // Evaluate literal value
                                                // If key="val", Value is "val".
                                                // We need "val" string.
                                                // resolveValue?
                                                // But here we are building the AST. Value currently holds the raw string if literal?
                                                // parseBladeAttributes returns Node{Name, Value}.
                                                // If Value is expression (starts with $?), we can't fully resolve name at parse time if dynamic?
                                                // Blade x-slot name usually static.
                                                // Assuming value is literal string.
                                                compNode.Value = c.Value
                                        }</span>
                                }
                        }

                        // Handle Body
                        <span class="cov8" title="1">if isSelfClosing </span><span class="cov0" title="0">{
                                root.Children = append(root.Children, compNode)
                                pos += tagEnd + 1
                        }</span> else<span class="cov8" title="1"> {
                                // Find closing tag &lt;/x-name&gt; (or &lt;/x-slot&gt;)
                                // name for searching: tagName (x-name)
                                blockStart := pos + tagEnd + 1
                                blockEnd := findEndComponent(content[blockStart:], tagName)

                                if blockEnd == -1 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("unclosed component %s", tagName)
                                }</span>

                                <span class="cov8" title="1">absoluteBlockEnd := blockStart + blockEnd
                                bodyContent := content[blockStart:absoluteBlockEnd]

                                // Recursive Parse Body
                                bodyNode, err := transpileBladeNative(bodyContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">if nodeName == "slot" </span><span class="cov8" title="1">{
                                        compNode.Children = append(compNode.Children, bodyNode.Children...)
                                }</span> else<span class="cov8" title="1"> {
                                        // For component, body is Default Slot
                                        // Wrap in "default_slot" node?
                                        // Or just append children that are NOT slots?
                                        // view.component slot handles "default_slot" or just children.
                                        // Implementation (Step 1436) handled `child.Name == "default_slot"`.
                                        // So wrap body in `default_slot` node.

                                        // But wait, &lt;x-slot&gt; children inside body will be parsed as "slot" nodes.
                                        // We should separate them?
                                        // Implementation iterates children. If "slot", puts in map. If "default_slot", puts in slotContent.
                                        // So if we put &lt;x-slot&gt; nodes as direct children of compNode, they are handled.
                                        // What about non-slot content? That's default slot.
                                        // So we should verify body children.

                                        defaultSlotNode := &amp;engine.Node{Name: "default_slot"}

                                        for _, c := range bodyNode.Children </span><span class="cov8" title="1">{
                                                if c.Name == "slot" </span><span class="cov8" title="1">{
                                                        compNode.Children = append(compNode.Children, c)
                                                }</span> else<span class="cov8" title="1"> {
                                                        defaultSlotNode.Children = append(defaultSlotNode.Children, c)
                                                }</span>
                                        }
                                        // Only append default slot if has children
                                        <span class="cov8" title="1">if len(defaultSlotNode.Children) &gt; 0 </span><span class="cov8" title="1">{
                                                compNode.Children = append(compNode.Children, defaultSlotNode)
                                        }</span>
                                }

                                <span class="cov8" title="1">root.Children = append(root.Children, compNode)

                                // Advance past closing tag &lt;/x-name&gt;
                                // findEndComponent returns index of start of closing tag.
                                // length of &lt;/x-name&gt; = 2 + len(name) + 1
                                closingLen := 2 + len(tagName) + 1

                                // Verify closing tag match? findEndComponent guarantees it find the prefix.
                                // Assume simple match.
                                // What about whitespace in closing? &lt;/x-name &gt;?
                                // Just scan until &gt;
                                endTagScan := content[absoluteBlockEnd:]
                                endTagClose := strings.Index(endTagScan, "&gt;")
                                if endTagClose != -1 </span><span class="cov8" title="1">{
                                        pos = absoluteBlockEnd + endTagClose + 1
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback
                                        pos = absoluteBlockEnd + closingLen
                                }</span>
                        }

                } else<span class="cov8" title="1"> {
                        root.Children = append(root.Children, createWriteNode(string(content[pos])))
                        pos++
                }</span>
        }

        // If extends exists, execute it AT THE END
        <span class="cov8" title="1">if extendsFile != "" </span><span class="cov8" title="1">{
                root.Children = append(root.Children, &amp;engine.Node{
                        Name:  "view.extends",
                        Value: extendsFile,
                })
        }</span>

        <span class="cov8" title="1">return root, nil</span>
}

func findEndSection(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@section") </span><span class="cov8" title="1">{
                        depth++
                        pos += 8
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endsection") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 11</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// Simple Helpers for parsing

func findEndIf(s string) (int, string) <span class="cov8" title="1">{
        // Find @endif OR @else respecting nested @if
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@if") </span><span class="cov8" title="1">{
                        depth++
                        pos += 3
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endif") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos, "endif" // Found match
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 6</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@else") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos, "else"
                        }</span>
                        <span class="cov0" title="0">pos += 5</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1, ""</span>
}

func findEndForeach(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@foreach") </span><span class="cov8" title="1">{
                        depth++
                        pos += 8
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endforeach") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 11</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func splitBladeArgs(s string) []string <span class="cov8" title="1">{
        // Simple split by comma, respecting parens/brackets/quotes?
        // For now VERY simple: split by comma if not in brackets.
        // Valid: 'view', ['a'=&gt;1]
        // Valid: 'view', $data

        var args []string
        depth := 0
        lastSplit := 0

        for i, c := range s </span><span class="cov8" title="1">{
                if c == '[' || c == '(' </span><span class="cov8" title="1">{
                        depth++
                }</span>
                <span class="cov8" title="1">if c == ']' || c == ')' </span><span class="cov8" title="1">{
                        depth--
                }</span>
                <span class="cov8" title="1">if c == ',' &amp;&amp; depth == 0 </span><span class="cov8" title="1">{
                        args = append(args, s[lastSplit:i])
                        lastSplit = i + 1
                }</span>
        }
        <span class="cov8" title="1">args = append(args, s[lastSplit:])
        return args</span>
}

func parseBladeData(s string) *engine.Node <span class="cov8" title="1">{
        s = strings.TrimSpace(s)
        // Check if it's a bracketed dict ['k' =&gt; 'v']
        if strings.HasPrefix(s, "[") &amp;&amp; strings.HasSuffix(s, "]") </span><span class="cov8" title="1">{
                inner := s[1 : len(s)-1]
                // Split by comma
                pairs := splitBladeArgs(inner)
                dataNode := &amp;engine.Node{Name: "data_map"}

                for _, pair := range pairs </span><span class="cov8" title="1">{
                        parts := strings.Split(pair, "=&gt;")
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                key := strings.Trim(strings.TrimSpace(parts[0]), "'\"") // Key is usually string
                                valRaw := strings.TrimSpace(parts[1])

                                // Value can be literal or variable
                                var valNode *engine.Node
                                if strings.HasPrefix(valRaw, "$") </span><span class="cov8" title="1">{
                                        valNode = &amp;engine.Node{Name: "var", Value: valRaw}
                                }</span> else<span class="cov8" title="1"> {
                                        valNode = &amp;engine.Node{Name: "literal", Value: strings.Trim(valRaw, "'\"")}
                                }</span>

                                <span class="cov8" title="1">valNode.Name = key // Encode Key as Node Name for simplicity in this specific "data_map" structure
                                dataNode.Children = append(dataNode.Children, valNode)</span>
                        } else<span class="cov8" title="1"> if len(parts) == 1 </span><span class="cov8" title="1">{
                                valRaw := strings.TrimSpace(parts[0])
                                key := strings.Trim(valRaw, "'\"")

                                // It's just a class name string without a condition, so condition is true
                                valNode := &amp;engine.Node{Name: key, Value: "true"}
                                dataNode.Children = append(dataNode.Children, valNode)
                        }</span>
                }
                <span class="cov8" title="1">return dataNode</span>
        }

        // Variable $data
        <span class="cov0" title="0">if strings.HasPrefix(s, "$") </span><span class="cov0" title="0">{
                return &amp;engine.Node{Name: "data_var", Value: s}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func findEndSwitch(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@switch") </span><span class="cov8" title="1">{
                        depth++
                        pos += 7
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endswitch") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 10</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

type switchCase struct {
        Type  string // "case" or "default"
        Value string // Raw value for case
        Body  string
}

func splitSwitchCases(body string) []switchCase <span class="cov8" title="1">{
        var cases []switchCase

        // Scan for @case, @default at scanning depth 0 (respecting nested @switch)
        depth := 0
        pos := 0
        length := len(body)

        // Track start of current case body
        currentStart := -1
        currentType := ""
        currentVal := ""

        for pos &lt; length </span><span class="cov8" title="1">{
                if strings.HasPrefix(body[pos:], "@switch") </span><span class="cov0" title="0">{
                        depth++
                        pos += 7
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(body[pos:], "@endswitch") </span><span class="cov0" title="0">{
                        depth--
                        pos += 10
                }</span> else<span class="cov8" title="1"> if depth == 0 </span><span class="cov8" title="1">{
                        // Check for @case / @default
                        if strings.HasPrefix(body[pos:], "@case") </span><span class="cov8" title="1">{
                                // Close previous
                                if currentStart != -1 </span><span class="cov8" title="1">{
                                        cases = append(cases, switchCase{
                                                Type:  currentType,
                                                Value: currentVal,
                                                Body:  body[currentStart:pos],
                                        })
                                }</span>

                                // Start new
                                <span class="cov8" title="1">startParen := strings.Index(body[pos:], "(")
                                endParen := findBalancedParen(body[pos:])
                                if startParen != -1 &amp;&amp; endParen != -1 </span><span class="cov8" title="1">{
                                        currentVal = body[pos+startParen+1 : pos+endParen]
                                        currentType = "case"
                                        currentStart = pos + endParen + 1
                                        pos = currentStart
                                        continue</span>
                                } else<span class="cov0" title="0"> {
                                        pos += 5
                                }</span>
                        } else<span class="cov8" title="1"> if strings.HasPrefix(body[pos:], "@default") </span><span class="cov8" title="1">{
                                // Close previous
                                if currentStart != -1 </span><span class="cov8" title="1">{
                                        cases = append(cases, switchCase{
                                                Type:  currentType,
                                                Value: currentVal,
                                                Body:  body[currentStart:pos],
                                        })
                                }</span>
                                <span class="cov8" title="1">currentType = "default"
                                currentVal = ""
                                currentStart = pos + 8
                                pos += 8
                                continue</span>
                        } else<span class="cov8" title="1"> {
                                pos++
                        }</span>
                } else<span class="cov0" title="0"> {
                        pos++
                }</span>
        }

        // Close last
        <span class="cov8" title="1">if currentStart != -1 </span><span class="cov8" title="1">{
                cases = append(cases, switchCase{
                        Type:  currentType,
                        Value: currentVal,
                        Body:  body[currentStart:],
                })
        }</span>

        <span class="cov8" title="1">return cases</span>
}

func findEndPush(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@push") </span><span class="cov8" title="1">{
                        depth++
                        pos += 5
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endpush") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 8</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func findEndIsset(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@isset") </span><span class="cov8" title="1">{
                        depth++
                        pos += 6
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endisset") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 9</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func findEndEmpty(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@empty") </span><span class="cov8" title="1">{
                        depth++
                        pos += 6
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endempty") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 9</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func findEndUnless(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@unless") </span><span class="cov8" title="1">{
                        depth++
                        pos += 7
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endunless") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 10</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func findEndAuth(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@auth") </span><span class="cov8" title="1">{
                        depth++
                        pos += 5
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endauth") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 8</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func findEndGuest(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@guest") </span><span class="cov8" title="1">{
                        depth++
                        pos += 6
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endguest") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 9</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func findEndFor(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@for") </span><span class="cov8" title="1">{
                        if strings.HasPrefix(s[pos:], "@foreach") </span><span class="cov0" title="0">{
                                pos += 8
                        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@for") </span><span class="cov8" title="1">{
                                depth++
                                pos += 4
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endfor") </span><span class="cov8" title="1">{
                        if strings.HasPrefix(s[pos:], "@endforeach") </span><span class="cov0" title="0">{
                                pos += 11
                        }</span> else<span class="cov8" title="1"> {
                                if depth == 0 </span><span class="cov8" title="1">{
                                        return pos
                                }</span>
                                <span class="cov8" title="1">depth--
                                pos += 7</span>
                        }
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func createWriteNode(text string) *engine.Node <span class="cov8" title="1">{
        return &amp;engine.Node{
                Name:  "__native_write",
                Value: text,
        }
}</span>

func findBalancedParen(s string) int <span class="cov8" title="1">{
        depth := 0
        for i, c := range s </span><span class="cov8" title="1">{
                if c == '(' </span><span class="cov8" title="1">{
                        depth++
                }</span>
                <span class="cov8" title="1">if c == ')' </span><span class="cov8" title="1">{
                        depth--
                        if depth == 0 </span><span class="cov8" title="1">{
                                return i
                        }</span>
                }
        }
        <span class="cov0" title="0">return -1</span>
}

func findEndWhile(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@while") </span><span class="cov8" title="1">{
                        depth++
                        pos += 6
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endwhile") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov0" title="0">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 9</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func findEndForelse(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@forelse") </span><span class="cov8" title="1">{
                        depth++
                        pos += 8
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endforelse") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 11</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func findEndComponent(s, tagName string) int <span class="cov8" title="1">{
        // tagName: x-alert
        closing := "&lt;/" + tagName
        start := "&lt;" + tagName

        depth := 0
        pos := 0

        for pos &lt; len(s) </span><span class="cov8" title="1">{
                // Check start tag &lt;x-name (ensure word boundary?)
                // Simplification: HasPrefix
                if strings.HasPrefix(s[pos:], start) </span><span class="cov8" title="1">{
                        depth++
                        pos += len(start)
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], closing) </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += len(closing)</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func parseBladeAttributes(raw string) []*engine.Node <span class="cov8" title="1">{
        // raw: class="btn" :type="$type" dismissible
        var nodes []*engine.Node

        raw = strings.TrimSpace(raw)
        n := len(raw)
        i := 0

        for i &lt; n </span><span class="cov8" title="1">{
                // Skip spaces
                for i &lt; n &amp;&amp; raw[i] == ' ' </span><span class="cov8" title="1">{
                        i++
                }</span>
                <span class="cov8" title="1">if i &gt;= n </span><span class="cov0" title="0">{
                        break</span>
                }

                // Read Key
                <span class="cov8" title="1">keyStart := i
                for i &lt; n &amp;&amp; raw[i] != '=' &amp;&amp; raw[i] != ' ' </span><span class="cov8" title="1">{
                        i++
                }</span>
                <span class="cov8" title="1">key := raw[keyStart:i]

                val := ""

                if i &lt; n &amp;&amp; raw[i] == '=' </span><span class="cov8" title="1">{
                        i++ // skip =
                        // Read Value (Quoted)
                        if i &lt; n &amp;&amp; (raw[i] == '"' || raw[i] == '\'') </span><span class="cov8" title="1">{
                                quote := raw[i]
                                i++
                                valStart := i
                                for i &lt; n &amp;&amp; raw[i] != quote </span><span class="cov8" title="1">{
                                        i++
                                }</span>
                                <span class="cov8" title="1">val = raw[valStart:i]
                                if i &lt; n </span><span class="cov8" title="1">{
                                        i++
                                }</span> // skip quote
                        } else<span class="cov0" title="0"> {
                                // Unquoted? Not standard HTML but verify
                                valStart := i
                                for i &lt; n &amp;&amp; raw[i] != ' ' </span><span class="cov0" title="0">{
                                        i++
                                }</span>
                                <span class="cov0" title="0">val = raw[valStart:i]</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Boolean attribute
                        val = "true"
                }</span>

                // Create Node
                <span class="cov8" title="1">nodes = append(nodes, &amp;engine.Node{
                        Name:  key,
                        Value: val,
                })</span>
        }
        <span class="cov8" title="1">return nodes</span>
}

func findEndError(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@error") </span><span class="cov8" title="1">{
                        depth++
                        pos += 6
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@enderror") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 9</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func findEndCan(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@can") </span><span class="cov8" title="1">{
                        depth++
                        pos += 4
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endcan") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 7</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func findEndCannot(s string) int <span class="cov8" title="1">{
        depth := 0
        pos := 0
        for pos &lt; len(s) </span><span class="cov8" title="1">{
                if strings.HasPrefix(s[pos:], "@cannot") </span><span class="cov8" title="1">{
                        depth++
                        pos += 7
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(s[pos:], "@endcannot") </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                return pos
                        }</span>
                        <span class="cov8" title="1">depth--
                        pos += 10</span>
                } else<span class="cov8" title="1"> {
                        pos++
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package slots

import (
        "context"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

// Cache slots - Currently disabled (Redis removed)
// All cache operations are no-ops for compatibility

func RegisterCacheSlots(eng *engine.Engine, rdb interface{}) <span class="cov8" title="1">{

        // CACHE.PUT
        eng.Register("cache.put", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // Cache disabled - Redis removed
                // This is a no-op for compatibility
                return nil
        }</span>, engine.SlotMeta{
                Description: "Menyimpan data sementara (Cache). Currently disabled.",
                Example: `cache.put
  key: "homepage_stats"
  val: stats_data
  ttl: "30m"`,
        })

        // CACHE.GET
        <span class="cov8" title="1">eng.Register("cache.get", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var target string
                var defaultVal interface{}
                target = "cache_value"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        rawVal := parseNodeValue(c, scope)
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "default" </span><span class="cov8" title="1">{
                                defaultVal = rawVal
                        }</span>
                }

                // Always return default value (cache miss)
                <span class="cov8" title="1">scope.Set(target, defaultVal)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Mengambil data cache. Always returns default value (cache disabled).",
                Example: `cache.get
  key: "homepage_stats"
  default: 0
  as: $stats`,
        })

        // CACHE.FORGET
        <span class="cov8" title="1">eng.Register("cache.forget", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // Cache disabled - no-op
                return nil
        }</span>, engine.SlotMeta{Example: "cache.forget: 'homepage_stats'"})
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package slots

import (
        "bytes"
        "context"
        "fmt"
        "net/http"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"

        "github.com/dchest/captcha"
        "github.com/go-chi/chi/v5"
)

// RegisterCaptchaSlots mendaftarkan slot-slot captcha ke engine.
// Slot yang tersedia:
//   - captcha.new    : Buat captcha baru dan simpan ID ke scope
//   - captcha.verify : Verifikasi jawaban user
//   - captcha.image  : Tulis PNG captcha ke http.ResponseWriter
//   - captcha.serve  : Daftarkan route handler bawaan captcha ke router
func RegisterCaptchaSlots(eng *engine.Engine, r *chi.Mux) <span class="cov8" title="1">{

        //  captcha.new 
        // Membuat captcha baru dengan panjang default (6 digit) atau custom.
        // Menyimpan captcha ID ke scope.
        //
        // Contoh:
        //   captcha.new
        //     as: $captcha_id
        //
        //   captcha.new
        //     length: 4
        //     as: $captcha_id
        eng.Register("captcha.new", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                target := "captcha_id"
                length := captcha.DefaultLen

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        switch c.Name </span>{
                        case "as":<span class="cov8" title="1">
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")</span>
                        case "length":<span class="cov8" title="1">
                                if l, err := coerce.ToInt(val); err == nil &amp;&amp; l &gt; 0 </span><span class="cov8" title="1">{
                                        length = l
                                }</span>
                        }
                }

                <span class="cov8" title="1">id := captcha.NewLen(length)
                scope.Set(target, id)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Membuat captcha baru dan menyimpan ID-nya ke scope.",
                Example: `captcha.new
  as: $captcha_id`,
        })

        //  captcha.verify 
        // Memverifikasi jawaban user terhadap captcha ID yang diberikan.
        // Menghapus captcha dari store setelah verifikasi (one-time use).
        //
        // Contoh:
        //   captcha.verify
        //     id: $captcha_id
        //     answer: $user_input
        //     as: $is_valid
        <span class="cov8" title="1">eng.Register("captcha.verify", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var id, answer string
                target := "captcha_valid"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        switch c.Name </span>{
                        case "id":<span class="cov8" title="1">
                                id = coerce.ToString(val)</span>
                        case "answer":<span class="cov8" title="1">
                                answer = coerce.ToString(val)</span>
                        case "as":<span class="cov8" title="1">
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")</span>
                        }
                }

                <span class="cov8" title="1">if id == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("captcha.verify: 'id' is required")
                }</span>
                <span class="cov8" title="1">if answer == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("captcha.verify: 'answer' is required")
                }</span>

                <span class="cov8" title="1">ok := captcha.VerifyString(id, answer)
                scope.Set(target, ok)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Memverifikasi jawaban user terhadap captcha ID. Menghapus captcha setelah verifikasi.",
                Example: `captcha.verify
  id: $captcha_id
  answer: $user_input
  as: $is_valid`,
        })

        //  captcha.image 
        // Menulis gambar PNG captcha langsung ke http.ResponseWriter.
        // Gunakan slot ini di dalam route handler untuk menampilkan captcha.
        //
        // Contoh:
        //   captcha.image
        //     id: $captcha_id
        //     width: 240
        //     height: 80
        <span class="cov8" title="1">eng.Register("captcha.image", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var id string
                width := captcha.StdWidth
                height := captcha.StdHeight

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        switch c.Name </span>{
                        case "id":<span class="cov8" title="1">
                                id = coerce.ToString(val)</span>
                        case "width":<span class="cov0" title="0">
                                if w, err := coerce.ToInt(val); err == nil &amp;&amp; w &gt; 0 </span><span class="cov0" title="0">{
                                        width = w
                                }</span>
                        case "height":<span class="cov0" title="0">
                                if h, err := coerce.ToInt(val); err == nil &amp;&amp; h &gt; 0 </span><span class="cov0" title="0">{
                                        height = h
                                }</span>
                        }
                }

                <span class="cov8" title="1">if id == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("captcha.image: 'id' is required")
                }</span>

                // Tulis ke buffer terlebih dahulu untuk menangkap error
                <span class="cov8" title="1">var buf bytes.Buffer
                if err := captcha.WriteImage(&amp;buf, id, width, height); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("captcha.image: failed to write image: %w", err)
                }</span>

                // Tulis ke ResponseWriter jika tersedia di context
                <span class="cov8" title="1">wVal := ctx.Value("httpResponseWriter")
                if wVal != nil </span><span class="cov0" title="0">{
                        w := wVal.(http.ResponseWriter)
                        w.Header().Set("Content-Type", "image/png")
                        w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
                        _, err := w.Write(buf.Bytes())
                        return err
                }</span>

                // Simpan bytes ke scope jika tidak ada ResponseWriter (misal: testing)
                <span class="cov8" title="1">scope.Set("captcha_image_bytes", buf.Bytes())
                return nil</span>
        }, engine.SlotMeta{
                Description: "Menulis gambar PNG captcha ke http.ResponseWriter atau menyimpan bytes ke scope.",
                Example: `captcha.image
  id: $captcha_id
  width: 240
  height: 80`,
        })

        //  captcha.serve 
        // Mendaftarkan route handler bawaan dchest/captcha ke router chi.
        // Handler ini melayani gambar dan audio captcha secara otomatis.
        //
        // URL pattern:
        //   GET /captcha/{id}.png   gambar PNG
        //   GET /captcha/{id}.wav   audio WAV
        //   GET /captcha/{id}.png?reload=1  reload captcha
        //
        // Contoh:
        //   captcha.serve
        //     prefix: /captcha
        //
        // Setelah ini, di HTML gunakan:
        //   &lt;img src="/captcha/{captcha_id}.png"&gt;
        <span class="cov8" title="1">eng.Register("captcha.serve", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                prefix := "/captcha"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "prefix" </span><span class="cov8" title="1">{
                                prefix = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                // Pastikan prefix diawali /
                <span class="cov8" title="1">if !strings.HasPrefix(prefix, "/") </span><span class="cov0" title="0">{
                        prefix = "/" + prefix
                }</span>

                // Daftarkan handler ke router
                <span class="cov8" title="1">handler := captcha.Server(captcha.StdWidth, captcha.StdHeight)
                r.Handle(prefix+"/*", http.StripPrefix(prefix, handler))

                return nil</span>
        }, engine.SlotMeta{
                Description: "Mendaftarkan route handler captcha ke router. Melayani PNG dan WAV secara otomatis.",
                Example: `captcha.serve
  prefix: /captcha`,
        })
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package slots

import (
        "context"
        "fmt"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

func RegisterCollectionSlots(eng *engine.Engine) <span class="cov8" title="1">{
        // ==========================================
        // ARRAY MANIPULATION
        // ==========================================

        // ARRAY.PUSH
        eng.Register("array.push", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var targetName string
                var items []interface{}

                // Parse arguments
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "in" || c.Name == "list" </span><span class="cov0" title="0">{
                                targetName = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "val" || c.Name == "value" || c.Name == "item" </span><span class="cov8" title="1">{
                                items = append(items, parseNodeValue(c, scope))
                        }</span>
                }

                // Also support main value as list name
                <span class="cov8" title="1">if node.Value != nil </span><span class="cov8" title="1">{
                        targetName = strings.TrimPrefix(coerce.ToString(node.Value), "$")
                }</span>

                <span class="cov8" title="1">if targetName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("array.push: target list not specified")
                }</span>

                // Get existing list
                <span class="cov8" title="1">currentVal, ok := scope.Get(targetName)
                if !ok || currentVal == nil </span><span class="cov0" title="0">{
                        // Initialize if not exists
                        currentVal = []interface{}{}
                }</span>

                // Convert to Slice
                <span class="cov8" title="1">list, err := coerce.ToSlice(currentVal)
                if err != nil </span><span class="cov0" title="0">{
                        // If it's single item, make it a list
                        list = []interface{}{currentVal}
                }</span>

                // Append new items
                <span class="cov8" title="1">list = append(list, items...)

                // Update Scope
                scope.Set(targetName, list)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Menambahkan elemen baru ke akhir array.",
                Example:     "array.push: $my_list\n  val: 'New Item'",
        })

        // ARRAY.GET
        <span class="cov8" title="1">eng.Register("collections.get", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var list []interface{}
                var index int
                target := "item"

                if node.Value != nil </span><span class="cov8" title="1">{
                        list, _ = coerce.ToSlice(resolveValue(node.Value, scope))
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "in" || c.Name == "list" </span><span class="cov0" title="0">{
                                list, _ = coerce.ToSlice(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "index" || c.Name == "i" </span><span class="cov8" title="1">{
                                index, _ = coerce.ToInt(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if len(list) == 0 </span><span class="cov0" title="0">{
                        scope.Set(target, nil)
                        return nil
                }</span>

                <span class="cov8" title="1">if index &lt; 0 || index &gt;= len(list) </span><span class="cov0" title="0">{
                        return fmt.Errorf("collections.get: index out of bounds")
                }</span>

                <span class="cov8" title="1">scope.Set(target, list[index])
                return nil</span>
        }, engine.SlotMeta{Example: "collections.get: $list { index: 0; as: $item }"})

        // ARRAY.POP
        <span class="cov8" title="1">eng.Register("array.pop", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                targetName := strings.TrimPrefix(coerce.ToString(node.Value), "$")
                dstName := "popped_item"

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "in" || c.Name == "list" </span><span class="cov0" title="0">{
                                targetName = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov0" title="0">if c.Name == "as" </span><span class="cov0" title="0">{
                                dstName = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">currentVal, ok := scope.Get(targetName)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("array.pop: variable '%s' not found", targetName)
                }</span>

                <span class="cov0" title="0">list, err := coerce.ToSlice(currentVal)
                if err != nil || len(list) == 0 </span><span class="cov0" title="0">{
                        scope.Set(dstName, nil)
                        return nil
                }</span>

                // Pop last item
                <span class="cov0" title="0">lastItem := list[len(list)-1]
                newList := list[:len(list)-1]

                scope.Set(targetName, newList)
                scope.Set(dstName, lastItem)
                return nil</span>
        }, engine.SlotMeta{Example: "array.pop: $stack\n  as: $item"})

        // ARRAY.JOIN
        <span class="cov8" title="1">eng.Register("array.join", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                var list []interface{}
                separator := ","
                target := "joined_string"

                if node.Value != nil </span><span class="cov0" title="0">{
                        list, _ = coerce.ToSlice(resolveValue(node.Value, scope))
                }</span>

                <span class="cov0" title="0">for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "list" </span><span class="cov0" title="0">{
                                list, _ = coerce.ToSlice(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "sep" || c.Name == "separator" </span><span class="cov0" title="0">{
                                separator = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">var strList []string
                for _, item := range list </span><span class="cov0" title="0">{
                        strList = append(strList, coerce.ToString(item))
                }</span>

                <span class="cov0" title="0">scope.Set(target, strings.Join(strList, separator))
                return nil</span>
        }, engine.SlotMeta{Example: "array.join: $tags\n  sep: ', '\n  as: $tag_str"})

        // ==========================================
        // MAP MANIPULATION
        // ==========================================

        // MAP.SET
        <span class="cov8" title="1">eng.Register("map.set", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                targetName := strings.TrimPrefix(coerce.ToString(node.Value), "$")

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "map" </span><span class="cov0" title="0">{
                                targetName = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if targetName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("map.set: target map not specified")
                }</span>

                // Get or Init Map
                <span class="cov8" title="1">currentVal, ok := scope.Get(targetName)
                mapVal, okMap := currentVal.(map[string]interface{})
                if !ok || !okMap || mapVal == nil </span><span class="cov8" title="1">{
                        mapVal = make(map[string]interface{})
                }</span>

                // Set key-values
                // Usage: map.set: $my_map { key: "foo"; val: "bar" }
                // OR shorthand attributes: map.set: $my_map { name: "Budi"; age: 20 }

                <span class="cov8" title="1">explicitKey := ""
                explicitVal := interface{}(nil)
                hasExplicit := false

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "key" </span><span class="cov0" title="0">{
                                explicitKey = coerce.ToString(parseNodeValue(c, scope))
                                hasExplicit = true
                        }</span>
                        <span class="cov8" title="1">if c.Name == "val" || c.Name == "value" </span><span class="cov0" title="0">{
                                explicitVal = parseNodeValue(c, scope)
                        }</span>
                        <span class="cov8" title="1">if c.Name != "map" &amp;&amp; c.Name != "key" &amp;&amp; c.Name != "val" &amp;&amp; c.Name != "value" </span><span class="cov8" title="1">{
                                // Shorthand: name: "Budi"
                                mapVal[c.Name] = parseNodeValue(c, scope)
                        }</span>
                }

                <span class="cov8" title="1">if hasExplicit &amp;&amp; explicitKey != "" </span><span class="cov0" title="0">{
                        mapVal[explicitKey] = explicitVal
                }</span>

                <span class="cov8" title="1">scope.Set(targetName, mapVal)
                return nil</span>
        }, engine.SlotMeta{Example: "map.set: $user\n  age: 30"})

        // MAP.KEYS
        <span class="cov8" title="1">eng.Register("map.keys", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                val := resolveValue(node.Value, scope)
                target := "keys"

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "map" </span><span class="cov0" title="0">{
                                val = parseNodeValue(c, scope)
                        }</span>
                        <span class="cov0" title="0">if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">m, ok := val.(map[string]interface{})
                var keys []interface{}

                if ok </span><span class="cov0" title="0">{
                        for k := range m </span><span class="cov0" title="0">{
                                keys = append(keys, k)
                        }</span>
                }

                <span class="cov0" title="0">scope.Set(target, keys)
                return nil</span>
        }, engine.SlotMeta{Example: "map.keys: $user\n  as: $fields"})
        // LEN
        <span class="cov8" title="1">eng.Register("len", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var val interface{}
                target := "len"

                // Value dari main node? e.g. len: $var
                if node.Value != nil </span><span class="cov8" title="1">{
                        val = resolveValue(node.Value, scope)
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "in" || c.Name == "list" || c.Name == "val" || c.Name == "value" </span><span class="cov0" title="0">{
                                val = parseNodeValue(c, scope)
                        }</span>
                }

                <span class="cov8" title="1">var length int64 = 0

                if val == nil </span><span class="cov0" title="0">{
                        length = 0
                }</span> else<span class="cov8" title="1"> if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                        length = int64(len(str))
                }</span> else<span class="cov0" title="0"> if slice, err := coerce.ToSlice(val); err == nil </span><span class="cov0" title="0">{
                        length = int64(len(slice))
                }</span> else<span class="cov0" title="0"> if m, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        length = int64(len(m))
                }</span>

                <span class="cov8" title="1">scope.Set(target, length)
                return nil</span>
        }, engine.SlotMeta{Example: "len: $my_list { as: $count }"})
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package slots

import (
        "context"
        "fmt"
        "strings"
        "zeno/pkg/dbmanager"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

// Helper: Build query from Node
func buildQuery(node *engine.Node, scope *engine.Scope) (string, string, []interface{}, error) <span class="cov8" title="1">{
        query := ""
        dbName := "default"
        var args []interface{}

        // Value utama: mysql.select: "SELECT * FROM..." (atau $query_var)
        if node.Value != nil </span><span class="cov8" title="1">{
                val, err := MustResolveValue(node.Value, scope, coerce.ToString(node.Value))
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", nil, err
                }</span>
                <span class="cov8" title="1">query = coerce.ToString(val)</span>
        }

        <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                if c.Name == "sql" </span><span class="cov0" title="0">{
                        query = coerce.ToString(parseNodeValue(c, scope))
                }</span>
                <span class="cov8" title="1">if c.Name == "db" || c.Name == "connection" </span><span class="cov0" title="0">{
                        dbName = coerce.ToString(parseNodeValue(c, scope))
                }</span>
                <span class="cov8" title="1">if c.Name == "val" </span><span class="cov0" title="0">{
                        val := parseNodeValue(c, scope)
                        args = append(args, val)
                }</span>
                <span class="cov8" title="1">if c.Name == "params" </span><span class="cov0" title="0">{
                        val := parseNodeValue(c, scope)
                        if list, err := coerce.ToSlice(val); err == nil </span><span class="cov0" title="0">{
                                args = append(args, list...)
                        }</span>
                }
                // Add support for 'bind' parameter
                <span class="cov8" title="1">if c.Name == "bind" </span><span class="cov8" title="1">{
                        // Check if bind has children (any keyname is allowed, order is preserved)
                        if len(c.Children) &gt; 0 </span><span class="cov8" title="1">{
                                for _, child := range c.Children </span><span class="cov8" title="1">{
                                        val := parseNodeValue(child, scope)
                                        args = append(args, val)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return query, dbName, args, nil</span>
}

func RegisterRawDBSlots(eng *engine.Engine, dbMgr *dbmanager.DBManager) <span class="cov8" title="1">{

        // DB.SELECT (Generic)
        handlerSelect := func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                query, dbName, args, err := buildQuery(node, scope)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">target := "rows"
                onlyFirst := false
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "first" </span><span class="cov8" title="1">{
                                onlyFirst, _ = coerce.ToBool(parseNodeValue(c, scope))
                        }</span>
                }

                <span class="cov8" title="1">if query == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.select: query cannot be empty")
                }</span>

                <span class="cov8" title="1">executor, dialect, err := getExecutor(scope, dbMgr, dbName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // [OPTIONAL] We could use dialect here to transform query placeholders if needed
                // for now we just pass it through.
                <span class="cov8" title="1">_ = dialect

                rows, err := executor.QueryContext(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer rows.Close()

                cols, _ := rows.Columns()
                var results []map[string]interface{}

                for rows.Next() </span><span class="cov8" title="1">{
                        columns := make([]interface{}, len(cols))
                        columnPointers := make([]interface{}, len(cols))
                        for i := range columns </span><span class="cov8" title="1">{
                                columnPointers[i] = &amp;columns[i]
                        }</span>

                        <span class="cov8" title="1">if err := rows.Scan(columnPointers...); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">m := make(map[string]interface{})
                        for i, colName := range cols </span><span class="cov8" title="1">{
                                val := columns[i]
                                b, ok := val.([]byte)
                                if ok </span><span class="cov0" title="0">{
                                        m[colName] = string(b)
                                }</span> else<span class="cov8" title="1"> {
                                        m[colName] = val
                                }</span>
                        }
                        <span class="cov8" title="1">results = append(results, m)</span>
                }

                <span class="cov8" title="1">if onlyFirst </span><span class="cov8" title="1">{
                        if len(results) &gt; 0 </span><span class="cov8" title="1">{
                                scope.Set(target, results[0])
                        }</span> else<span class="cov0" title="0"> {
                                scope.Set(target, nil)
                        }</span>
                } else<span class="cov0" title="0"> {
                        scope.Set(target, results)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">eng.Register("db.select", handlerSelect, engine.SlotMeta{
                Description: "Perform a SELECT query and retrieve multiple rows.",
                Example:     "db.select: 'SELECT * FROM users'\n  as: $users",
                ValueType:   "string",
                Inputs: map[string]engine.InputMeta{
                        "as":     {Description: "Variable to store results", Required: false, Type: "string"},
                        "first":  {Description: "Return only the first row as a map (Default: false)", Required: false, Type: "bool"},
                        "db":     {Description: "Database connection name", Required: false, Type: "string"},
                        "bind":   {Description: "Bind parameters container", Required: false, Type: "any"},
                        "val":    {Description: "Single bind value", Required: false, Type: "any"},
                        "params": {Description: "List of bind values", Required: false, Type: "list"},
                },
        })
        eng.Register("mysql.select", handlerSelect, engine.SlotMeta{Description: "Alias for db.select"})
        eng.Register("db.query", handlerSelect, engine.SlotMeta{Description: "Alias for db.select"})

        // DB.EXECUTE (Generic)
        handlerExecute := func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                query, dbName, args, err := buildQuery(node, scope)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if query == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.execute: query cannot be empty")
                }</span>

                <span class="cov8" title="1">executor, _, err := getExecutor(scope, dbMgr, dbName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">res, err := executor.ExecContext(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">affected, _ := res.RowsAffected()
                lastId, _ := res.LastInsertId()

                scope.Set("db_affected", affected)
                scope.Set("db_last_id", lastId)

                return nil</span>
        }

        <span class="cov8" title="1">eng.Register("db.execute", handlerExecute, engine.SlotMeta{
                Description: "Execute a raw SQL query (INSERT, UPDATE, DELETE, etc.).",
                Example:     "db.execute: 'UPDATE users SET x=1'",
                ValueType:   "string",
                Inputs: map[string]engine.InputMeta{
                        "db":     {Description: "Database connection name", Required: false, Type: "string"},
                        "bind":   {Description: "Bind parameters container", Required: false, Type: "any"},
                        "val":    {Description: "Single bind value", Required: false, Type: "any"},
                        "params": {Description: "List of bind values", Required: false, Type: "list"},
                },
        })
        eng.Register("mysql.execute", handlerExecute, engine.SlotMeta{Description: "Alias for db.execute"})</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package slots

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "os"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "time"

        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"

        "github.com/xuri/excelize/v2"
)

func RegisterExcelSlots(eng *engine.Engine) <span class="cov0" title="0">{
        eng.Register("excel.from_template", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // 1. Get Template Path
                <span class="cov0" title="0">templatePath := coerce.ToString(resolveValue(node.Value, scope))
                if templatePath == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("excel.from_template: template path required")
                }</span>

                // Clean path
                <span class="cov0" title="0">fullPath := templatePath
                if !filepath.IsAbs(fullPath) </span><span class="cov0" title="0">{
                        cwd, _ := os.Getwd()
                        fullPath = filepath.Join(cwd, templatePath)
                }</span>
                <span class="cov0" title="0">slog.Info("Excel Export", "template", fullPath)

                // 2. Open File
                f, err := excelize.OpenFile(fullPath)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Excel Open Failed", "error", err, "path", fullPath)
                        return fmt.Errorf("excel.from_template: failed to open template '%s': %v", templatePath, err)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                        }</span>
                }()

                <span class="cov0" title="0">filename := "export.xlsx"
                sheetName := "Sheet1"
                markerData := make(map[string]interface{})

                // 3. Process Logic
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        // Metadata
                        if c.Name == "filename" </span><span class="cov0" title="0">{
                                filename = coerce.ToString(resolveValue(c.Value, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "sheet" </span><span class="cov0" title="0">{
                                sheetName = coerce.ToString(resolveValue(c.Value, scope))
                        }</span>

                        // Single Cell Overrides
                        <span class="cov0" title="0">if c.Name == "cell" </span><span class="cov0" title="0">{
                                cellCoord := coerce.ToString(resolveValue(c.Value, scope))
                                for _, child := range c.Children </span><span class="cov0" title="0">{
                                        if child.Name == "val" || child.Name == "value" </span><span class="cov0" title="0">{
                                                val := resolveValue(child.Value, scope)
                                                f.SetCellValue(sheetName, cellCoord, val)
                                        }</span>
                                }
                        }

                        // Batch Data &amp; Markers
                        <span class="cov0" title="0">if c.Name == "data" </span><span class="cov0" title="0">{
                                dataVal := parseNodeValue(c, scope)
                                if m, ok := dataVal.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        for k, v := range m </span><span class="cov0" title="0">{
                                                // If key looks like a cell coordinate (A1, B2), set directly
                                                if isCellCoord(k) </span><span class="cov0" title="0">{
                                                        f.SetCellValue(sheetName, k, v)
                                                }</span> else<span class="cov0" title="0"> {
                                                        // Auto-detect JSON string in data
                                                        // This handles cases where data comes as a JSON string from ZenoLang
                                                        if strVal, ok := v.(string); ok </span><span class="cov0" title="0">{
                                                                strVal = strings.TrimSpace(strVal)
                                                                // Handle ZenoLang @json(...) directive passed as raw string
                                                                // Regex: ^@\s*json\s*\((.*)\)$
                                                                if strings.HasPrefix(strVal, "@") </span><span class="cov0" title="0">{
                                                                        // Simple manual parsing to avoid regex overhead/complexity
                                                                        lower := strings.ToLower(strVal)
                                                                        idxOpen := strings.Index(lower, "(")
                                                                        idxClose := strings.LastIndex(lower, ")")
                                                                        if idxOpen &gt; 0 &amp;&amp; idxClose &gt; idxOpen &amp;&amp; strings.Contains(lower, "json") </span><span class="cov0" title="0">{
                                                                                // Check if it's actually @...json...
                                                                                prefix := lower[:idxOpen]
                                                                                if strings.Contains(prefix, "json") </span><span class="cov0" title="0">{
                                                                                        strVal = strVal[idxOpen+1 : idxClose]
                                                                                        strVal = strings.TrimSpace(strVal)
                                                                                }</span>
                                                                        }
                                                                }

                                                                // Strip outer quotes again if they were inside the @json(...)
                                                                <span class="cov0" title="0">if len(strVal) &gt;= 2 &amp;&amp; ((strings.HasPrefix(strVal, "'") &amp;&amp; strings.HasSuffix(strVal, "'")) ||
                                                                        (strings.HasPrefix(strVal, "\"") &amp;&amp; strings.HasSuffix(strVal, "\""))) </span><span class="cov0" title="0">{
                                                                        strVal = strVal[1 : len(strVal)-1]
                                                                        strVal = strings.TrimSpace(strVal)
                                                                }</span>

                                                                // Debug: print exactly what we represent
                                                                // slog.Info("Checking JSON Candidate", "val_raw", strVal)
                                                                <span class="cov0" title="0">if (strings.HasPrefix(strVal, "{") &amp;&amp; strings.HasSuffix(strVal, "}")) ||
                                                                        (strings.HasPrefix(strVal, "[") &amp;&amp; strings.HasSuffix(strVal, "]")) </span><span class="cov0" title="0">{
                                                                        var parsed interface{}
                                                                        // Try Unmarshal
                                                                        err := json.Unmarshal([]byte(strVal), &amp;parsed)
                                                                        if err == nil </span><span class="cov0" title="0">{
                                                                                v = parsed
                                                                                slog.Info("JSON Auto-Parse Success", "key", k)
                                                                        }</span> else<span class="cov0" title="0"> {
                                                                                slog.Warn("JSON Auto-Parse Failed", "key", k, "error", err)
                                                                        }</span>
                                                                } else<span class="cov0" title="0"> {
                                                                        slog.Info("JSON Candidate Rejected", "reason", "no_brace_bracket_prefix")
                                                                }</span>
                                                        }

                                                        // Otherwise treat as marker data
                                                        <span class="cov0" title="0">markerData[k] = v
                                                        slog.Info("Data Key", "key", k, "type", fmt.Sprintf("%T", v))</span>
                                                }
                                        }
                                }
                        }
                        // Formula Support
                        <span class="cov0" title="0">if c.Name == "formulas" </span><span class="cov0" title="0">{
                                val := parseNodeValue(c, scope)
                                if m, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        for k, v := range m </span><span class="cov0" title="0">{
                                                formula := coerce.ToString(v)
                                                if isCellCoord(k) </span><span class="cov0" title="0">{
                                                        if err := f.SetCellFormula(sheetName, k, formula); err != nil </span><span class="cov0" title="0">{
                                                                slog.Warn("Excel SetFormula Failed", "cell", k, "formula", formula, "error", err)
                                                        }</span>
                                                }
                                        }
                                }
                        }

                        // Image Support
                        <span class="cov0" title="0">if c.Name == "images" </span><span class="cov0" title="0">{
                                val := parseNodeValue(c, scope)
                                // Expected: images: { "A1": "/path/to/image.png" }
                                if m, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        for k, v := range m </span><span class="cov0" title="0">{
                                                imgPath := coerce.ToString(v)
                                                if !filepath.IsAbs(imgPath) </span><span class="cov0" title="0">{
                                                        cwd, _ := os.Getwd()
                                                        imgPath = filepath.Join(cwd, imgPath)
                                                }</span>

                                                <span class="cov0" title="0">if isCellCoord(k) </span><span class="cov0" title="0">{
                                                        // Basic image insertion
                                                        // Scaling can be added via options if needed later
                                                        err := f.AddPicture(sheetName, k, imgPath, &amp;excelize.GraphicOptions{
                                                                AutoFit: true,
                                                        })
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                slog.Warn("Excel AddPicture Failed", "cell", k, "path", imgPath, "error", err)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }

                // 4. Process Template Markers
                <span class="cov0" title="0">if len(markerData) &gt; 0 </span><span class="cov0" title="0">{
                        if err := processMarkers(f, sheetName, markerData); err != nil </span><span class="cov0" title="0">{
                                slog.Error("Excel Marker Process Failed", "error", err)
                                return err
                        }</span>
                }

                // 5. Send Response
                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
                w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%s", filename))
                w.Header().Set("Last-Modified", time.Now().UTC().Format(http.TimeFormat))
                w.WriteHeader(http.StatusOK) // Explicit Status OK

                slog.Info("Excel Writing Response...")
                if err := f.Write(w); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Excel Write Failed", "error", err)
                        return fmt.Errorf("excel.from_template: failed to write response: %v", err)
                }</span>
                <span class="cov0" title="0">slog.Info("Excel Export Complete")

                return nil</span>
        }, engine.SlotMeta{
                Description: "Generate Excel from template with marker support",
                Example: `excel.from_template: 'template.xlsx'
  data:
    title: "Report"
    users: $user_list`,
        })
}

// Simple heuristic check for Cell Coordinate (e.g., A1, AA10, not "title")
func isCellCoord(s string) bool <span class="cov0" title="0">{
        matched, _ := regexp.MatchString(`^[A-Z]+[0-9]+$`, s)
        return matched
}</span>

// ==========================================
// TEMPLATE MARKER LOGIC
// ==========================================

func processMarkers(f *excelize.File, sheet string, data map[string]interface{}) error <span class="cov0" title="0">{
        rows, err := f.GetRows(sheet)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">re := regexp.MustCompile(`\{\{\s*([\w\.]+)\s*\}\}`)

        // Struct to track markers found in the sheet
        type Marker struct {
                Row, Col int
                Key      string
                Original string // {{ key }}
        }

        var markers []Marker

        // 1. Scan for all markers
        // Note: rows is [][]string. index i is row-1.
        for rIdx, row := range rows </span><span class="cov0" title="0">{
                for cIdx, cellValue := range row </span><span class="cov0" title="0">{
                        matches := re.FindStringSubmatch(cellValue)
                        if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                                markers = append(markers, Marker{
                                        Row:      rIdx + 1, // 1-based index
                                        Col:      cIdx + 1, // 1-based index
                                        Key:      matches[1],
                                        Original: matches[0],
                                })
                        }</span>
                }
        }

        // 2. Separate Scalar vs List Replacement
        // We need to process from BOTTOM to TOP for List expansions to avoid shifting issues affecting unprocessed markers.
        // Actually, sorting markers reversely by Row is sufficient.

        <span class="cov0" title="0">sort.Slice(markers, func(i, j int) bool </span><span class="cov0" title="0">{
                return markers[i].Row &gt; markers[j].Row // Descending Sort
        }</span>)

        // Track inserted rows shift for debugging or future use?
        // Not needed if we process bottom-up.

        <span class="cov0" title="0">for _, m := range markers </span><span class="cov0" title="0">{
                // Get Value from Data
                val := getNestedValue(data, m.Key)

                // Check type
                if _, err := coerce.ToSlice(val); err == nil </span>{<span class="cov0" title="0">
                        // === LIST EXPANSION ===
                        // Logic handled in Re-Process step below.
                }</span> else<span class="cov0" title="0"> {
                        // === SCALAR REPLACEMENT ===
                        cellName, _ := excelize.CoordinatesToCellName(m.Col, m.Row)
                        f.SetCellValue(sheet, cellName, val)
                }</span>
        }

        // 3. RE-PROCESS FOR LISTS (Row-Grouping)
        // We iterate original rows top-down? Or bottom-up?
        // Bottom-up is safer for insertion.

        // Group markers by Row
        <span class="cov0" title="0">rowMarkers := make(map[int][]Marker)
        for _, m := range markers </span><span class="cov0" title="0">{
                rowMarkers[m.Row] = append(rowMarkers[m.Row], m)
        }</span>

        // Get sorted keys (Row Indices) Descending
        <span class="cov0" title="0">var rowsIndices []int
        for r := range rowMarkers </span><span class="cov0" title="0">{
                rowsIndices = append(rowsIndices, r)
        }</span>
        <span class="cov0" title="0">sort.Sort(sort.Reverse(sort.IntSlice(rowsIndices)))

        for _, rIdx := range rowsIndices </span><span class="cov0" title="0">{
                ms := rowMarkers[rIdx]

                // Check if any marker in this row is a List
                var listLen int = 0
                var isListRow bool = false

                for _, m := range ms </span><span class="cov0" title="0">{
                        val := getNestedValue(data, m.Key)
                        if slice, err := coerce.ToSlice(val); err == nil &amp;&amp; len(slice) &gt; 1 </span><span class="cov0" title="0">{
                                if isListRow &amp;&amp; len(slice) != listLen </span>{<span class="cov0" title="0">
                                        // Mismatch lengths! Warning.
                                }</span>
                                <span class="cov0" title="0">listLen = len(slice)
                                isListRow = true</span>
                        }
                }

                <span class="cov0" title="0">if isListRow </span><span class="cov0" title="0">{
                        // Insert rows
                        // We need to insert N-1 rows
                        numToInsert := listLen - 1
                        if numToInsert &gt; 0 </span><span class="cov0" title="0">{
                                // Use InsertRows (plural) which takes count argument in v2
                                if err := f.InsertRows(sheet, rIdx+1, numToInsert); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error inserting rows: %v\n", err)
                                }</span>
                        }

                        // Prepare to fill data
                        // For each marker in this row
                        <span class="cov0" title="0">for _, m := range ms </span><span class="cov0" title="0">{
                                val := getNestedValue(data, m.Key)
                                slice, err := coerce.ToSlice(val)
                                if err != nil </span><span class="cov0" title="0">{
                                        // Scalar in a list row?
                                        cellName, _ := excelize.CoordinatesToCellName(m.Col, rIdx)
                                        f.SetCellValue(sheet, cellName, val)
                                        continue</span>
                                }

                                // Fill slice values
                                <span class="cov0" title="0">for i := 0; i &lt; listLen; i++ </span><span class="cov0" title="0">{
                                        if i &gt;= len(slice) </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                        // Write to Row rIdx + i
                                        <span class="cov0" title="0">cellName, _ := excelize.CoordinatesToCellName(m.Col, rIdx+i)
                                        f.SetCellValue(sheet, cellName, slice[i])</span>
                                }
                        }

                } else<span class="cov0" title="0"> {
                        // Scalar Row - Just process values
                        for _, m := range ms </span><span class="cov0" title="0">{
                                val := getNestedValue(data, m.Key)
                                originalVal, _ := f.GetCellValue(sheet, fmt.Sprintf("%s%d", getColName(m.Col), m.Row)) // simplified
                                newVal := strings.Replace(originalVal, m.Original, coerce.ToString(val), -1)

                                cellName, _ := excelize.CoordinatesToCellName(m.Col, m.Row)
                                f.SetCellValue(sheet, cellName, newVal)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper to get nested value "users.0.name"
func getNestedValue(data map[string]interface{}, key string) interface{} <span class="cov8" title="1">{
        parts := strings.Split(key, ".")
        var current interface{} = data

        for _, part := range parts </span><span class="cov8" title="1">{
                slog.Info("Nested Traverse", "part", part, "currentType", fmt.Sprintf("%T", current))
                if m, ok := current.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        if val, exists := m[part]; exists </span><span class="cov8" title="1">{
                                current = val
                        }</span> else<span class="cov8" title="1"> {
                                return nil
                        }</span>
                } else<span class="cov8" title="1"> if slice, ok := current.([]interface{}); ok </span><span class="cov8" title="1">{
                        // List Projection: items.name -&gt; [A, B, C]
                        // We map the next part over the slice
                        var projected []interface{}
                        for _, item := range slice </span><span class="cov8" title="1">{
                                if itemMap, ok := item.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        if val, exists := itemMap[part]; exists </span><span class="cov8" title="1">{
                                                projected = append(projected, val)
                                        }</span> else<span class="cov8" title="1"> {
                                                projected = append(projected, nil)
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">current = projected</span>
                } else<span class="cov0" title="0"> {
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return current</span>
}

func getColName(n int) string <span class="cov0" title="0">{
        name, _ := excelize.ColumnNumberToName(n)
        return name
}</span>

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package slots

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

func RegisterFileSystemSlots(eng *engine.Engine) <span class="cov8" title="1">{

        // 1. IO.FILE.WRITE
        eng.Register("io.file.write", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var path, content string
                var mode int = 0644

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "path" </span><span class="cov8" title="1">{
                                path = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "content" </span><span class="cov8" title="1">{
                                content = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "mode" </span><span class="cov0" title="0">{
                                if m, err := coerce.ToInt(val); err == nil </span><span class="cov0" title="0">{
                                        mode = m
                                }</span>
                        }
                }

                <span class="cov8" title="1">if path == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("io.file.write: path is required")
                }</span>

                <span class="cov8" title="1">cleanPath := filepath.Clean(filepath.FromSlash(path))

                // [SECURITY] Block writing to critical source/config files
                // Allow unrestricted access ONLY in development mode
                if os.Getenv("APP_ENV") != "development" </span><span class="cov8" title="1">{
                        ext := strings.ToLower(filepath.Ext(cleanPath))
                        if ext == ".zl" || ext == ".go" || ext == ".env" || strings.Contains(cleanPath, ".git") </span><span class="cov8" title="1">{
                                return fmt.Errorf("security violation: modifying '%s' files is restricted in production", ext)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Optional: Log warning in dev mode
                        fmt.Printf("  [DEV MODE] Writing to sensitive file: %s\n", cleanPath)
                }</span>

                <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(cleanPath), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return os.WriteFile(cleanPath, []byte(content), os.FileMode(mode))</span>
        }, engine.SlotMeta{})

        // 2. IO.FILE.READ
        <span class="cov8" title="1">eng.Register("io.file.read", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var path, target string
                target = "file_content"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "path" </span><span class="cov8" title="1">{
                                path = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if node.Value != nil </span><span class="cov0" title="0">{
                        val, err := MustResolveValue(node.Value, scope, coerce.ToString(node.Value))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">path = coerce.ToString(val)</span>
                }

                <span class="cov8" title="1">if path == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("io.file.read: path is required")
                }</span>

                <span class="cov8" title="1">cleanPath := filepath.Clean(filepath.FromSlash(path))
                content, err := os.ReadFile(cleanPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">scope.Set(target, string(content))
                return nil</span>
        }, engine.SlotMeta{Example: "io.file.read: $path\n  as: $content"})

        // 3. IO.DIR.CREATE
        <span class="cov8" title="1">eng.Register("io.dir.create", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                path := coerce.ToString(resolveValue(node.Value, scope))
                if path == "" </span><span class="cov0" title="0">{
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "path" </span><span class="cov0" title="0">{
                                        path = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                        }
                }
                <span class="cov0" title="0">if path == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("io.dir.create: path is required")
                }</span>
                <span class="cov0" title="0">return os.MkdirAll(filepath.Clean(filepath.FromSlash(path)), 0755)</span>
        }, engine.SlotMeta{})

        // 4. IO.FILE.DELETE
        <span class="cov8" title="1">eng.Register("io.file.delete", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var pathRaw string
                if node.Value != nil </span><span class="cov8" title="1">{
                        val, err := MustResolveValue(node.Value, scope, coerce.ToString(node.Value))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">pathRaw = coerce.ToString(val)</span>
                }

                <span class="cov8" title="1">if pathRaw == "" </span><span class="cov0" title="0">{
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "path" </span><span class="cov0" title="0">{
                                        pathRaw = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                        }
                }

                <span class="cov8" title="1">if pathRaw == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("io.file.delete: path is required")
                }</span>

                <span class="cov8" title="1">cleanPath := filepath.Clean(filepath.FromSlash(pathRaw))
                fmt.Printf(" [FILESYSTEM] Deleting: '%s'\n", cleanPath)

                err := os.Remove(cleanPath)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to delete file: %v", err)</span>
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{Example: "io.file.delete: $path"})
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package slots

import (
        "context"
        "fmt"
        "sync"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

// RegisterFunctionSlots mendaftarkan slot 'fn' dan 'call'
// Mekanisme: 'fn' menyimpan *Node ke GLOBAL REGISTRY, 'call' mengeksekusinya.
func RegisterFunctionSlots(eng *engine.Engine) <span class="cov8" title="1">{

        // Global Function Registry (thread-safe)
        var (
                functionRegistry   = make(map[string]*engine.Node)
                functionRegistryMu sync.RWMutex
        )

        // ==========================================
        // 1. SLOT: FN (Define Function)
        // ==========================================
        // Menyimpan node children sebagai "Function Body" di dalam variabel scope.
        // Tidak dieksekusi saat definisi.
        // Contoh:
        // fn: my_func {
        //    log: "Hello"
        // }
        eng.Register("fn", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // 1. Ambil Nama Fungsi
                funcName := coerce.ToString(resolveValue(node.Value, scope))
                if funcName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("fn: function name is required")
                }</span>

                // 2. Simpan Node ini (atau children-nya) ke Scope
                // Kita simpan pointer ke Node itu sendiri agar bisa di-execute nanti.
                // Prefix "_fn_" bisa digunakan untuk namespace internal jika perlu,
                // tapi untuk fleksibilitas meta-programming, simpan sebagai variable biasa pun oke.
                // Namun agar aman dari overwrite variabel data, kita pakai prefix/suffix atau tipe data khusus.
                // Disini kita simpan raw *engine.Node

                <span class="cov8" title="1">functionRegistryMu.Lock()
                functionRegistry[funcName] = node
                functionRegistryMu.Unlock()
                fmt.Printf("[DEBUG FN] Registered function '%s' in scope\n", funcName)

                return nil</span>
        }, engine.SlotMeta{
                Description: "Mendefinisikan fungsi (menyimpan blok kode untuk dipanggil nanti).",
                Example:     "fn: hitung_gaji {\n  ...\n}",
        })

        // ==========================================
        // 2. SLOT: CALL (Invoke Function)
        // ==========================================
        // Memanggil node yang disimpan oleh 'fn' dari GLOBAL REGISTRY.
        // Contoh: call: my_func
        <span class="cov8" title="1">eng.Register("call", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                funcName := coerce.ToString(resolveValue(node.Value, scope))
                if funcName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("call: function name is required")
                }</span>

                // 1. Retrieve Function Node from GLOBAL REGISTRY
                <span class="cov8" title="1">functionRegistryMu.RLock()
                funcNode, found := functionRegistry[funcName]
                functionRegistryMu.RUnlock()

                fmt.Printf("[DEBUG CALL] Looking for function '%s', found=%v (from GLOBAL registry)\n", funcName, found)
                if !found </span><span class="cov0" title="0">{
                        return fmt.Errorf("call: function '%s' not found", funcName)
                }</span>

                // 2. Execute Children of the Function Node
                // Kita eksekusi children-nya seolah-olah mereka ada di sini.
                // Scope: Apakah New Scope atau Current Scope?
                // ZenoLang (HyperLambda style) biasanya mewarisi scope (Dynamic Scope).
                // Jadi variabel $gaji yang ada di scope pemanggil bisa diakses di dalam fungsi.

                <span class="cov8" title="1">for _, child := range funcNode.Children </span><span class="cov8" title="1">{
                        if err := eng.Execute(ctx, child, scope); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Memanggil fungsi yang didefinisikan dengan fn.",
                Example:     "call: hitung_gaji",
        })

        // ==========================================
        // 3. SLOT: RETURN (Early Exit)
        // ==========================================
        // Note: Implementasi return membutuhkan support di engine.Execute loop
        // untuk menangkap error khusus (seperti break/continue).
        // Jika engine belum support handle error "Return", ini hanya akan stop execution blok saat ini.
        // Untuk saat ini kita skip dulu atau implementasi basic error.
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package slots

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/fastjson"
        "zeno/pkg/utils/coerce"
)

func RegisterHTTPServerSlots(eng *engine.Engine) <span class="cov8" title="1">{

        // 1. HTTP.RESPONSE
        eng.Register("http.response", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.response: not in http context")
                }</span>

                <span class="cov0" title="0">var status int = 200
                var contentType string = "application/json"
                var body interface{}

                if node.Value != nil </span><span class="cov0" title="0">{
                        val := resolveValue(node.Value, scope)
                        if s, err := coerce.ToInt(val); err == nil </span><span class="cov0" title="0">{
                                status = s
                        }</span>
                }

                <span class="cov0" title="0">for _, c := range node.Children </span><span class="cov0" title="0">{
                        val := parseNodeValue(c, scope)

                        if c.Name == "status" </span><span class="cov0" title="0">{
                                if s, err := coerce.ToInt(val); err == nil </span><span class="cov0" title="0">{
                                        status = s
                                }</span>
                        }
                        <span class="cov0" title="0">if c.Name == "type" </span><span class="cov0" title="0">{
                                contentType = coerce.ToString(val)
                        }</span>
                        <span class="cov0" title="0">if c.Name == "data" || c.Name == "body" </span><span class="cov0" title="0">{
                                body = val
                        }</span>
                }

                <span class="cov0" title="0">w.Header().Set("Content-Type", contentType)
                w.WriteHeader(status)

                if body != nil </span><span class="cov0" title="0">{
                        if contentType == "application/json" </span><span class="cov0" title="0">{
                                // Use fast JSON encoder (2-3x faster than encoding/json)
                                fastjson.NewEncoder(w).Encode(body)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprint(w, coerce.ToString(body))
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{Example: "http.response: 200\n  body: $data"})

        // 2. HTTP.REDIRECT
        <span class="cov8" title="1">eng.Register("http.redirect", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                r, ok2 := ctx.Value("httpRequest").(*http.Request)
                if !ok || !ok2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.redirect: not in http context")
                }</span>

                <span class="cov8" title="1">url := coerce.ToString(resolveValue(node.Value, scope))
                if url == "" </span><span class="cov0" title="0">{
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "to" || c.Name == "url" </span><span class="cov0" title="0">{
                                        url = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                        }
                }

                <span class="cov8" title="1">if url == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.redirect: url is required")
                }</span>

                <span class="cov8" title="1">http.Redirect(w, r, url, http.StatusFound)
                return ErrReturn</span>
        }, engine.SlotMeta{Example: "http.redirect: '/home'"})

        // 3. COOKIE.SET
        <span class="cov8" title="1">eng.Register("cookie.set", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("cookie.set: missing context")
                }</span>

                <span class="cov8" title="1">name := ""
                value := ""
                maxAge := 3600

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "name" </span><span class="cov8" title="1">{
                                name = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "val" </span><span class="cov8" title="1">{
                                value = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "age" </span><span class="cov0" title="0">{
                                if i, err := coerce.ToInt(val); err == nil </span><span class="cov0" title="0">{
                                        maxAge = i
                                }</span>
                        }
                }

                <span class="cov8" title="1">if name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("cookie.set: name required")
                }</span>

                <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                        Name: name, Value: value, MaxAge: maxAge, Path: "/", HttpOnly: true,
                })
                return nil</span>
        }, engine.SlotMeta{Example: "cookie.set\n  name: 'token'\n  val: $token"})

        // 4. HTTP.FORM
        <span class="cov8" title="1">eng.Register("http.form", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                key := coerce.ToString(resolveValue(node.Value, scope))
                target := key

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                // Get form data injected by Router
                <span class="cov0" title="0">if formData, ok := scope.Get("form"); ok </span><span class="cov0" title="0">{
                        if m, ok := formData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if val, exists := m[key]; exists </span><span class="cov0" title="0">{
                                        scope.Set(target, val)
                                        return nil
                                }</span>
                        }
                }

                // If not present, set empty string
                <span class="cov0" title="0">scope.Set(target, "")
                return nil</span>
        }, engine.SlotMeta{Example: "http.form: 'email'\n  as: $email"})

        // 5. HTTP.QUERY (Fixed: Use resolveValue)
        <span class="cov8" title="1">eng.Register("http.query", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                reqVal := ctx.Value("httpRequest")
                if reqVal == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">r := reqVal.(*http.Request)

                // [FIX] Use resolveValue so quotes ("page") are cleaned up to (page)
                param := coerce.ToString(resolveValue(node.Value, scope))
                target := param

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">val := r.URL.Query().Get(param)
                scope.Set(target, val)
                return nil</span>
        }, engine.SlotMeta{Example: "http.query: 'page'\n  as: $page_param"})

        // 6. HTTP.HEADER (Extract HTTP headers)
        <span class="cov8" title="1">eng.Register("http.header", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                reqVal := ctx.Value("httpRequest")
                if reqVal == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">r := reqVal.(*http.Request)

                // Get header name from node value
                headerName := coerce.ToString(resolveValue(node.Value, scope))
                target := headerName

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">val := r.Header.Get(headerName)
                scope.Set(target, val)
                return nil</span>
        }, engine.SlotMeta{Example: "http.header: 'X-Tenant-ID'\n  as: $tenant_id"})

        // 7. HTTP.HOST (Extract HTTP host)
        <span class="cov8" title="1">eng.Register("http.host", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                reqVal := ctx.Value("httpRequest")
                if reqVal == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">r := reqVal.(*http.Request)

                target := "host"
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">scope.Set(target, r.Host)
                return nil</span>
        }, engine.SlotMeta{Example: "http.host: { as: $host }"})

        // 8. HTTP.BODY (Raw Body)
        <span class="cov8" title="1">eng.Register("http.body", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                reqVal := ctx.Value("httpRequest")
                if reqVal == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">r := reqVal.(*http.Request)

                target := "body"
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">if r.Body == nil </span><span class="cov0" title="0">{
                        scope.Set(target, "")
                        return nil
                }</span>

                // Read body
                <span class="cov0" title="0">bodyBytes, err := io.ReadAll(r.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.body: failed to read: %v", err)
                }</span>

                // Restore body so it can be read again
                <span class="cov0" title="0">r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

                scope.Set(target, string(bodyBytes))
                return nil</span>
        }, engine.SlotMeta{Example: "http.body { as: $raw }"})

        // 9. HTTP.JSON_BODY (Auto Parse)
        <span class="cov8" title="1">eng.Register("http.json_body", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                reqVal := ctx.Value("httpRequest")
                if reqVal == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">r := reqVal.(*http.Request)

                target := "input"
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">if r.Body == nil </span><span class="cov0" title="0">{
                        scope.Set(target, map[string]interface{}{})
                        return nil
                }</span>

                // Read body
                <span class="cov0" title="0">bodyBytes, err := io.ReadAll(r.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.json_body: failed to read: %v", err)
                }</span>

                // Restore body
                <span class="cov0" title="0">r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

                if len(bodyBytes) == 0 </span><span class="cov0" title="0">{
                        scope.Set(target, map[string]interface{}{})
                        return nil
                }</span>

                <span class="cov0" title="0">var result interface{}
                if err := json.Unmarshal(bodyBytes, &amp;result); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.json_body: invalid json: %v", err)
                }</span>

                <span class="cov0" title="0">scope.Set(target, result)
                return nil</span>
        }, engine.SlotMeta{Example: "http.json_body { as: $data }"})

        // ==========================================
        // HTTP RESPONSE HELPERS (Syntax Sugar)
        // ==========================================

        // Helper function to send JSON response with auto success field
        <span class="cov8" title="1">sendJSONResponse := func(ctx context.Context, statusCode int, node *engine.Node, scope *engine.Scope, success bool) error </span><span class="cov8" title="1">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("http response helper: not in http context")
                }</span>

                // Build response body
                <span class="cov8" title="1">responseBody := make(map[string]interface{})
                responseBody["success"] = success

                // Parse children for message, data, errors, etc.
                for _, child := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(child, scope)
                        responseBody[child.Name] = val
                }</span>

                // Send JSON response
                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(statusCode)
                fastjson.NewEncoder(w).Encode(responseBody)
                return nil</span>
        }

        // Success Responses (2xx)
        <span class="cov8" title="1">eng.Register("http.ok", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                return sendJSONResponse(ctx, 200, node, scope, true)
        }</span>, engine.SlotMeta{
                Description: "Send 200 OK response with auto JSON wrapping",
                Example:     "http.ok: {\n  data: $posts\n}",
        })

        <span class="cov8" title="1">eng.Register("http.created", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                return sendJSONResponse(ctx, 201, node, scope, true)
        }</span>, engine.SlotMeta{
                Description: "Send 201 Created response",
                Example:     "http.created: {\n  message: \"Resource created\"\n  id: $db_last_id\n}",
        })

        <span class="cov8" title="1">eng.Register("http.accepted", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                return sendJSONResponse(ctx, 202, node, scope, true)
        }</span>, engine.SlotMeta{
                Description: "Send 202 Accepted response",
                Example:     "http.accepted: {\n  message: \"Request accepted\"\n}",
        })

        <span class="cov8" title="1">eng.Register("http.no_content", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.no_content: not in http context")
                }</span>
                <span class="cov0" title="0">w.WriteHeader(204)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Send 204 No Content response",
                Example:     "http.no_content",
        })

        // Client Error Responses (4xx)
        <span class="cov8" title="1">eng.Register("http.bad_request", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                return sendJSONResponse(ctx, 400, node, scope, false)
        }</span>, engine.SlotMeta{
                Description: "Send 400 Bad Request response",
                Example:     "http.bad_request: {\n  message: \"Invalid parameters\"\n  errors: $errors\n}",
        })

        <span class="cov8" title="1">eng.Register("http.unauthorized", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                return sendJSONResponse(ctx, 401, node, scope, false)
        }</span>, engine.SlotMeta{
                Description: "Send 401 Unauthorized response",
                Example:     "http.unauthorized: {\n  message: \"Authentication required\"\n}",
        })

        <span class="cov8" title="1">eng.Register("http.forbidden", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                return sendJSONResponse(ctx, 403, node, scope, false)
        }</span>, engine.SlotMeta{
                Description: "Send 403 Forbidden response",
                Example:     "http.forbidden: {\n  message: \"Access denied\"\n}",
        })

        <span class="cov8" title="1">eng.Register("http.not_found", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                return sendJSONResponse(ctx, 404, node, scope, false)
        }</span>, engine.SlotMeta{
                Description: "Send 404 Not Found response",
                Example:     "http.not_found: {\n  message: \"Resource not found\"\n}",
        })

        <span class="cov8" title="1">eng.Register("http.validation_error", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                return sendJSONResponse(ctx, 422, node, scope, false)
        }</span>, engine.SlotMeta{
                Description: "Send 422 Validation Error response",
                Example:     "http.validation_error: {\n  message: \"Validation failed\"\n  errors: $errors\n}",
        })

        // Server Error Responses (5xx)
        <span class="cov8" title="1">eng.Register("http.server_error", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                return sendJSONResponse(ctx, 500, node, scope, false)
        }</span>, engine.SlotMeta{
                Description: "Send 500 Internal Server Error response",
                Example:     "http.server_error: {\n  message: \"Internal error\"\n  error: $error\n}",
        })

}
</pre>
		
		<pre class="file" id="file10" style="display: none">package slots

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

func RegisterHTTPClientSlots(eng *engine.Engine) <span class="cov8" title="1">{
        eng.Register("http.request", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var url, method string
                var headers map[string]interface{}
                var body interface{}
                var timeoutSeconds int = 30
                target := "response"

                // 1. Parse Arguments (Value &amp; Children)
                if node.Value != nil </span><span class="cov8" title="1">{
                        url = coerce.ToString(resolveValue(node.Value, scope))
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        switch c.Name </span>{
                        case "url":<span class="cov0" title="0">
                                url = coerce.ToString(val)</span>
                        case "method":<span class="cov8" title="1">
                                method = strings.ToUpper(coerce.ToString(val))</span>
                        case "headers":<span class="cov0" title="0">
                                if h, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        headers = h
                                }</span>
                        case "body", "data", "payload":<span class="cov8" title="1">
                                body = val</span>
                        case "timeout":<span class="cov0" title="0">
                                if t, err := coerce.ToInt(val); err == nil </span><span class="cov0" title="0">{
                                        timeoutSeconds = t
                                }</span>
                        case "as":<span class="cov8" title="1">
                                // Handle variable assignment target
                                if str, ok := c.Value.(string); ok </span><span class="cov8" title="1">{
                                        target = strings.TrimPrefix(str, "$")
                                }</span>
                        }
                }

                // Defaults
                <span class="cov8" title="1">if url == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.request: url is required")
                }</span>
                <span class="cov8" title="1">if method == "" </span><span class="cov0" title="0">{
                        method = "GET"
                }</span>

                // 2. Prepare Request Body
                <span class="cov8" title="1">var reqBody io.Reader
                if body != nil </span><span class="cov8" title="1">{
                        // If explicitly string, send raw
                        if strBody, ok := body.(string); ok </span><span class="cov0" title="0">{
                                reqBody = bytes.NewBufferString(strBody)
                        }</span> else<span class="cov8" title="1"> {
                                // Otherwise, auto-marshal to JSON
                                jsonBytes, err := json.Marshal(body)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("http.request: failed to marshal body: %w", err)
                                }</span>
                                <span class="cov8" title="1">reqBody = bytes.NewBuffer(jsonBytes)</span>
                        }
                }

                // 3. Create Request
                <span class="cov8" title="1">req, err := http.NewRequest(method, url, reqBody)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.request: failed to create request: %w", err)
                }</span>

                // 4. Set Headers
                // Default Content-Type if body exists and not set
                <span class="cov8" title="1">if body != nil &amp;&amp; headers["Content-Type"] == nil </span><span class="cov8" title="1">{
                        req.Header.Set("Content-Type", "application/json")
                }</span>

                <span class="cov8" title="1">for k, v := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(k, coerce.ToString(v))
                }</span>

                // 5. Execute Request with Timeout
                <span class="cov8" title="1">client := &amp;http.Client{
                        Timeout: time.Duration(timeoutSeconds) * time.Second,
                }

                resp, err := client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        // Return error structure instead of hard failing?
                        // Ideally we want to let user handle connection errors too
                        // For now, let's return a structured error response in the target variable
                        // to avoid crashing the script execution flow completely.
                        /*
                                scope.Set(target, map[string]interface{}{
                                        "status": 0,
                                        "error":  err.Error(),
                                })
                                return nil
                        */
                        return fmt.Errorf("http.request: connection failed: %w", err)
                }</span>
                <span class="cov8" title="1">defer resp.Body.Close()

                // 6. Process Response
                respBodyBytes, _ := io.ReadAll(resp.Body)
                var respBody interface{}

                // Auto-parse Response JSON
                contentType := resp.Header.Get("Content-Type")
                if strings.Contains(contentType, "application/json") </span><span class="cov8" title="1">{
                        var jsonResult interface{}
                        if err := json.Unmarshal(respBodyBytes, &amp;jsonResult); err == nil </span><span class="cov8" title="1">{
                                respBody = jsonResult
                        }</span> else<span class="cov0" title="0"> {
                                respBody = string(respBodyBytes) // Fallback to string if invalid JSON
                        }</span>
                } else<span class="cov0" title="0"> {
                        respBody = string(respBodyBytes)
                }</span>

                // Convert Headers to Map
                <span class="cov8" title="1">respHeaders := make(map[string]interface{})
                for k, v := range resp.Header </span><span class="cov8" title="1">{
                        if len(v) &gt; 0 </span><span class="cov8" title="1">{
                                respHeaders[k] = v[0]
                        }</span>
                }

                // 7. Store Result
                <span class="cov8" title="1">result := map[string]interface{}{
                        "status":  resp.StatusCode,
                        "body":    respBody,
                        "headers": respHeaders,
                }

                scope.Set(target, result)
                return nil</span>

        }, engine.SlotMeta{Example: "http.request: 'https://api.com'\n  method: 'POST'\n  body: $data\n  as: $res"})
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package slots

import (
        "context"
        "fmt"
        "image"
        "image/jpeg"
        "image/png"
        "os"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
        // Library resize pihak ketiga (golang.org/x/image/draw) direkomendasikan,
        // tapi untuk "Zero-effort" start kita pakai basic logic atau library standar.
)

func RegisterImageSlots(eng *engine.Engine) <span class="cov8" title="1">{

        // IMAGE.INFO (Cek Ukuran)
        eng.Register("image.info", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                path := ""
                target := "image_info"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        // Gunakan parseNodeValue dari utils.go
                        if c.Name == "path" </span><span class="cov8" title="1">{
                                path = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                // Bersihkan awalan $ agar konsisten
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if path == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("image.info: path is required")
                }</span>

                <span class="cov8" title="1">f, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer f.Close()

                // Decode Config (Hanya header, cepat)
                cfg, _, err := image.DecodeConfig(f)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("image.info: failed to decode image: %v", err)
                }</span>

                <span class="cov8" title="1">info := map[string]interface{}{
                        "width":  cfg.Width,
                        "height": cfg.Height,
                }
                scope.Set(target, info)
                return nil</span>
        }, engine.SlotMeta{Example: "image.info\n  path: 'uploads/foto.jpg'"})

        // IMAGE.RESIZE (Simple Implementation)
        <span class="cov8" title="1">eng.Register("image.resize", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var srcPath, destPath string
                var w, h int

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "source" </span><span class="cov8" title="1">{
                                srcPath = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "dest" </span><span class="cov8" title="1">{
                                destPath = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "width" </span><span class="cov8" title="1">{
                                w, _ = coerce.ToInt(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "height" </span><span class="cov0" title="0">{
                                h, _ = coerce.ToInt(val)
                        }</span>
                }

                // [FIX] Bungkam error "declared and not used"
                // Variabel w &amp; h disiapkan untuk implementasi resize library masa depan.
                <span class="cov8" title="1">_ = w
                _ = h

                if srcPath == "" || destPath == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("image.resize: source and dest paths required")
                }</span>

                // Membuka file source
                <span class="cov8" title="1">file, err := os.Open(srcPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer file.Close()

                img, format, err := image.Decode(file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("image.resize: decode failed: %v", err)
                }</span>

                // LOGIKA RESIZE (Disederhanakan / Placeholder)
                // Saat ini hanya melakukan re-encoding (compress) tanpa resize dimensi.
                // TODO: Gunakan 'github.com/nfnt/resize' untuk menggunakan w &amp; h.

                <span class="cov8" title="1">out, err := os.Create(destPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer out.Close()

                if format == "png" </span><span class="cov8" title="1">{
                        return png.Encode(out, img)
                }</span>
                // Default JPEG quality 75
                <span class="cov0" title="0">return jpeg.Encode(out, img, &amp;jpeg.Options{Quality: 75})</span>

        }, engine.SlotMeta{
                Description: "Mengubah ukuran atau format gambar (Placeholder implementasi).",
                Example: `image.resize
  source: "input.jpg"
  dest: "output_thumb.jpg"
  width: 100`,
        })
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package slots

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

// RegisterInertiaSlots registers Inertia.js related slots
func RegisterInertiaSlots(eng *engine.Engine) <span class="cov8" title="1">{
        // inertia.render - Main slot for rendering Inertia responses
        eng.Register("inertia.render", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var component string
                var props map[string]interface{}

                // Parse parameters
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "component" </span><span class="cov8" title="1">{
                                component = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "props" </span><span class="cov8" title="1">{
                                propsVal := parseNodeValue(c, scope)
                                if propsMap, ok := propsVal.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        props = propsMap
                                }</span>
                        }
                }

                <span class="cov8" title="1">if component == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("inertia.render: component is required")
                }</span>

                // Get HTTP context
                <span class="cov8" title="1">w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("inertia.render: http writer not found in context")
                }</span>

                <span class="cov8" title="1">r, ok := ctx.Value("httpRequest").(*http.Request)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("inertia.render: http request not found in context")
                }</span>

                // Get shared data from scope
                <span class="cov8" title="1">sharedData := make(map[string]interface{})

                // Add auth if available
                if auth, ok := scope.Get("auth"); ok &amp;&amp; auth != nil </span><span class="cov0" title="0">{
                        sharedData["auth"] = auth
                }</span>

                // Add flash messages if available
                <span class="cov8" title="1">if flash, ok := scope.Get("flash"); ok &amp;&amp; flash != nil </span><span class="cov0" title="0">{
                        sharedData["flash"] = flash
                }</span>

                // Add errors if available
                <span class="cov8" title="1">if errors, ok := scope.Get("errors"); ok &amp;&amp; errors != nil </span><span class="cov0" title="0">{
                        sharedData["errors"] = errors
                }</span>

                // Merge shared data with props
                <span class="cov8" title="1">if props == nil </span><span class="cov0" title="0">{
                        props = make(map[string]interface{})
                }</span>
                <span class="cov8" title="1">for k, v := range sharedData </span><span class="cov0" title="0">{
                        if _, exists := props[k]; !exists </span><span class="cov0" title="0">{
                                props[k] = v
                        }</span>
                }

                // Build Inertia page object
                <span class="cov8" title="1">page := map[string]interface{}{
                        "component": component,
                        "props":     props,
                        "url":       r.URL.Path,
                        "version":   "1", // TODO: Make this configurable
                }

                // Check if this is an Inertia request
                isInertia := r.Header.Get("X-Inertia") == "true"

                if isInertia </span><span class="cov8" title="1">{
                        // Return JSON for Inertia requests
                        w.Header().Set("Content-Type", "application/json")
                        w.Header().Set("X-Inertia", "true")
                        w.Header().Set("Vary", "Accept")

                        return json.NewEncoder(w).Encode(page)
                }</span>

                // Return HTML for initial page load
                <span class="cov8" title="1">pageJSON, err := json.Marshal(page)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("inertia.render: failed to marshal page data: %v", err)
                }</span>

                <span class="cov8" title="1">html := fmt.Sprintf(`&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;title&gt;Inertia App&lt;/title&gt;
    &lt;link rel="stylesheet" href="/inertia/dist/assets/app.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app" data-page='%s'&gt;&lt;/div&gt;
    &lt;script type="module" src="/inertia/dist/assets/app.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`, string(pageJSON))

                w.Header().Set("Content-Type", "text/html; charset=utf-8")
                w.Write([]byte(html))

                return nil</span>
        }, engine.SlotMeta{
                Description: "Render Inertia.js response",
                Example:     "inertia.render:\n  component: \"Dashboard\"\n  props: { user: $user }",
        })

        // inertia.share - Share data across all Inertia requests
        <span class="cov8" title="1">eng.Register("inertia.share", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // Parse key-value pairs
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name != "do" </span><span class="cov8" title="1">{
                                value := parseNodeValue(c, scope)
                                scope.Set(c.Name, value)
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Share data across all Inertia requests",
                Example:     "inertia.share:\n  auth: $auth\n  flash: $flash",
        })

        // inertia.location - Force a full page reload to a URL
        <span class="cov8" title="1">eng.Register("inertia.location", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var url string

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "url" </span><span class="cov8" title="1">{
                                url = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                <span class="cov8" title="1">if url == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("inertia.location: url is required")
                }</span>

                <span class="cov8" title="1">w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("inertia.location: http writer not found in context")
                }</span>

                <span class="cov8" title="1">w.Header().Set("X-Inertia-Location", url)
                w.WriteHeader(http.StatusConflict)

                return nil</span>
        }, engine.SlotMeta{
                Description: "Force a full page reload to a URL",
                Example:     "inertia.location:\n  url: \"/login\"",
        })
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package slots

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"

        "zeno/pkg/worker"
)

func RegisterJobSlots(eng *engine.Engine, queue worker.JobQueue, setConfig func([]string)) <span class="cov8" title="1">{

        // WORKER.CONFIG
        eng.Register("worker.config", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                if setConfig == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">var queues []string
                if node.Value != nil </span><span class="cov0" title="0">{
                        val := coerce.ToString(node.Value)
                        if val != "" </span><span class="cov0" title="0">{
                                parts := strings.Split(val, ",")
                                for _, p := range parts </span><span class="cov0" title="0">{
                                        queues = append(queues, strings.TrimSpace(p))
                                }</span>
                        }
                }

                // Handle array children if present or comma separated string?
                // Let's support simple array of strings as children or single string value.
                <span class="cov0" title="0">for _, c := range node.Children </span><span class="cov0" title="0">{
                        v := coerce.ToString(parseNodeValue(c, scope))
                        if v == "" &amp;&amp; c.Name != "" </span><span class="cov0" title="0">{
                                v = c.Name
                        }</span>
                        <span class="cov0" title="0">if v != "" </span><span class="cov0" title="0">{
                                queues = append(queues, v)
                        }</span>
                }

                <span class="cov0" title="0">if len(queues) &gt; 0 </span><span class="cov0" title="0">{
                        setConfig(queues)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Configure worker queues.",
                Example: `worker.config
  - "high_priority"
  - "default"`,
        })

        // JOB.ENQUEUE
        <span class="cov8" title="1">eng.Register("job.enqueue", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // [SAFETY] Cek Queue
                if queue == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("job.enqueue failed: Queue is not available")
                }</span>

                <span class="cov8" title="1">var queueName string = "default"
                var payload interface{}

                // Support shorthand: job.enqueue: "email_queue"
                if node.Value != nil &amp;&amp; fmt.Sprintf("%v", node.Value) != "" </span><span class="cov0" title="0">{
                        queueName = coerce.ToString(node.Value)
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "queue" </span><span class="cov8" title="1">{
                                queueName = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "payload" </span><span class="cov8" title="1">{
                                // Payload bisa map kompleks, gunakan parseNodeValue
                                payload = parseNodeValue(c, scope)
                        }</span>
                }

                <span class="cov8" title="1">if payload == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("job.enqueue: payload is required")
                }</span>

                // Marshal payload ke JSON string untuk disimpan di Redis List
                <span class="cov8" title="1">jsonBytes, err := json.Marshal(payload)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("job.enqueue: failed to marshal payload: %v", err)
                }</span>

                // Push ke Queue
                <span class="cov8" title="1">err = queue.Push(ctx, queueName, jsonBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Add a job to the background queue (Redis/DB).",
                Example: `job.enqueue
  queue: "emails"
  payload:
    to: "budi@example.com"
    subject: "Welcome"`,
        })
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package slots

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

func RegisterJSONSlots(eng *engine.Engine) <span class="cov8" title="1">{

        // 1. JSON.PARSE
        eng.Register("json.parse", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var jsonStr string
                target := "json_result"

                if node.Value != nil </span><span class="cov8" title="1">{
                        jsonStr = coerce.ToString(resolveValue(node.Value, scope))
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "val" </span><span class="cov0" title="0">{
                                jsonStr = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if jsonStr == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("json.parse: input value is empty")
                }</span>

                <span class="cov8" title="1">var result interface{}
                err := json.Unmarshal([]byte(jsonStr), &amp;result)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("json.parse: invalid json format: %v", err)
                }</span>

                <span class="cov8" title="1">scope.Set(target, result)
                return nil</span>
        }, engine.SlotMeta{Example: "json.parse: $response_body\n  as: $data"})

        // 2. JSON.STRINGIFY
        <span class="cov8" title="1">eng.Register("json.stringify", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var input interface{}
                target := "json_string"

                if node.Value != nil </span><span class="cov8" title="1">{
                        input = resolveValue(node.Value, scope)
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "val" </span><span class="cov0" title="0">{
                                input = parseNodeValue(c, scope)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">bytes, err := json.Marshal(input)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("json.stringify: failed to marshal: %v", err)
                }</span>

                <span class="cov8" title="1">scope.Set(target, string(bytes))
                return nil</span>
        }, engine.SlotMeta{Example: "json.stringify: $data\n  as: $json_str"})
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package slots

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "os"
        "strconv"
        "strings"
        "time"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"

        "github.com/golang-jwt/jwt/v5"
)

var (
        ErrBreak    = errors.New("break")
        ErrContinue = errors.New("continue")
        ErrReturn   = errors.New("return")
)

func RegisterLogicSlots(eng *engine.Engine) <span class="cov8" title="1">{
        // ==========================================
        // SLOT: RETURN / STOP
        // ==========================================
        eng.Register("return", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                return ErrReturn
        }</span>, engine.SlotMeta{Description: "Halt execution of the current block/handler."})

        // ==========================================
        // SLOT: SCOPE SET (Legacy alias for 'var')
        // ==========================================
        <span class="cov8" title="1">eng.Register("scope.set", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var key string
                var val interface{}

                // Support Shorthand: scope.set: $nama_var
                if node.Value != nil </span><span class="cov8" title="1">{
                        raw := coerce.ToString(node.Value)
                        key = strings.TrimPrefix(raw, "$")
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "key" || c.Name == "name" </span><span class="cov0" title="0">{
                                raw := coerce.ToString(c.Value)
                                key = strings.TrimPrefix(raw, "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "val" || c.Name == "value" </span><span class="cov8" title="1">{
                                // First parse the node value
                                parsedVal := parseNodeValue(c, scope)

                                // Check if it's still a variable reference that needs resolution
                                valStr := fmt.Sprintf("%v", parsedVal)
                                if strings.HasPrefix(valStr, "$") </span><span class="cov0" title="0">{
                                        // Recursively resolve the variable
                                        resolvedVal := valStr
                                        maxDepth := 10
                                        depth := 0

                                        for depth &lt; maxDepth &amp;&amp; strings.HasPrefix(resolvedVal, "$") </span><span class="cov0" title="0">{
                                                varName := strings.TrimPrefix(resolvedVal, "$")

                                                // Handle dot notation (e.g., tenants.0.db_connection_name)
                                                if strings.Contains(varName, ".") </span><span class="cov0" title="0">{
                                                        parts := strings.Split(varName, ".")
                                                        rootKey := parts[0]

                                                        if rootVal, ok := scope.Get(rootKey); ok </span><span class="cov0" title="0">{
                                                                // Navigate through the path
                                                                curr := rootVal
                                                                for j := 1; j &lt; len(parts); j++ </span><span class="cov0" title="0">{
                                                                        targetKey := parts[j]

                                                                        // Handle maps
                                                                        if m, ok := curr.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                                                if v, exists := m[targetKey]; exists </span><span class="cov0" title="0">{
                                                                                        curr = v
                                                                                        continue</span>
                                                                                }
                                                                        }

                                                                        // Handle arrays/slices with numeric index
                                                                        <span class="cov0" title="0">if list, err := coerce.ToSlice(curr); err == nil </span><span class="cov0" title="0">{
                                                                                if idx, err := coerce.ToInt(targetKey); err == nil </span><span class="cov0" title="0">{
                                                                                        if idx &gt;= 0 &amp;&amp; idx &lt; len(list) </span><span class="cov0" title="0">{
                                                                                                curr = list[idx]
                                                                                                continue</span>
                                                                                        }
                                                                                }
                                                                        }

                                                                        // Not found
                                                                        <span class="cov0" title="0">curr = nil
                                                                        break</span>
                                                                }

                                                                <span class="cov0" title="0">if curr != nil </span><span class="cov0" title="0">{
                                                                        // Check if result is still a variable reference
                                                                        currStr := fmt.Sprintf("%v", curr)
                                                                        if strings.HasPrefix(currStr, "$") </span><span class="cov0" title="0">{
                                                                                resolvedVal = currStr
                                                                                depth++
                                                                                continue</span>
                                                                        } else<span class="cov0" title="0"> {
                                                                                // Final value
                                                                                val = curr
                                                                                break</span>
                                                                        }
                                                                } else<span class="cov0" title="0"> {
                                                                        val = nil
                                                                        break</span>
                                                                }
                                                        } else<span class="cov0" title="0"> {
                                                                val = nil
                                                                break</span>
                                                        }
                                                } else<span class="cov0" title="0"> {
                                                        // Simple variable
                                                        if v, ok := scope.Get(varName); ok </span><span class="cov0" title="0">{
                                                                vStr := fmt.Sprintf("%v", v)
                                                                if strings.HasPrefix(vStr, "$") </span><span class="cov0" title="0">{
                                                                        resolvedVal = vStr
                                                                        depth++
                                                                        continue</span>
                                                                } else<span class="cov0" title="0"> {
                                                                        val = v
                                                                        break</span>
                                                                }
                                                        } else<span class="cov0" title="0"> {
                                                                val = nil
                                                                break</span>
                                                        }
                                                }
                                        }

                                        <span class="cov0" title="0">if depth &gt;= maxDepth </span><span class="cov0" title="0">{
                                                val = nil
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        // Not a variable reference, use parsed value as-is
                                        val = parsedVal
                                }</span>
                        }
                }

                <span class="cov8" title="1">if key != "" </span><span class="cov8" title="1">{
                        scope.Set(key, val)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Create a variable (Legacy alias for 'var').",
                Example:     "scope.set: $my_var\n  val: 123",
                Inputs: map[string]engine.InputMeta{
                        "key":   {Description: "Variable name", Required: false, Type: "string"},
                        "name":  {Description: "Variable name (alias for key)", Required: false, Type: "string"},
                        "val":   {Description: "Variable value", Required: false, Type: "any"},
                        "value": {Description: "Variable value (alias for val)", Required: false, Type: "any"},
                },
        })

        // ==========================================
        // SLOT: LOGIC.COMPARE
        // ==========================================
        <span class="cov8" title="1">eng.Register("logic.compare", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var v1, v2 interface{}
                var op string
                target := "compare_result"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "v1" </span><span class="cov8" title="1">{
                                v1 = val
                        }</span>
                        <span class="cov8" title="1">if c.Name == "v2" </span><span class="cov8" title="1">{
                                v2 = val
                        }</span>
                        <span class="cov8" title="1">if c.Name == "op" </span><span class="cov8" title="1">{
                                op = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">res := false
                f1, err1 := coerce.ToFloat64(v1)
                f2, err2 := coerce.ToFloat64(v2)

                if err1 == nil &amp;&amp; err2 == nil </span><span class="cov8" title="1">{
                        switch op </span>{
                        case "==":<span class="cov0" title="0">
                                res = (f1 == f2)</span>
                        case "!=":<span class="cov0" title="0">
                                res = (f1 != f2)</span>
                        case "&gt;":<span class="cov8" title="1">
                                res = (f1 &gt; f2)</span>
                        case "&lt;":<span class="cov0" title="0">
                                res = (f1 &lt; f2)</span>
                        case "&gt;=":<span class="cov0" title="0">
                                res = (f1 &gt;= f2)</span>
                        case "&lt;=":<span class="cov0" title="0">
                                res = (f1 &lt;= f2)</span>
                        }
                } else<span class="cov0" title="0"> {
                        s1 := coerce.ToString(v1)
                        s2 := coerce.ToString(v2)
                        switch op </span>{
                        case "==":<span class="cov0" title="0">
                                res = (s1 == s2)</span>
                        case "!=":<span class="cov0" title="0">
                                res = (s1 != s2)</span>
                        }
                }

                <span class="cov8" title="1">scope.Set(target, res)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Compare two values.",
                Example:     "logic.compare\n  v1: $age\n  op: '&gt;'\n  v2: 17",
                Inputs: map[string]engine.InputMeta{
                        "v1": {Description: "First value", Required: true, Type: "any"},
                        "v2": {Description: "Second value", Required: true, Type: "any"},
                        "op": {Description: "Comparison operator", Required: true, Type: "string"},
                        "as": {Description: "Variable to store result (Default: compare_result)", Required: false, Type: "string"},
                },
        })

        // ==========================================
        // SLOT: TRY / CATCH
        // ==========================================
        <span class="cov8" title="1">eng.Register("try", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var doNode, catchNode *engine.Node
                errVar := "error"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "do" </span><span class="cov8" title="1">{
                                doNode = c
                        }</span>
                        <span class="cov8" title="1">if c.Name == "catch" </span><span class="cov8" title="1">{
                                catchNode = c
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov0" title="0">{
                                errVar = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if doNode != nil </span><span class="cov8" title="1">{
                        for _, child := range doNode.Children </span><span class="cov8" title="1">{
                                if err := eng.Execute(ctx, child, scope); err != nil </span><span class="cov8" title="1">{
                                        // DON'T catch control flow errors (return, break, continue)
                                        if errors.Is(err, ErrReturn) || errors.Is(err, ErrBreak) || errors.Is(err, ErrContinue) </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">if catchNode != nil </span><span class="cov8" title="1">{
                                                scope.Set(errVar, err.Error())
                                                return eng.Execute(ctx, catchNode, scope)
                                        }</span>
                                        <span class="cov0" title="0">return err</span>
                                }
                        }
                }
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Handle errors using a try-catch block.",
                Example:     "try {\n  do: { ... }\n  catch: { ... }\n}",
                Inputs: map[string]engine.InputMeta{
                        "as":    {Description: "Variable name for error message (Default: 'error')", Required: false},
                        "do":    {Description: "Main code block to execute", Required: false},
                        "catch": {Description: "Error handling code block", Required: false},
                },
        })

        // ==========================================
        // SLOT: FOR LOOP
        // ==========================================
        // ==========================================
        <span class="cov8" title="1">handlerFor := func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var raw interface{}
                valStr, _ := node.Value.(string)
                if strings.Count(valStr, ";") == 2 </span><span class="cov8" title="1">{
                        raw = valStr
                }</span> else<span class="cov8" title="1"> {
                        raw = resolveValue(node.Value, scope)
                }</span>
                <span class="cov8" title="1">rawStr := coerce.ToString(raw)

                var doNode *engine.Node
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "do" </span><span class="cov8" title="1">{
                                doNode = c
                                break</span>
                        }
                }

                // A. C-Style For Loop (e.g. "$i = 0; $i &lt; 10; $i++")
                <span class="cov8" title="1">if strings.Count(rawStr, ";") == 2 </span><span class="cov8" title="1">{
                        parts := strings.Split(rawStr, ";")
                        initStr := strings.TrimSpace(parts[0])
                        condStr := strings.TrimSpace(parts[1])
                        updStr := strings.TrimSpace(parts[2])

                        // 1. INIT
                        var loopVar string
                        if strings.Contains(initStr, "=") </span><span class="cov8" title="1">{
                                initParts := strings.SplitN(initStr, "=", 2)
                                loopVar = strings.TrimPrefix(strings.TrimSpace(initParts[0]), "$")
                                initVal, _ := strconv.Atoi(strings.TrimSpace(initParts[1]))
                                scope.Set(loopVar, initVal)
                        }</span>

                        // LOOP
                        <span class="cov8" title="1">if doNode != nil </span><span class="cov8" title="1">{
                                maxLoop := 10000
                                for i := 0; i &lt; maxLoop; i++ </span><span class="cov8" title="1">{
                                        // Check context cancellation/timeout every iteration
                                        select </span>{
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return fmt.Errorf("for loop cancelled: %v", ctx.Err())</span>
                                        default:<span class="cov8" title="1"></span>
                                        }

                                        // 2. CONDITION
                                        <span class="cov8" title="1">if !evalSimpleCondition(condStr, scope) </span><span class="cov8" title="1">{
                                                break</span>
                                        }

                                        // DO BODY
                                        <span class="cov8" title="1">if err := eng.Execute(ctx, doNode, scope); err != nil </span><span class="cov8" title="1">{
                                                if errors.Is(err, ErrBreak) || strings.Contains(err.Error(), "break") </span><span class="cov8" title="1">{
                                                        return nil
                                                }</span>
                                                <span class="cov0" title="0">if errors.Is(err, ErrContinue) || strings.Contains(err.Error(), "continue") </span><span class="cov0" title="0">{
                                                        goto Update</span>
                                                }
                                                <span class="cov0" title="0">return err</span>
                                        }

                                Update:
                                        // 3. UPDATE
                                        <span class="cov8" title="1">if strings.Contains(updStr, "++") </span><span class="cov8" title="1">{
                                                vRaw, _ := scope.Get(loopVar)
                                                vInt, _ := coerce.ToInt(vRaw)
                                                scope.Set(loopVar, vInt+1)
                                        }</span> else<span class="cov0" title="0"> if strings.Contains(updStr, "--") </span><span class="cov0" title="0">{
                                                vRaw, _ := scope.Get(loopVar)
                                                vInt, _ := coerce.ToInt(vRaw)
                                                scope.Set(loopVar, vInt-1)
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">return nil</span>
                }

                // B. Foreach Loop
                <span class="cov8" title="1">sourceList, err := coerce.ToSlice(raw)
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Empty loop if data invalid
                }</span>

                <span class="cov8" title="1">var itemName string = "item"
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                itemName = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if doNode != nil </span><span class="cov8" title="1">{
                        count := len(sourceList)
                        parentLoop, hasParentLoop := scope.Get("loop")

                        for i, item := range sourceList </span><span class="cov8" title="1">{
                                scope.Set(itemName, item)
                                loopData := map[string]interface{}{
                                        "index":     i,
                                        "iteration": i + 1,
                                        "remaining": count - (i + 1),
                                        "count":     count,
                                        "first":     (i == 0),
                                        "last":      (i == count-1),
                                        "even":      ((i+1)%2 == 0),
                                        "odd":       ((i+1)%2 != 0),
                                }
                                if hasParentLoop </span><span class="cov0" title="0">{
                                        loopData["parent"] = parentLoop
                                }</span>
                                <span class="cov8" title="1">scope.Set("loop", loopData)

                                if err := eng.Execute(ctx, doNode, scope); err != nil </span><span class="cov8" title="1">{
                                        if errors.Is(err, ErrBreak) || strings.Contains(err.Error(), "break") </span><span class="cov0" title="0">{
                                                goto EndForeach</span>
                                        }
                                        <span class="cov8" title="1">if errors.Is(err, ErrContinue) || strings.Contains(err.Error(), "continue") </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">return err</span>
                                }
                        }
                EndForeach:
                        <span class="cov8" title="1">if hasParentLoop </span><span class="cov0" title="0">{
                                scope.Set("loop", parentLoop)
                        }</span> else<span class="cov8" title="1"> {
                                scope.Set("loop", nil)
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">eng.Register("for", handlerFor, engine.SlotMeta{
                Description: "Iterate (loop) over a list or array.",
                Example:     "for: $list\n  as: $item\n  do: ...",
                Inputs: map[string]engine.InputMeta{
                        "as":             {Description: "Variable name for current element (Default: 'item')", Required: false},
                        "do":             {Description: "Code block to repeat", Required: false},
                        "__native_write": {Description: "Internal Blade attribute", Required: false},
                },
                RequiredBlocks: []string{"do"},
        })
        eng.Register("foreach", handlerFor, engine.SlotMeta{
                Example: "foreach: $list { as: $item ... }",
                Inputs: map[string]engine.InputMeta{
                        "as":             {Description: "Variable name for current element (Default: 'item')", Required: false},
                        "do":             {Description: "Code block to repeat", Required: false},
                        "__native_write": {Description: "Internal Blade attribute", Required: false},
                },
        }) // Alias

        // ==========================================
        // SLOT: CTX TIMEOUT
        // ==========================================
        eng.Register("ctx.timeout", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                var durationStr string
                var doNode *engine.Node

                // Get duration from main value (ctx.timeout: "5s")
                if node.Value != nil </span><span class="cov0" title="0">{
                        durationStr = coerce.ToString(resolveValue(node.Value, scope))
                }</span>

                <span class="cov0" title="0">for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "duration" </span><span class="cov0" title="0">{
                                durationStr = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "do" </span><span class="cov0" title="0">{
                                doNode = c
                        }</span>
                }

                <span class="cov0" title="0">if durationStr == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("ctx.timeout: duration is required")
                }</span>

                <span class="cov0" title="0">duration, err := time.ParseDuration(durationStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ctx.timeout: invalid duration '%s'", durationStr)
                }</span>

                <span class="cov0" title="0">timeoutCtx, cancel := context.WithTimeout(ctx, duration)
                defer cancel()

                if doNode != nil </span><span class="cov0" title="0">{
                        for _, child := range doNode.Children </span><span class="cov0" title="0">{
                                if err := eng.Execute(timeoutCtx, child, scope); err != nil </span><span class="cov0" title="0">{
                                        if timeoutCtx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                                                return fmt.Errorf("execution timed out after %s", durationStr)
                                        }</span>
                                        <span class="cov0" title="0">return err</span>
                                }
                        }
                }
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Limit execution time of a code block.",
                Example:     "ctx.timeout: '5s' {\n  do: { ... }\n}",
                Inputs: map[string]engine.InputMeta{
                        "duration": {Description: "Timeout duration (e.g., '5s', '1m')", Required: false},
                        "do":       {Description: "Code block to execute", Required: false},
                },
        })

        // ==========================================
        // SLOT: WHILE LOOP / LOOP
        // ==========================================
        <span class="cov8" title="1">handlerWhile := func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                condRaw := coerce.ToString(node.Value)
                maxLoop := 10000

                for i := 0; i &lt; maxLoop; i++ </span><span class="cov0" title="0">{
                        // Check context cancellation/timeout every iteration
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return fmt.Errorf("while loop cancelled: %v", ctx.Err())</span>
                        default:<span class="cov0" title="0"></span>
                        }

                        <span class="cov0" title="0">if !evalSimpleCondition(condRaw, scope) </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // Find 'do' block or use the node itself if it has no 'do' child but has children
                        <span class="cov0" title="0">var childrenToExec []*engine.Node
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "do" </span><span class="cov0" title="0">{
                                        childrenToExec = c.Children
                                        break</span>
                                }
                        }

                        // Fallback: execute all children if no 'do' block found
                        <span class="cov0" title="0">if childrenToExec == nil </span><span class="cov0" title="0">{
                                childrenToExec = node.Children
                        }</span>

                        <span class="cov0" title="0">for _, child := range childrenToExec </span><span class="cov0" title="0">{
                                if err := eng.Execute(ctx, child, scope); err != nil </span><span class="cov0" title="0">{
                                        if errors.Is(err, ErrBreak) || strings.Contains(err.Error(), "break") </span><span class="cov0" title="0">{
                                                goto EndWhile</span>
                                        }
                                        <span class="cov0" title="0">if errors.Is(err, ErrContinue) || strings.Contains(err.Error(), "continue") </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                        <span class="cov0" title="0">return err</span>
                                }
                        }
                }
        EndWhile:
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">eng.Register("while", handlerWhile, engine.SlotMeta{
                Description:    "While loop",
                RequiredBlocks: []string{"do"},
                Inputs: map[string]engine.InputMeta{
                        "do": {Description: "Code block to execute"},
                },
        })
        eng.Register("loop", handlerWhile, engine.SlotMeta{
                Description:    "While loop",
                RequiredBlocks: []string{"do"},
                Inputs: map[string]engine.InputMeta{
                        "do": {Description: "Code block to execute"},
                },
        })

        // ==========================================
        // SLOT: BREAK &amp; CONTINUE (Support Conditional: break: $i == 5)
        // ==========================================
        eng.Register("break", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                if node.Value != nil </span><span class="cov8" title="1">{
                        expr := coerce.ToString(node.Value)
                        if !evalSimpleCondition(expr, scope) </span><span class="cov8" title="1">{
                                return nil // Don't break if condition not met
                        }</span>
                }
                <span class="cov8" title="1">return ErrBreak</span>
        }, engine.SlotMeta{Description: "Force stop. Supports conditional: `break: $i == 5`"})

        <span class="cov8" title="1">eng.Register("continue", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                if node.Value != nil </span><span class="cov0" title="0">{
                        expr := coerce.ToString(node.Value)
                        if !evalSimpleCondition(expr, scope) </span><span class="cov0" title="0">{
                                return nil // Don't continue if condition not met
                        }</span>
                }
                <span class="cov8" title="1">return ErrContinue</span>
        }, engine.SlotMeta{Description: "Continue to next iteration. Supports conditional: `continue: $i % 2 == 0`"})

        // ==========================================
        // SLOT: DD &amp; DUMP (Laravel Style)
        // ==========================================
        <span class="cov8" title="1">eng.Register("dump", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                val := resolveValue(node.Value, scope)
                fmt.Printf("[DUMP]: %+v (Type: %T)\n", val, val)
                return nil
        }</span>, engine.SlotMeta{Description: "Dump variable to console without stopping execution."})

        <span class="cov8" title="1">eng.Register("dd", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                val := resolveValue(node.Value, scope)
                fmt.Printf("[DD]: %+v (Type: %T)\n", val, val)
                return fmt.Errorf("DD HALT: execution stopped by dd")
        }</span>, engine.SlotMeta{Description: "Dump and Die. Display variable content and stop script immediately."})

        // ==========================================
        // SLOT: SWITCH
        // ==========================================
        <span class="cov8" title="1">eng.Register("switch", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                val := resolveValue(node.Value, scope)

                for _, child := range node.Children </span><span class="cov8" title="1">{
                        if child.Name == "case" </span><span class="cov8" title="1">{
                                caseVal := resolveValue(child.Value, scope)
                                if val == caseVal </span><span class="cov8" title="1">{
                                        err := eng.Execute(ctx, child, scope)
                                        if err != nil &amp;&amp; (errors.Is(err, ErrBreak) || strings.Contains(err.Error(), "break")) </span><span class="cov8" title="1">{
                                                return nil
                                        }</span>
                                        <span class="cov8" title="1">return err</span>
                                }
                        } else<span class="cov8" title="1"> if child.Name == "default" </span><span class="cov8" title="1">{
                                err := eng.Execute(ctx, child, scope)
                                if err != nil &amp;&amp; (errors.Is(err, ErrBreak) || strings.Contains(err.Error(), "break")) </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov8" title="1">return err</span>
                        }
                }
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Conditional branching (Switch Case).",
                Inputs: map[string]engine.InputMeta{
                        "case":    {Description: "Case value to check"},
                        "default": {Description: "Default block if no case matches"},
                },
        })

        // ==========================================
        // SLOT: ISSET, EMPTY, UNLESS
        // ==========================================
        <span class="cov8" title="1">eng.Register("isset", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                val := resolveValue(node.Value, scope)
                if val != nil </span><span class="cov8" title="1">{
                        for _, child := range node.Children </span><span class="cov8" title="1">{
                                if child.Name == "do" </span><span class="cov8" title="1">{
                                        return eng.Execute(ctx, child, scope)
                                }</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Execute block if variable is set/defined.",
                Inputs: map[string]engine.InputMeta{
                        "do": {Description: "Code block to execute"},
                },
        })

        <span class="cov8" title="1">eng.Register("empty", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                val := resolveValue(node.Value, scope)
                isEmpty := false
                if val == nil </span><span class="cov0" title="0">{
                        isEmpty = true
                }</span> else<span class="cov8" title="1"> {
                        str := coerce.ToString(val)
                        if str == "" </span><span class="cov0" title="0">{
                                isEmpty = true
                        }</span> else<span class="cov8" title="1"> {
                                switch v := val.(type) </span>{
                                case []interface{}:<span class="cov0" title="0">
                                        isEmpty = len(v) == 0</span>
                                case []string:<span class="cov8" title="1">
                                        isEmpty = len(v) == 0</span>
                                case map[string]interface{}:<span class="cov0" title="0">
                                        isEmpty = len(v) == 0</span>
                                }
                        }
                }

                <span class="cov8" title="1">if isEmpty </span><span class="cov8" title="1">{
                        for _, child := range node.Children </span><span class="cov8" title="1">{
                                if child.Name == "do" </span><span class="cov8" title="1">{
                                        return eng.Execute(ctx, child, scope)
                                }</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Execute block if variable is empty (null, '', or empty array).",
                Inputs: map[string]engine.InputMeta{
                        "do": {Description: "Code block to execute"},
                },
        })

        <span class="cov8" title="1">eng.Register("unless", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                val := resolveValue(node.Value, scope)
                boolVal, _ := coerce.ToBool(val)
                if !boolVal </span><span class="cov8" title="1">{
                        for _, child := range node.Children </span><span class="cov8" title="1">{
                                if child.Name == "do" </span><span class="cov8" title="1">{
                                        return eng.Execute(ctx, child, scope)
                                }</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Reverse of IF. Execute block if condition is FALSE.",
                Inputs: map[string]engine.InputMeta{
                        "do": {Description: "Code block to execute"},
                },
        })

        // ==========================================
        // SLOT: AUTH &amp; GUEST (Check Login)
        // ==========================================
        <span class="cov8" title="1">eng.Register("auth", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                user, found := scope.Get("user")
                isAuth := found &amp;&amp; user != nil
                if !isAuth </span><span class="cov8" title="1">{
                        authObjRaw, foundAuth := scope.Get("auth")
                        if foundAuth &amp;&amp; authObjRaw != nil </span><span class="cov0" title="0">{
                                isAuth = true
                        }</span>
                }

                <span class="cov8" title="1">if isAuth </span><span class="cov8" title="1">{
                        for _, child := range node.Children </span><span class="cov8" title="1">{
                                if child.Name == "do" </span><span class="cov8" title="1">{
                                        return eng.Execute(ctx, child, scope)
                                }</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Execute block if user is logged in.",
                Inputs: map[string]engine.InputMeta{
                        "do": {Description: "Code block to execute"},
                },
        })

        <span class="cov8" title="1">eng.Register("guest", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                user, found := scope.Get("user")
                isAuth := found &amp;&amp; user != nil
                if !isAuth </span><span class="cov8" title="1">{
                        authObjRaw, foundAuth := scope.Get("auth")
                        if foundAuth &amp;&amp; authObjRaw != nil </span><span class="cov0" title="0">{
                                isAuth = true
                        }</span>
                }

                <span class="cov8" title="1">if !isAuth </span><span class="cov8" title="1">{
                        for _, child := range node.Children </span><span class="cov8" title="1">{
                                if child.Name == "do" </span><span class="cov8" title="1">{
                                        return eng.Execute(ctx, child, scope)
                                }</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Execute block if user is NOT logged in (guest).",
                Inputs: map[string]engine.InputMeta{
                        "do": {Description: "Code block to execute"},
                },
        })

        <span class="cov8" title="1">eng.Register("auth.user", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                target := "user"
                if node.Value != nil </span><span class="cov0" title="0">{
                        target = strings.TrimPrefix(coerce.ToString(node.Value), "$")
                }</span>
                <span class="cov0" title="0">for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }
                <span class="cov0" title="0">user, found := scope.Get("user")
                if !found || user == nil </span><span class="cov0" title="0">{
                        authObj, ok := scope.Get("auth")
                        if ok &amp;&amp; authObj != nil </span><span class="cov0" title="0">{
                                user = authObj
                        }</span>
                }
                <span class="cov0" title="0">scope.Set(target, user)
                return nil</span>
        }, engine.SlotMeta{Description: "Retrieve current logged-in user data."})

        <span class="cov8" title="1">eng.Register("auth.check", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                target := "is_auth"
                if node.Value != nil </span><span class="cov0" title="0">{
                        target = strings.TrimPrefix(coerce.ToString(node.Value), "$")
                }</span>
                <span class="cov0" title="0">for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }
                <span class="cov0" title="0">user, found := scope.Get("user")
                isAuth := found &amp;&amp; user != nil
                if !isAuth </span><span class="cov0" title="0">{
                        authObj, ok := scope.Get("auth")
                        isAuth = ok &amp;&amp; authObj != nil
                }</span>

                // Fallback: Check and VERIFY cookies if not in scope
                <span class="cov0" title="0">if !isAuth </span><span class="cov0" title="0">{
                        reqVal := ctx.Value("httpRequest")
                        if req, ok := reqVal.(*http.Request); ok </span><span class="cov0" title="0">{
                                var tokenString string
                                if cookie, err := req.Cookie("auth_token"); err == nil </span><span class="cov0" title="0">{
                                        tokenString = cookie.Value
                                }</span> else<span class="cov0" title="0"> if cookie, err := req.Cookie("token"); err == nil </span><span class="cov0" title="0">{
                                        tokenString = cookie.Value
                                }</span>

                                // VERIFY the token, not just check existence
                                <span class="cov0" title="0">if tokenString != "" </span><span class="cov0" title="0">{
                                        jwtSecret := os.Getenv("JWT_SECRET")
                                        if jwtSecret == "" </span><span class="cov0" title="0">{
                                                jwtSecret = "ZENOLANG_DEMO_SECRET_KEY_2026"
                                        }</span>

                                        <span class="cov0" title="0">token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                                                return []byte(jwtSecret), nil
                                        }</span>)

                                        // Only set isAuth to true if token is VALID
                                        <span class="cov0" title="0">if err == nil &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                                                isAuth = true
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">scope.Set(target, isAuth)
                return nil</span>
        }, engine.SlotMeta{Description: "Check if user is logged in (returns boolean)."})

        // ==========================================
        // SLOT: CAN &amp; CANNOT (RBAC)
        // ==========================================
        <span class="cov8" title="1">eng.Register("can", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                ability := coerce.ToString(node.Value)
                canFunc, ok := scope.Get("can")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">var resource interface{}
                for _, child := range node.Children </span><span class="cov8" title="1">{
                        if child.Name == "resource" </span><span class="cov8" title="1">{
                                varName := strings.TrimPrefix(coerce.ToString(child.Value), "$")
                                resource, _ = scope.Get(varName)
                                break</span>
                        }
                }

                <span class="cov8" title="1">callback, ok := canFunc.(func(string, interface{}) bool)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">if callback(ability, resource) </span><span class="cov8" title="1">{
                        for _, child := range node.Children </span><span class="cov8" title="1">{
                                if child.Name == "do" </span><span class="cov8" title="1">{
                                        return eng.Execute(ctx, child, scope)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Execute block if user has specific permission (ability).",
                Inputs: map[string]engine.InputMeta{
                        "resource": {Description: "Object to check permission for"},
                        "do":       {Description: "Code block to execute"},
                },
        })

        <span class="cov8" title="1">eng.Register("cannot", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                ability := coerce.ToString(node.Value)
                canFunc, ok := scope.Get("can")

                var resource interface{}
                for _, child := range node.Children </span><span class="cov8" title="1">{
                        if child.Name == "resource" </span><span class="cov8" title="1">{
                                varName := strings.TrimPrefix(coerce.ToString(child.Value), "$")
                                resource, _ = scope.Get(varName)
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                        // No callback, assume cannot
                        for _, child := range node.Children </span><span class="cov0" title="0">{
                                if child.Name == "do" </span><span class="cov0" title="0">{
                                        return eng.Execute(ctx, child, scope)
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov8" title="1">callback, ok := canFunc.(func(string, interface{}) bool)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">if !callback(ability, resource) </span><span class="cov8" title="1">{
                        for _, child := range node.Children </span><span class="cov8" title="1">{
                                if child.Name == "do" </span><span class="cov8" title="1">{
                                        return eng.Execute(ctx, child, scope)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Menjalankan blok jika user TIDAK memiliki izin (ability).",
                Inputs: map[string]engine.InputMeta{
                        "resource": {Description: "Objek yang dicek izinnya"},
                        "do":       {Description: "Blok kode yang dijalankan"},
                },
        })

        // ==========================================
        // SLOT: JSON OUTPUT
        // ==========================================
        <span class="cov8" title="1">eng.Register("json", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                val := resolveValue(node.Value, scope)
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">bytes, err := json.Marshal(val)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
                w.Write(bytes)
                return nil</span>
        }, engine.SlotMeta{Description: "Mengeluarkan nilai sebagai JSON langsung ke HTTP response."})

        // ==========================================
        // SLOT: FORELSE
        // ==========================================
        <span class="cov8" title="1">eng.Register("forelse", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                val := resolveValue(node.Value, scope)
                list, _ := coerce.ToSlice(val)

                if len(list) == 0 </span><span class="cov8" title="1">{
                        for _, child := range node.Children </span><span class="cov8" title="1">{
                                if child.Name == "forelse_empty" </span><span class="cov8" title="1">{
                                        return eng.Execute(ctx, child, scope)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Synthesize a "for" node
                        forNode := &amp;engine.Node{Name: "for", Value: node.Value}
                        for _, child := range node.Children </span><span class="cov0" title="0">{
                                if child.Name == "as" || child.Name == "do" </span><span class="cov0" title="0">{
                                        forNode.Children = append(forNode.Children, child)
                                }</span>
                        }
                        <span class="cov0" title="0">return eng.Execute(ctx, forNode, scope)</span>
                }
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Perulangan list dengan blok cadangan jika list kosong.",
                Inputs: map[string]engine.InputMeta{
                        "as":            {Description: "Alias variabel item"},
                        "do":            {Description: "Blok yang diulang"},
                        "forelse_empty": {Description: "Blok jika data kosong"},
                        // Keep 'empty' for backward compat if users write manually, though parser uses forelse_empty
                        "empty":          {Description: "Blok jika data kosong (Legacy)"},
                        "__native_write": {Description: "Internal Blade attribute", Required: false},
                },
        })

        // ==========================================
        // SLOT: VALIDATION ERROR
        // ==========================================
        <span class="cov8" title="1">eng.Register("error", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                fieldName := coerce.ToString(node.Value)
                errorsRaw, ok := scope.Get("errors")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">errs, ok := errorsRaw.(map[string][]string)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">msgs, exists := errs[fieldName]
                if !exists || len(msgs) == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">scope.Set("message", msgs[0])
                for _, child := range node.Children </span><span class="cov8" title="1">{
                        if child.Name == "do" </span><span class="cov8" title="1">{
                                return eng.Execute(ctx, child, scope)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Menampilkan pesan error validasi untuk field tertentu.",
                Inputs: map[string]engine.InputMeta{
                        "do": {Description: "Blok kode yang dijalankan"},
                },
        })
}

func evalSimpleCondition(expr string, scope *engine.Scope) bool <span class="cov8" title="1">{
        var op string
        var left, right string

        ops := []string{"&lt;=", "&gt;=", "==", "!=", "&lt;", "&gt;"}
        for _, o := range ops </span><span class="cov8" title="1">{
                if strings.Contains(expr, o) </span><span class="cov8" title="1">{
                        op = o
                        parts := strings.SplitN(expr, o, 2)
                        left = strings.TrimSpace(parts[0])
                        right = strings.TrimSpace(parts[1])
                        break</span>
                }
        }

        <span class="cov8" title="1">if op == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">leftVal := resolveExpressionValue(left, scope)
        rightVal := resolveExpressionValue(right, scope)

        lInt, errL := coerce.ToInt(leftVal)
        rInt, errR := coerce.ToInt(rightVal)

        isNumeric := (errL == nil &amp;&amp; errR == nil)

        switch op </span>{
        case "&lt;":<span class="cov8" title="1">
                if isNumeric </span><span class="cov8" title="1">{
                        return lInt &lt; rInt
                }</span>
                <span class="cov0" title="0">return coerce.ToString(leftVal) &lt; coerce.ToString(rightVal)</span>
        case "&gt;":<span class="cov0" title="0">
                if isNumeric </span><span class="cov0" title="0">{
                        return lInt &gt; rInt
                }</span>
                <span class="cov0" title="0">return coerce.ToString(leftVal) &gt; coerce.ToString(rightVal)</span>
        case "&lt;=":<span class="cov8" title="1">
                if isNumeric </span><span class="cov8" title="1">{
                        return lInt &lt;= rInt
                }</span>
                <span class="cov0" title="0">return coerce.ToString(leftVal) &lt;= coerce.ToString(rightVal)</span>
        case "&gt;=":<span class="cov0" title="0">
                if isNumeric </span><span class="cov0" title="0">{
                        return lInt &gt;= rInt
                }</span>
                <span class="cov0" title="0">return coerce.ToString(leftVal) &gt;= coerce.ToString(rightVal)</span>
        case "==":<span class="cov8" title="1">
                if isNumeric </span><span class="cov8" title="1">{
                        return lInt == rInt
                }</span>
                <span class="cov0" title="0">return coerce.ToString(leftVal) == coerce.ToString(rightVal)</span>
        case "!=":<span class="cov0" title="0">
                if isNumeric </span><span class="cov0" title="0">{
                        return lInt != rInt
                }</span>
                <span class="cov0" title="0">return coerce.ToString(leftVal) != coerce.ToString(rightVal)</span>
        }
        <span class="cov0" title="0">return false</span>
}

func resolveExpressionValue(s string, scope *engine.Scope) interface{} <span class="cov8" title="1">{
        if strings.HasPrefix(s, "$") </span><span class="cov8" title="1">{
                v, _ := scope.Get(strings.TrimPrefix(s, "$"))
                return v
        }</span>
        <span class="cov8" title="1">if i, err := strconv.Atoi(s); err == nil </span><span class="cov8" title="1">{
                return i
        }</span>
        <span class="cov0" title="0">return s</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package slots

import (
        "context"
        "fmt"
        "net/smtp"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

// Exported for testing
var SendMailFunc = smtp.SendMail

func RegisterMailSlots(eng *engine.Engine) <span class="cov8" title="1">{

        // MAIL.SEND (SMTP)
        eng.Register("mail.send", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var host, user, pass, to, subject, body string
                var port int = 587 // Default SMTP port
                target := "mail_sent"

                // Support Shorthand: mail.send: "client@example.com" (atau $email)
                if node.Value != nil </span><span class="cov8" title="1">{
                        to = coerce.ToString(resolveValue(node.Value, scope))
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)

                        if c.Name == "host" </span><span class="cov8" title="1">{
                                host = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "port" </span><span class="cov8" title="1">{
                                if p, err := coerce.ToInt(val); err == nil </span><span class="cov8" title="1">{
                                        port = p
                                }</span>
                        }
                        <span class="cov8" title="1">if c.Name == "user" </span><span class="cov8" title="1">{
                                user = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "pass" </span><span class="cov8" title="1">{
                                pass = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "to" </span><span class="cov8" title="1">{
                                to = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "subject" </span><span class="cov8" title="1">{
                                subject = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "body" </span><span class="cov8" title="1">{
                                body = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if host == "" || user == "" || to == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("mail.send: host, user, and to are required")
                }</span>

                // Setup Authentication
                <span class="cov8" title="1">auth := smtp.PlainAuth("", user, pass, host)

                // Setup Message (Simple text/html)
                msg := []byte(fmt.Sprintf("To: %s\r\n"+
                        "Subject: %s\r\n"+
                        "Content-Type: text/html; charset=UTF-8\r\n"+
                        "\r\n"+
                        "%s\r\n", to, subject, body))

                addr := fmt.Sprintf("%s:%d", host, port)

                // Send Email
                err := SendMailFunc(addr, auth, user, []string{to}, msg)
                if err != nil </span><span class="cov8" title="1">{
                        scope.Set(target, false)
                        // Coba tangani error common
                        if strings.Contains(err.Error(), "authentication failed") </span><span class="cov0" title="0">{
                                return fmt.Errorf("mail.send: authentication failed, check user/pass")
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }

                <span class="cov8" title="1">scope.Set(target, true)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Mengirim email via SMTP.",
                Example: `mail.send: $client_email
  host: "smtp.gmail.com"
  port: 587
  user: $smtp_user
  pass: $smtp_pass
  subject: "Invoice"
  body: $html_content
  as: $is_sent`,
        })
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package slots

import (
        "context"
        "fmt"
        "math"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"

        "github.com/expr-lang/expr"
        "github.com/shopspring/decimal"
)

func RegisterMathSlots(eng *engine.Engine) <span class="cov8" title="1">{

        // ==========================================
        // 1. SLOT: MATH.CALC (General Math - Float64)
        // ==========================================
        eng.Register("math.calc", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                expressionStr := coerce.ToString(node.Value)
                target := "calc_result"

                // Support shorthand &amp; attributes
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "val" || c.Name == "expr" </span><span class="cov0" title="0">{
                                expressionStr = coerce.ToString(c.Value)
                        }</span>
                }

                <span class="cov8" title="1">if expressionStr == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("math.calc: expression is required")
                }</span>

                // 1. Siapkan Environment
                <span class="cov8" title="1">env := make(map[string]interface{})

                // Copy variabel dari scope &amp; AUTO-CONVERT angka
                for k, v := range scope.ToMap() </span><span class="cov8" title="1">{
                        // Cek apakah value ini string yang isinya angka? (misal: "5", "10.5")
                        if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                                if f, err := coerce.ToFloat64(str); err == nil </span><span class="cov0" title="0">{
                                        env[k] = f // Simpan sebagai Float agar bisa dihitung
                                }</span> else<span class="cov0" title="0"> {
                                        env[k] = str // Biarkan string jika bukan angka (misal: "budi")
                                }</span>
                        } else<span class="cov8" title="1"> {
                                env[k] = v // Value lain (int, bool, object) biarkan apa adanya
                        }</span>
                }

                // [UPGRADE] Inject Fungsi Matematika Standar
                <span class="cov8" title="1">env["ceil"] = math.Ceil
                env["floor"] = math.Floor
                env["round"] = math.Round
                env["abs"] = math.Abs
                env["max"] = math.Max
                env["min"] = math.Min
                env["sqrt"] = math.Sqrt
                env["pow"] = math.Pow

                // 2. Pre-processing ($ -&gt; kosong)
                cleanExpr := strings.ReplaceAll(expressionStr, "$", "")

                // 3. Compile &amp; Run
                program, err := expr.Compile(cleanExpr, expr.Env(env))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("math.calc: syntax error '%s': %v", expressionStr, err)
                }</span>

                <span class="cov8" title="1">output, err := expr.Run(program, env)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("math.calc: runtime error: %v", err)
                }</span>

                <span class="cov8" title="1">scope.Set(target, output)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Melakukan perhitungan matematika menggunakan ekspresi string.",
                Example:     "math.calc: ceil($total / 10)\n  as: $pages",
                ValueType:   "string",
                Inputs: map[string]engine.InputMeta{
                        "as":   {Description: "Variabel penyimpan hasil", Required: false, Type: "string"},
                        "val":  {Description: "Ekspresi matematika (jika tidak via value utama)", Required: false, Type: "string"},
                        "expr": {Description: "Alias untuk val", Required: false, Type: "string"},
                },
        })

        // ==========================================
        // 2. SLOT: MONEY.CALC (Financial Math - Decimal)
        // ==========================================
        <span class="cov8" title="1">eng.Register("money.calc", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                expressionStr := coerce.ToString(node.Value)
                target := "money_result"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "val" </span><span class="cov0" title="0">{
                                expressionStr = coerce.ToString(c.Value)
                        }</span>
                }

                // 1. Siapkan Environment Decimal
                <span class="cov8" title="1">env := make(map[string]interface{})

                for k, v := range scope.ToMap() </span><span class="cov8" title="1">{
                        // Only convert if it looks like a number
                        s := coerce.ToString(v)
                        if s != "" &amp;&amp; (s[0] == '-' || (s[0] &gt;= '0' &amp;&amp; s[0] &lt;= '9')) </span><span class="cov8" title="1">{
                                if d, err := decimal.NewFromString(s); err == nil </span><span class="cov8" title="1">{
                                        env[k] = d
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">env[k] = v</span> // Keep original for non-numeric
                }

                // Inject Decimal Functions for Operator Overloading
                <span class="cov8" title="1">env["Add"] = func(a, b decimal.Decimal) decimal.Decimal </span><span class="cov8" title="1">{ return a.Add(b) }</span>
                <span class="cov8" title="1">env["Sub"] = func(a, b decimal.Decimal) decimal.Decimal </span><span class="cov8" title="1">{ return a.Sub(b) }</span>
                <span class="cov8" title="1">env["Mul"] = func(a, b decimal.Decimal) decimal.Decimal </span><span class="cov8" title="1">{ return a.Mul(b) }</span>
                <span class="cov8" title="1">env["Div"] = func(a, b decimal.Decimal) decimal.Decimal </span><span class="cov0" title="0">{ return a.Div(b) }</span>

                // [UPGRADE] Inject Decimal Constructor for literals
                <span class="cov8" title="1">env["decimal"] = func(v interface{}) decimal.Decimal </span><span class="cov8" title="1">{
                        d, _ := decimal.NewFromString(coerce.ToString(v))
                        return d
                }</span>

                // 2. Pre-processing
                <span class="cov8" title="1">cleanExpr := strings.ReplaceAll(expressionStr, "$", "")

                // 3. Konfigurasi Expr (Operator Overloading)
                options := []expr.Option{
                        expr.Env(env),
                        expr.Operator("+", "Add"),
                        expr.Operator("-", "Sub"),
                        expr.Operator("*", "Mul"),
                        expr.Operator("/", "Div"),
                }

                program, err := expr.Compile(cleanExpr, options...)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("money.calc: syntax error '%s': %v", expressionStr, err)
                }</span>

                <span class="cov8" title="1">output, err := expr.Run(program, env)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("money.calc: runtime error: %v", err)
                }</span>

                // Return sebagai String
                <span class="cov8" title="1">if d, ok := output.(decimal.Decimal); ok </span><span class="cov8" title="1">{
                        scope.Set(target, d.String())
                }</span> else<span class="cov0" title="0"> {
                        scope.Set(target, coerce.ToString(output))
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Melakukan perhitungan keuangan menggunakan Decimal untuk presisi tinggi.",
                Example:     "money.calc: ($harga * $qty) - $diskon\n  as: $total",
                ValueType:   "decimal",
                Inputs: map[string]engine.InputMeta{
                        "as":  {Description: "Variabel penyimpan hasil", Required: false, Type: "string"},
                        "val": {Description: "Ekspresi keuangan", Required: false, Type: "decimal"},
                },
        })
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package slots

import (
        "context"
        "fmt"
        "net/http"
        "net/http/httptest"
        "path/filepath"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

func RegisterMetaSlots(eng *engine.Engine) <span class="cov8" title="1">{
        // 1. meta.eval
        eng.Register("meta.eval", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // Resolve the value (handle variables like $code)
                val := resolveValue(node.Value, scope)
                code, ok := val.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("meta.eval requires a string value, got %T: %v", val, val)
                }</span>

                // Parse the code dynamically
                <span class="cov8" title="1">root, err := engine.ParseString(code, "eval")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("meta.eval parse error: %v", err)
                }</span>

                // Execute the parsed AST
                <span class="cov8" title="1">if err := eng.Execute(ctx, root, scope); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Evaluates a string as ZenoLang code dynamically.",
                Example:     `meta.eval: "http.get: '/api'"`,
                Inputs: map[string]engine.InputMeta{
                        "(value)": {Description: "The ZenoLang code string to evaluate", Type: "string"},
                },
        })

        // 2. meta.scope
        <span class="cov8" title="1">eng.Register("meta.scope", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // Introspection: Return all variables in current scope as a map
                vars := scope.ToMap()

                // Check for "as" attribute to store result
                target := ""
                for _, child := range node.Children </span><span class="cov8" title="1">{
                        if child.Name == "as" </span><span class="cov8" title="1">{
                                if val, ok := child.Value.(string); ok </span><span class="cov8" title="1">{
                                        target = strings.TrimPrefix(val, "$")
                                }</span>
                        }
                }

                <span class="cov8" title="1">if target != "" </span><span class="cov8" title="1">{
                        scope.Set(target, vars)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Returns all variables in the current scope as a map (Introspection).",
                Example:     `$vars: meta.scope`,
                Inputs: map[string]engine.InputMeta{
                        "as": {Description: "Variable to store the scope map", Type: "string"},
                },
        })

        // 3. meta.parse
        <span class="cov8" title="1">eng.Register("meta.parse", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // Resolve the value
                val := resolveValue(node.Value, scope)
                code, ok := val.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("meta.parse requires a string value, got %T: %v", val, val)
                }</span>

                // Parse the code
                <span class="cov8" title="1">root, err := engine.ParseString(code, "eval")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("meta.parse error: %v", err)
                }</span>

                // Convert AST to Map
                <span class="cov8" title="1">astMap := nodeToMap(root)

                // Return result via "as" attribute
                target := ""
                for _, child := range node.Children </span><span class="cov8" title="1">{
                        if child.Name == "as" </span><span class="cov8" title="1">{
                                if val, ok := child.Value.(string); ok </span><span class="cov8" title="1">{
                                        target = strings.TrimPrefix(val, "$")
                                }</span>
                        }
                }

                <span class="cov8" title="1">if target != "" </span><span class="cov8" title="1">{
                        scope.Set(target, astMap)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Parses ZenoLang code into an AST Map (Code as Data).",
                Example:     `$ast: meta.parse: "print: 'hello'"`,
                Inputs: map[string]engine.InputMeta{
                        "(value)": {Description: "The ZenoLang code string to parse", Type: "string"},
                        "as":      {Description: "Variable to store the AST map", Type: "string"},
                },
        })

        // 4. meta.run
        <span class="cov8" title="1">eng.Register("meta.run", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                var astMap map[string]interface{}

                // Input can be value or "ast" attribute
                if val, ok := node.Value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        astMap = val
                }</span> else<span class="cov0" title="0"> {
                        // Check children
                        for _, child := range node.Children </span><span class="cov0" title="0">{
                                if child.Name == "ast" </span><span class="cov0" title="0">{
                                        if m, ok := child.Value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                astMap = m
                                        }</span> else<span class="cov0" title="0"> {
                                                // Try to resolve variable
                                                val := eng.ResolveShorthandValue(child, scope)
                                                if m, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                        astMap = m
                                                }</span>
                                        }
                                }
                        }
                }

                <span class="cov0" title="0">if astMap == nil </span><span class="cov0" title="0">{
                        // Try to resolve main value if it was a variable reference
                        val := eng.ResolveShorthandValue(node, scope)
                        if m, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                astMap = m
                        }</span>
                }

                <span class="cov0" title="0">if astMap == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("meta.run requires an AST Map")
                }</span>

                // Convert Map to AST
                <span class="cov0" title="0">root, err := mapToNode(astMap)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("meta.run error: %v", err)
                }</span>

                // Execute
                <span class="cov0" title="0">if err := eng.Execute(ctx, root, scope); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Executes an AST Map as ZenoLang code.",
                Example:     `meta.run: $ast`,
                Inputs: map[string]engine.InputMeta{
                        "(value)": {Description: "The AST Map to execute", Type: "map"},
                },
        })

        // 5. meta.template (Render Blade to String)
        <span class="cov8" title="1">eng.Register("meta.template", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                // 1. Prepare Recorder
                rec := httptest.NewRecorder()
                subCtx := context.WithValue(ctx, "httpWriter", http.ResponseWriter(rec))

                // 2. Resolve View File
                var viewFile string
                if node.Value != nil </span><span class="cov0" title="0">{
                        viewFile = coerce.ToString(resolveValue(node.Value, scope))
                }</span>

                // 3. Process Attributes (Children)
                <span class="cov0" title="0">if viewFile == "" </span><span class="cov0" title="0">{
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "file" </span><span class="cov0" title="0">{
                                        viewFile = coerce.ToString(resolveValue(c.Value, scope))
                                        continue</span>
                                }
                                // Bind attribute to scope (variables for the template)
                                <span class="cov0" title="0">val := parseNodeValue(c, scope)
                                scope.Set(c.Name, val)</span>
                        }
                } else<span class="cov0" title="0"> {
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                // Check for "as" attribute to store result
                                if c.Name == "as" </span><span class="cov0" title="0">{
                                        continue</span> // Handle later
                                }
                                // Bind attribute to scope
                                <span class="cov0" title="0">val := parseNodeValue(c, scope)
                                scope.Set(c.Name, val)</span>
                        }
                }

                <span class="cov0" title="0">if viewFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("meta.template: file required")
                }</span>

                // 4. Load Template (Using shared helpers from blade.go)
                <span class="cov0" title="0">fullPath := filepath.Join("views", ensureBladeExt(viewFile))
                programNode, err := getCachedOrParse(fullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // 5. Execute with Recorder Context
                <span class="cov0" title="0">if err := eng.Execute(subCtx, programNode, scope); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // 6. Capture Output
                <span class="cov0" title="0">output := rec.Body.String()

                // 7. Store in Variable ("as" attribute)
                target := ""
                for _, child := range node.Children </span><span class="cov0" title="0">{
                        if child.Name == "as" </span><span class="cov0" title="0">{
                                val := coerce.ToString(child.Value)
                                target = strings.TrimPrefix(val, "$")
                        }</span>
                }

                <span class="cov0" title="0">if target != "" </span><span class="cov0" title="0">{
                        scope.Set(target, output)
                }</span>

                <span class="cov0" title="0">return nil</span>

        }, engine.SlotMeta{
                Description: "Renders a Blade template into a string variable (useful for code generation).",
                Example:     `meta.template: 'codegen/route' { resource: 'users'; as: $code }`,
        })
}

// Helper: Convert Node to Map
func nodeToMap(n *engine.Node) map[string]interface{} <span class="cov8" title="1">{
        if n == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">m := make(map[string]interface{})
        m["name"] = n.Name
        m["value"] = n.Value
        m["line"] = n.Line
        m["col"] = n.Col
        m["filename"] = n.Filename

        var children []map[string]interface{}
        for _, c := range n.Children </span><span class="cov8" title="1">{
                children = append(children, nodeToMap(c))
        }</span>
        <span class="cov8" title="1">m["children"] = children
        return m</span>
}

// Helper: Convert Map to Node
func mapToNode(m map[string]interface{}) (*engine.Node, error) <span class="cov0" title="0">{
        n := &amp;engine.Node{}

        if name, ok := m["name"].(string); ok </span><span class="cov0" title="0">{
                n.Name = name
        }</span>

        <span class="cov0" title="0">if val, ok := m["value"]; ok </span><span class="cov0" title="0">{
                n.Value = val
        }</span>

        <span class="cov0" title="0">if line, ok := m["line"]; ok </span><span class="cov0" title="0">{
                n.Line = coerceToInt(line)
        }</span>
        <span class="cov0" title="0">if col, ok := m["col"]; ok </span><span class="cov0" title="0">{
                n.Col = coerceToInt(col)
        }</span>
        <span class="cov0" title="0">if filename, ok := m["filename"].(string); ok </span><span class="cov0" title="0">{
                n.Filename = filename
        }</span>

        <span class="cov0" title="0">if children, ok := m["children"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, c := range children </span><span class="cov0" title="0">{
                        if childMap, ok := c.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                childNode, err := mapToNode(childMap)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">childNode.Parent = n
                                n.Children = append(n.Children, childNode)</span>
                        }
                }
        } else<span class="cov0" title="0"> if childrenList, ok := m["children"].([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                // Handle specific type slice if applicable
                for _, childMap := range childrenList </span><span class="cov0" title="0">{
                        childNode, err := mapToNode(childMap)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">childNode.Parent = n
                        n.Children = append(n.Children, childNode)</span>
                }
        }

        <span class="cov0" title="0">return n, nil</span>
}

func coerceToInt(val interface{}) int <span class="cov0" title="0">{
        if i, ok := val.(int); ok </span><span class="cov0" title="0">{
                return i
        }</span>
        <span class="cov0" title="0">if f, ok := val.(float64); ok </span><span class="cov0" title="0">{
                return int(f)
        }</span>
        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package slots

import (
        "context"
        "encoding/json"
        "io"
        "net/http"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

func RegisterNetworkSlots(eng *engine.Engine) <span class="cov8" title="1">{
        // HTTP FETCH
        eng.Register("http.fetch", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var url, method, target string
                method = "GET"
                target = "api_response"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "url" </span><span class="cov0" title="0">{
                                url = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "method" </span><span class="cov0" title="0">{
                                method = strings.ToUpper(coerce.ToString(val))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if url == "" </span><span class="cov8" title="1">{
                        // Fallback value node (http.fetch: "$url")
                        url = coerce.ToString(resolveValue(node.Value, scope))
                }</span>

                <span class="cov8" title="1">req, err := http.NewRequest(method, url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">client := &amp;http.Client{}
                resp, err := client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer resp.Body.Close()

                bodyBytes, _ := io.ReadAll(resp.Body)
                var result interface{}

                // Auto-detect JSON
                if strings.Contains(resp.Header.Get("Content-Type"), "application/json") </span><span class="cov8" title="1">{
                        var jsonResult interface{}
                        if err := json.Unmarshal(bodyBytes, &amp;jsonResult); err == nil </span><span class="cov8" title="1">{
                                result = jsonResult
                        }</span> else<span class="cov0" title="0"> {
                                result = string(bodyBytes)
                        }</span>
                } else<span class="cov0" title="0"> {
                        result = string(bodyBytes)
                }</span>

                <span class="cov8" title="1">scope.Set(target, result)
                return nil</span>
        }, engine.SlotMeta{Example: "http.fetch: $api_url\n  as: $response"})
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package slots

import (
        "context"
        "fmt"
        "strings"
        "zeno/pkg/dbmanager"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

func RegisterORMSlots(eng *engine.Engine, dbMgr *dbmanager.DBManager) <span class="cov8" title="1">{

        // ORM.MODEL: 'users'
        eng.Register("orm.model", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                tableName := coerce.ToString(resolveValue(node.Value, scope))
                dbName := "default"

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "db" || c.Name == "connection" </span><span class="cov0" title="0">{
                                dbName = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                // Leverage existing db.table logic by setting _query_state
                <span class="cov8" title="1">dialect := dbMgr.GetDialect(dbName)
                scope.Set("_query_state", &amp;QueryState{
                        Table:   tableName,
                        DBName:  dbName,
                        Dialect: dialect,
                })

                // Store model metadata for other orm.* slots
                scope.Set("_active_model", tableName)

                return nil</span>
        }, engine.SlotMeta{
                Description: "Define the active model/table for ORM operations.",
                Example:     "orm.model: 'users'",
        })

        // ORM.FIND: 1 { as: $user }
        <span class="cov8" title="1">eng.Register("orm.find", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                id := resolveValue(node.Value, scope)
                target := "model"
                primaryKey := "id"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "key" || c.Name == "pk" </span><span class="cov0" title="0">{
                                primaryKey = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                // Ensure query state exists
                <span class="cov8" title="1">qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("orm.find: no model defined. Call orm.model first")
                }</span>
                <span class="cov8" title="1">qs := qsVal.(*QueryState)

                // Create a temporary filter for find
                originalWhere := qs.Where
                qs.Where = append(qs.Where, WhereCond{Column: primaryKey, Op: "=", Value: id})

                // Use db.first logic (Execute db.first slot internally)
                firstNode := &amp;engine.Node{
                        Name: "db.first",
                        Children: []*engine.Node{
                                {Name: "as", Value: target},
                        },
                }

                err := eng.Execute(ctx, firstNode, scope)

                // Restore original where state
                qs.Where = originalWhere

                return err</span>
        }, engine.SlotMeta{
                Description: "Find a single record by primary key.",
                Example:     "orm.find: 1 { as: $user }",
        })

        // ORM.SAVE: $user
        <span class="cov8" title="1">eng.Register("orm.save", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                dataRaw := resolveValue(node.Value, scope)
                data, ok := dataRaw.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("orm.save: expected map data, got %T", dataRaw)
                }</span>

                <span class="cov8" title="1">primaryKey := "id"
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "key" || c.Name == "pk" </span><span class="cov0" title="0">{
                                primaryKey = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                <span class="cov8" title="1">qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("orm.save: no model defined")
                }</span>
                <span class="cov8" title="1">qs := qsVal.(*QueryState)

                idVal, hasId := data[primaryKey]
                // Check if ID exists and is non-zero
                isUpdate := false
                if hasId &amp;&amp; idVal != nil </span><span class="cov8" title="1">{
                        idInt, _ := coerce.ToInt(idVal)
                        if idInt &gt; 0 </span><span class="cov8" title="1">{
                                isUpdate = true
                        }</span>
                }

                <span class="cov8" title="1">if isUpdate </span><span class="cov8" title="1">{
                        // Update Logic
                        originalWhere := qs.Where
                        qs.Where = append(qs.Where, WhereCond{Logical: "AND", Column: primaryKey, Op: "=", Value: idVal})

                        // Build sets excluding the PK
                        updateNode := &amp;engine.Node{Name: "db.update"}
                        for k, v := range data </span><span class="cov8" title="1">{
                                if k == primaryKey </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">updateNode.Children = append(updateNode.Children, &amp;engine.Node{Name: k, Value: v})</span>
                        }

                        <span class="cov8" title="1">err := eng.Execute(ctx, updateNode, scope)
                        qs.Where = originalWhere
                        return err</span>
                } else<span class="cov8" title="1"> {
                        // Insert Logic
                        insertNode := &amp;engine.Node{Name: "db.insert"}
                        for k, v := range data </span><span class="cov8" title="1">{
                                insertNode.Children = append(insertNode.Children, &amp;engine.Node{Name: k, Value: v})
                        }</span>
                        <span class="cov8" title="1">err := eng.Execute(ctx, insertNode, scope)
                        if err == nil </span><span class="cov8" title="1">{
                                // Set the new ID back to the object if possible
                                if lastId, ok := scope.Get("db_last_id"); ok </span><span class="cov8" title="1">{
                                        data[primaryKey] = lastId
                                }</span>
                        }
                        <span class="cov8" title="1">return err</span>
                }
        }, engine.SlotMeta{
                Description: "Save (Insert or Update) a model object.",
                Example:     "orm.save: $user",
        })

        // ORM.DELETE: $user (or ID)
        <span class="cov8" title="1">eng.Register("orm.delete", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                val := resolveValue(node.Value, scope)
                primaryKey := "id"
                var id interface{}

                if data, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        id = data[primaryKey]
                }</span> else<span class="cov0" title="0"> {
                        id = val
                }</span>

                <span class="cov0" title="0">if id == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("orm.delete: ID not found")
                }</span>

                <span class="cov0" title="0">qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("orm.delete: no model defined")
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)

                originalWhere := qs.Where
                qs.Where = append(qs.Where, WhereCond{Column: primaryKey, Op: "=", Value: id})

                deleteNode := &amp;engine.Node{Name: "db.delete"}
                err := eng.Execute(ctx, deleteNode, scope)

                qs.Where = originalWhere
                return err</span>
        }, engine.SlotMeta{})

        // ORM.BELONGSTO: 'User' { as: 'author', foreign_key: 'user_id' }
        <span class="cov8" title="1">eng.Register("orm.belongsTo", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                relatedModel := coerce.ToString(resolveValue(node.Value, scope))
                asName := strings.ToLower(relatedModel)
                foreignKey := asName + "_id"

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                asName = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "foreign_key" || c.Name == "fk" </span><span class="cov0" title="0">{
                                foreignKey = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                // Store relationship info in current model's metadata
                <span class="cov0" title="0">modelName := coerce.ToString(scope.GetDefault("_active_model", ""))
                if modelName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("orm.belongsTo: no active model")
                }</span>

                <span class="cov0" title="0">relKey := fmt.Sprintf("_rel_%s_%s", modelName, asName)
                scope.Set(relKey, map[string]interface{}{
                        "type":        "belongsTo",
                        "model":       relatedModel,
                        "foreign_key": foreignKey,
                })

                return nil</span>
        }, engine.SlotMeta{Description: "Define a many-to-one relationship."})

        // ORM.HASMANY: 'Post' { as: 'posts', foreign_key: 'user_id' }
        <span class="cov8" title="1">eng.Register("orm.hasMany", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                relatedModel := coerce.ToString(resolveValue(node.Value, scope))
                asName := strings.ToLower(relatedModel) + "s"
                localKey := "id"
                foreignKey := strings.ToLower(coerce.ToString(scope.GetDefault("_active_model", ""))) + "_id"

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                asName = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "foreign_key" || c.Name == "fk" </span><span class="cov0" title="0">{
                                foreignKey = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "local_key" || c.Name == "lk" </span><span class="cov0" title="0">{
                                localKey = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                <span class="cov0" title="0">modelName := coerce.ToString(scope.GetDefault("_active_model", ""))
                if modelName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("orm.hasMany: no active model")
                }</span>

                <span class="cov0" title="0">relKey := fmt.Sprintf("_rel_%s_%s", modelName, asName)
                scope.Set(relKey, map[string]interface{}{
                        "type":        "hasMany",
                        "model":       relatedModel,
                        "local_key":   localKey,
                        "foreign_key": foreignKey,
                })

                return nil</span>
        }, engine.SlotMeta{Description: "Define a one-to-many relationship."})

        // ORM.WITH: 'author' { orm.all: $posts }
        <span class="cov8" title="1">eng.Register("orm.with", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                relName := coerce.ToString(resolveValue(node.Value, scope))
                modelName := coerce.ToString(scope.GetDefault("_active_model", ""))

                relKey := fmt.Sprintf("_rel_%s_%s", modelName, relName)
                relRaw, ok := scope.Get(relKey)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("orm.with: relationship '%s' not defined for model '%s'", relName, modelName)
                }</span>
                <span class="cov0" title="0">rel := relRaw.(map[string]interface{})

                // 1. Execute the main query (usually the child block)
                if len(node.Children) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("orm.with: expected child query block")
                }</span>

                // We need to capture the result of the child query.
                // For simplicity, we assume the child query (like orm.all) sets a variable.
                // However, orm.all/db.get typically sets a variable in scope if 'as' is provided.

                <span class="cov0" title="0">err := eng.Execute(ctx, node.Children[0], scope)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // 2. Hydrate Relational Data
                // This is a simplified Eager Loading (not full N+1 fix yet, but functional API)
                // We'll look for the result in scope based on the child slot's 'as' attribute.
                <span class="cov0" title="0">var targetVar string
                for _, c := range node.Children[0].Children </span><span class="cov0" title="0">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                targetVar = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">if targetVar == "" </span><span class="cov0" title="0">{
                        return nil // No result to hydrate
                }</span>

                <span class="cov0" title="0">data, ok := scope.Get(targetVar)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Hydration Logic
                <span class="cov0" title="0">if rel["type"] == "belongsTo" </span><span class="cov0" title="0">{
                        // Find related for each item
                        list, err := coerce.ToSlice(data)
                        if err != nil </span><span class="cov0" title="0">{
                                // Single object
                                obj := data.(map[string]interface{})
                                fkVal := obj[rel["foreign_key"].(string)]
                                // Temporary switch model context
                                oldModel := scope.GetDefault("_active_model", "")
                                oldQS, _ := scope.Get("_query_state")

                                // Set new model context
                                dialect := dbMgr.GetDialect("default") // Assuming default DB
                                scope.Set("_active_model", rel["model"])
                                scope.Set("_query_state", &amp;QueryState{
                                        Table:   rel["model"].(string),
                                        Dialect: dialect,
                                        DBName:  "default",
                                })

                                eng.Execute(ctx, &amp;engine.Node{
                                        Name:     "orm.find",
                                        Value:    fkVal,
                                        Children: []*engine.Node{{Name: "as", Value: relName}},
                                }, scope)

                                if related, ok := scope.Get(relName); ok </span><span class="cov0" title="0">{
                                        obj[relName] = related
                                }</span>

                                // Restore context
                                <span class="cov0" title="0">scope.Set("_active_model", oldModel)
                                scope.Set("_query_state", oldQS)</span>
                        } else<span class="cov0" title="0"> {
                                // List of objects
                                for _, item := range list </span><span class="cov0" title="0">{
                                        obj := item.(map[string]interface{})
                                        fkVal := obj[rel["foreign_key"].(string)]

                                        oldModel := scope.GetDefault("_active_model", "")
                                        oldQS, _ := scope.Get("_query_state")

                                        dialect := dbMgr.GetDialect("default")
                                        scope.Set("_active_model", rel["model"])
                                        scope.Set("_query_state", &amp;QueryState{
                                                Table:   rel["model"].(string),
                                                Dialect: dialect,
                                                DBName:  "default",
                                        })

                                        eng.Execute(ctx, &amp;engine.Node{
                                                Name:     "orm.find",
                                                Value:    fkVal,
                                                Children: []*engine.Node{{Name: "as", Value: "___temp_rel"}},
                                        }, scope)
                                        if related, ok := scope.Get("___temp_rel"); ok </span><span class="cov0" title="0">{
                                                obj[relName] = related
                                        }</span>

                                        <span class="cov0" title="0">scope.Set("_active_model", oldModel)
                                        scope.Set("_query_state", oldQS)</span>
                                }
                        }
                } else<span class="cov0" title="0"> if rel["type"] == "hasMany" </span><span class="cov0" title="0">{
                        // Find many for each item
                        list, err := coerce.ToSlice(data)
                        if err != nil </span><span class="cov0" title="0">{
                                // Single object
                                obj := data.(map[string]interface{})
                                localVal := obj[rel["local_key"].(string)]

                                oldModel := scope.GetDefault("_active_model", "")
                                oldQS, _ := scope.Get("_query_state")

                                dialect := dbMgr.GetDialect("default")
                                scope.Set("_active_model", rel["model"])
                                scope.Set("_query_state", &amp;QueryState{
                                        Table:   rel["model"].(string),
                                        Dialect: dialect,
                                        DBName:  "default",
                                })

                                eng.Execute(ctx, &amp;engine.Node{
                                        Name: "db.where",
                                        Children: []*engine.Node{
                                                {Name: "col", Value: rel["foreign_key"]},
                                                {Name: "op", Value: "="},
                                                {Name: "val", Value: localVal},
                                        },
                                }, scope)
                                eng.Execute(ctx, &amp;engine.Node{
                                        Name:     "db.get",
                                        Children: []*engine.Node{{Name: "as", Value: "___temp_rel_list"}},
                                }, scope)

                                if related, ok := scope.Get("___temp_rel_list"); ok </span><span class="cov0" title="0">{
                                        obj[relName] = related
                                }</span>

                                <span class="cov0" title="0">scope.Set("_active_model", oldModel)
                                scope.Set("_query_state", oldQS)</span>
                        } else<span class="cov0" title="0"> {
                                for _, item := range list </span><span class="cov0" title="0">{
                                        obj := item.(map[string]interface{})
                                        localVal := obj[rel["local_key"].(string)]

                                        oldModel := scope.GetDefault("_active_model", "")
                                        oldQS, _ := scope.Get("_query_state")

                                        dialect := dbMgr.GetDialect("default")
                                        scope.Set("_active_model", rel["model"])
                                        scope.Set("_query_state", &amp;QueryState{
                                                Table:   rel["model"].(string),
                                                Dialect: dialect,
                                                DBName:  "default",
                                        })

                                        eng.Execute(ctx, &amp;engine.Node{
                                                Name: "db.where",
                                                Children: []*engine.Node{
                                                        {Name: "col", Value: rel["foreign_key"]},
                                                        {Name: "op", Value: "="},
                                                        {Name: "val", Value: localVal},
                                                },
                                        }, scope)
                                        eng.Execute(ctx, &amp;engine.Node{
                                                Name:     "db.get",
                                                Children: []*engine.Node{{Name: "as", Value: "___temp_rel_list"}},
                                        }, scope)

                                        if related, ok := scope.Get("___temp_rel_list"); ok </span><span class="cov0" title="0">{
                                                obj[relName] = related
                                        }</span>

                                        <span class="cov0" title="0">scope.Set("_active_model", oldModel)
                                        scope.Set("_query_state", oldQS)</span>
                                }
                        }
                }

                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{Description: "Eager load a relationship."})

        // DB.SEED: { name: 'UserSeeder', data: [...] }
        <span class="cov8" title="1">eng.Register("db.seed", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                // Basic seeding: just execute the block
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if err := eng.Execute(ctx, c, scope); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">logNode := &amp;engine.Node{Name: "log", Value: " Seeding completed."}
                eng.Execute(ctx, logNode, scope)
                return nil</span>
        }, engine.SlotMeta{Description: "Execute database seeders."})
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package slots

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "zeno/pkg/dbmanager"
        "zeno/pkg/engine"
        "zeno/pkg/wasm"

        "github.com/go-chi/chi/v5"
)

// Global plugin manager for cleanup
var globalPluginManager *wasm.PluginManager

// RegisterPluginSlots loads and registers all plugins (WASM &amp; Sidecar)
func RegisterPluginSlots(eng *engine.Engine, r *chi.Mux, dbMgr *dbmanager.DBManager) <span class="cov8" title="1">{
        // Check if plugins are enabled
        enabled := os.Getenv("ZENO_PLUGINS_ENABLED")
        if enabled != "true" &amp;&amp; enabled != "1" </span><span class="cov8" title="1">{
                slog.Debug("Plugins disabled", "env", "ZENO_PLUGINS_ENABLED")
                return
        }</span>

        // Get plugin directory
        <span class="cov0" title="0">pluginDir := os.Getenv("ZENO_PLUGIN_DIR")
        if pluginDir == "" </span><span class="cov0" title="0">{
                pluginDir = "./plugins"
        }</span>

        // Create plugin manager
        <span class="cov0" title="0">ctx := context.Background()
        pm, err := wasm.NewPluginManager(ctx, pluginDir)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to create plugin manager", "error", err)
                return
        }</span>

        // Set host callbacks
        <span class="cov0" title="0">setupHostCallbacks(pm, eng, dbMgr)

        // Load plugins from directory
        if err := pm.LoadPluginsFromDir(pluginDir); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load plugins", "error", err)
                return
        }</span>

        // Register slots from all loaded plugins
        <span class="cov0" title="0">plugins := pm.ListPlugins()
        totalSlots := 0

        for _, plugin := range plugins </span><span class="cov0" title="0">{
                for _, slot := range plugin.Slots </span><span class="cov0" title="0">{
                        // Register each slot
                        slotName := slot.Name
                        pluginName := plugin.Manifest.Name

                        eng.Register(slotName, func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                                // Inject scope into context for host functions
                                ctx = context.WithValue(ctx, "scope", scope)
                                return executePluginSlot(ctx, pm, pluginName, slotName, node, scope)
                        }</span>, engine.SlotMeta{
                                Description: slot.Description,
                                Example:     slot.Example,
                                Inputs:      convertInputMeta(slot.Inputs),
                        })

                        <span class="cov0" title="0">totalSlots++</span>
                }
        }

        <span class="cov0" title="0">if totalSlots &gt; 0 </span><span class="cov0" title="0">{
                slog.Info(" Plugins registered",
                        "plugins", len(plugins),
                        "slots", totalSlots)
        }</span>

        // Store plugin manager for cleanup
        <span class="cov0" title="0">globalPluginManager = pm

        if r == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Register admin API for hot reload
        <span class="cov0" title="0">r.Post("/api/admin/plugins/reload", func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                // Check for specific plugin name query param
                pluginName := req.URL.Query().Get("name")
                
                var err error
                if pluginName != "" </span><span class="cov0" title="0">{
                        err = pm.ReloadPlugin(pluginName)
                }</span> else<span class="cov0" title="0"> {
                        // Reload all if no name specified
                        errs := pm.ReloadAllPlugins()
                        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                                // Aggregate errors
                                errStr := []string{}
                                for p, e := range errs </span><span class="cov0" title="0">{
                                        errStr = append(errStr, fmt.Sprintf("%s: %v", p, e))
                                }</span>
                                <span class="cov0" title="0">err = fmt.Errorf("reload failed for: %s", strings.Join(errStr, ", "))</span>
                        }
                }

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
                        return
                }</span>

                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                json.NewEncoder(w).Encode(map[string]string{"status": "reloaded"})</span>
        })
}

// CleanupPlugins gracefully shuts down all plugins
// This should be called during application shutdown
func CleanupPlugins() <span class="cov0" title="0">{
        if globalPluginManager != nil </span><span class="cov0" title="0">{
                slog.Info(" Cleaning up plugins...")
                if err := globalPluginManager.Close(); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to cleanup plugins", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        slog.Info(" Plugins cleaned up")
                }</span>
                <span class="cov0" title="0">globalPluginManager = nil</span>
        }
}

// setupHostCallbacks configures host function callbacks
func setupHostCallbacks(pm *wasm.PluginManager, eng *engine.Engine, dbMgr *dbmanager.DBManager) <span class="cov0" title="0">{
        // Logging callback
        pm.SetHostCallback("log", func(ctx context.Context, level, message string) </span><span class="cov0" title="0">{
                switch level </span>{
                case "debug":<span class="cov0" title="0">
                        slog.Debug("[Plugin] " + message)</span>
                case "info":<span class="cov0" title="0">
                        slog.Info("[Plugin] " + message)</span>
                case "warn":<span class="cov0" title="0">
                        slog.Warn("[Plugin] " + message)</span>
                case "error":<span class="cov0" title="0">
                        slog.Error("[Plugin] " + message)</span>
                default:<span class="cov0" title="0">
                        slog.Info("[Plugin] " + message)</span>
                }
        })

        // Database query callback
        <span class="cov0" title="0">if dbMgr != nil </span><span class="cov0" title="0">{
                pm.SetHostCallback("db_query", func(ctx context.Context, connection, sql string, params map[string]interface{}) ([]map[string]interface{}, error) </span><span class="cov0" title="0">{
                        // Get database connection
                        db := dbMgr.GetConnection(connection)
                        if db == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("database connection not found: %s", connection)
                        }</span>

                        // Execute query
                        <span class="cov0" title="0">rows, err := db.Query(sql)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">defer rows.Close()

                        // Get column names
                        columns, err := rows.Columns()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Scan results
                        <span class="cov0" title="0">var results []map[string]interface{}
                        for rows.Next() </span><span class="cov0" title="0">{
                                // Create slice for scanning
                                values := make([]interface{}, len(columns))
                                valuePtrs := make([]interface{}, len(columns))
                                for i := range values </span><span class="cov0" title="0">{
                                        valuePtrs[i] = &amp;values[i]
                                }</span>

                                <span class="cov0" title="0">if err := rows.Scan(valuePtrs...); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                // Convert to map
                                <span class="cov0" title="0">row := make(map[string]interface{})
                                for i, col := range columns </span><span class="cov0" title="0">{
                                        val := values[i]
                                        // Convert []byte to string
                                        if b, ok := val.([]byte); ok </span><span class="cov0" title="0">{
                                                row[col] = string(b)
                                        }</span> else<span class="cov0" title="0"> {
                                                row[col] = val
                                        }</span>
                                }
                                <span class="cov0" title="0">results = append(results, row)</span>
                        }

                        <span class="cov0" title="0">return results, nil</span>
                })
        }

        // HTTP request callback
        <span class="cov0" title="0">pm.SetHostCallback("http_request", func(ctx context.Context, method, url string, headers, body map[string]interface{}) (map[string]interface{}, error) </span><span class="cov0" title="0">{
                // Create HTTP client with timeout
                client := &amp;http.Client{
                        Timeout: 30 * time.Second,
                }

                // Prepare request body
                var reqBody io.Reader
                if body != nil &amp;&amp; len(body) &gt; 0 </span><span class="cov0" title="0">{
                        jsonBody, err := json.Marshal(body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to marshal request body: %w", err)
                        }</span>
                        <span class="cov0" title="0">reqBody = bytes.NewBuffer(jsonBody)</span>
                }

                // Create HTTP request
                <span class="cov0" title="0">req, err := http.NewRequest(strings.ToUpper(method), url, reqBody)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create request: %w", err)
                }</span>

                // Set headers
                <span class="cov0" title="0">if headers != nil </span><span class="cov0" title="0">{
                        for key, value := range headers </span><span class="cov0" title="0">{
                                if strValue, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        req.Header.Set(key, strValue)
                                }</span>
                        }
                }

                // Set default Content-Type if not provided and body exists
                <span class="cov0" title="0">if reqBody != nil &amp;&amp; req.Header.Get("Content-Type") == "" </span><span class="cov0" title="0">{
                        req.Header.Set("Content-Type", "application/json")
                }</span>

                // Execute request
                <span class="cov0" title="0">resp, err := client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("request failed: %w", err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                // Read response body
                respBody, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read response: %w", err)
                }</span>

                // Try to parse as JSON, fallback to string
                <span class="cov0" title="0">var parsedBody interface{}
                if err := json.Unmarshal(respBody, &amp;parsedBody); err != nil </span><span class="cov0" title="0">{
                        // Not JSON, return as string
                        parsedBody = string(respBody)
                }</span>

                // Build response
                <span class="cov0" title="0">response := map[string]interface{}{
                        "status":  resp.StatusCode,
                        "body":    parsedBody,
                        "headers": make(map[string]string),
                }

                // Copy response headers
                for key, values := range resp.Header </span><span class="cov0" title="0">{
                        if len(values) &gt; 0 </span><span class="cov0" title="0">{
                                response["headers"].(map[string]string)[key] = values[0]
                        }</span>
                }

                <span class="cov0" title="0">return response, nil</span>
        })

        // Scope get callback
        <span class="cov0" title="0">pm.SetHostCallback("scope_get", func(ctx context.Context, key string) (interface{}, error) </span><span class="cov0" title="0">{
                scope, ok := ctx.Value("scope").(*engine.Scope)
                if !ok || scope == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scope access not available in this context")
                }</span>

                <span class="cov0" title="0">val, found := scope.Get(key)
                if !found </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("variable $%s not found", key)
                }</span>
                <span class="cov0" title="0">return val, nil</span>
        })

        // Scope set callback
        <span class="cov0" title="0">pm.SetHostCallback("scope_set", func(ctx context.Context, key string, value interface{}) error </span><span class="cov0" title="0">{
                scope, ok := ctx.Value("scope").(*engine.Scope)
                if !ok || scope == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("scope access not available in this context")
                }</span>

                <span class="cov0" title="0">scope.Set(key, value)
                return nil</span>
        })

        // File read callback
        <span class="cov0" title="0">pm.SetHostCallback("file_read", func(ctx context.Context, path string) (string, error) </span><span class="cov0" title="0">{
                // Clean and validate path
                cleanPath := filepath.Clean(path)
                
                // Check if path is absolute or tries to escape
                if filepath.IsAbs(cleanPath) || strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("absolute paths and parent directory access not allowed")
                }</span>
                
                // Read file
                <span class="cov0" title="0">content, err := os.ReadFile(cleanPath)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to read file: %w", err)
                }</span>
                
                <span class="cov0" title="0">return string(content), nil</span>
        })

        // File write callback
        <span class="cov0" title="0">pm.SetHostCallback("file_write", func(ctx context.Context, path, content string) error </span><span class="cov0" title="0">{
                // Clean and validate path
                cleanPath := filepath.Clean(path)
                
                // Check if path is absolute or tries to escape
                if filepath.IsAbs(cleanPath) || strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                        return fmt.Errorf("absolute paths and parent directory access not allowed")
                }</span>
                
                // Write file
                <span class="cov0" title="0">if err := os.WriteFile(cleanPath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write file: %w", err)
                }</span>
                
                <span class="cov0" title="0">return nil</span>
        })

        // Environment variable callback
        <span class="cov0" title="0">pm.SetHostCallback("env_get", func(ctx context.Context, key string) string </span><span class="cov0" title="0">{
                return os.Getenv(key)
        }</span>)
}

// executePluginSlot executes a plugin slot (WASM or Sidecar)
func executePluginSlot(ctx context.Context, pm *wasm.PluginManager, pluginName, slotName string, node *engine.Node, scope *engine.Scope) error <span class="cov0" title="0">{
        // Inject plugin name into context for permission checking in host functions
        ctx = context.WithValue(ctx, "pluginName", pluginName)

        // Parse parameters from node
        params := make(map[string]interface{})

        // Add node value as main parameter if present
        if node.Value != nil </span><span class="cov0" title="0">{
                params["value"] = node.Value
        }</span>

        // [NEW] DEEP SCOPE INJECTION
        // Inject current scope into parameters for better PHP context
        <span class="cov0" title="0">params["_zeno_scope"] = scope.ToMap()

        // Add children as parameters
        for _, child := range node.Children </span><span class="cov0" title="0">{
                var value interface{}
                
                if child.Value != nil </span><span class="cov0" title="0">{
                        // Try to preserve numeric types
                        valStr := fmt.Sprintf("%v", child.Value)
                        
                        // Try parsing as float
                        if f, err := strconv.ParseFloat(valStr, 64); err == nil </span><span class="cov0" title="0">{
                                value = f
                        }</span> else<span class="cov0" title="0"> if b, err := strconv.ParseBool(valStr); err == nil </span><span class="cov0" title="0">{
                                // Try parsing as bool
                                value = b
                        }</span> else<span class="cov0" title="0"> {
                                // Keep as string
                                value = child.Value
                        }</span>
                } else<span class="cov0" title="0"> if len(child.Children) &gt; 0 </span><span class="cov0" title="0">{
                        // Handle nested objects
                        value = parseNodeValue(child, scope)
                }</span>
                
                <span class="cov0" title="0">if value != nil </span><span class="cov0" title="0">{
                        params[child.Name] = value
                }</span>
        }

        // [NEW] ASYNC EXECUTION SUPPORT
        <span class="cov0" title="0">isAsync, _ := params["async"].(bool)
        if isAsync </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        _, _ = pm.ExecuteSlot(ctx, pluginName, slotName, params)
                        // Note: result is ignored for fire-and-forget async
                }</span>()
                <span class="cov0" title="0">return nil</span>
        }

        // Execute plugin slot (Synchronous)
        <span class="cov0" title="0">response, err := pm.ExecuteSlot(ctx, pluginName, slotName, params)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("plugin execution failed: %w", err)
        }</span>

        <span class="cov0" title="0">if !response.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("plugin error: %s", response.Error)
        }</span>

        // Store response data in scope
        <span class="cov0" title="0">if response.Data != nil </span><span class="cov0" title="0">{
                for key, value := range response.Data </span><span class="cov0" title="0">{
                        scope.Set(key, value)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// convertInputMeta converts WASM InputMeta to engine.InputMeta
func convertInputMeta(inputs map[string]wasm.InputMeta) map[string]engine.InputMeta <span class="cov8" title="1">{
        result := make(map[string]engine.InputMeta)
        for key, input := range inputs </span><span class="cov8" title="1">{
                result[key] = engine.InputMeta{
                        Type:        input.Type,
                        Required:    input.Required,
                        Description: input.Description,
                }
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package slots

import (
        "context"
        "database/sql"
        "fmt"
        "reflect"
        "strings"
        "zeno/pkg/dbmanager"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

// SQLExecutor interface
type SQLExecutor interface {
        ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
        QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
        QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
}

func getExecutor(scope *engine.Scope, dbMgr *dbmanager.DBManager, dbName string) (SQLExecutor, dbmanager.Dialect, error) <span class="cov8" title="1">{
        if val, ok := scope.Get("_active_tx"); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                if tx, ok := val.(*sql.Tx); ok </span><span class="cov8" title="1">{
                        // [IMPORTANT] Transaction also needs dialect.
                        // For now, we assume it's the default database dialect if not specified.
                        return tx, dbMgr.GetDialect(dbName), nil
                }</span>
        }
        <span class="cov8" title="1">db := dbMgr.GetConnection(dbName)
        dialect := dbMgr.GetDialect(dbName)
        if db == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("database connection '%s' not found", dbName)
        }</span>
        <span class="cov8" title="1">return db, dialect, nil</span>
}

type WhereCond struct {
        Logical string // "AND" or "OR"
        Column  string
        Op      string
        Value   interface{}
}

type JoinDef struct {
        Type  string // "INNER", "LEFT", "RIGHT"
        Table string
        On    []string // ["t1.col", "=", "t2.col"]
}

type QueryState struct {
        Table   string
        Columns []string
        Joins   []JoinDef
        Where   []WhereCond
        GroupBy []string
        Having  []WhereCond
        Args    []interface{}
        Limit   int
        Offset  int
        OrderBy string
        DBName  string
        Dialect dbmanager.Dialect
}

func (qs *QueryState) Quote(name string) string <span class="cov8" title="1">{
        if strings.Contains(name, " ") || strings.Contains(name, "(") </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">if strings.Contains(name, ".") </span><span class="cov8" title="1">{
                parts := strings.Split(name, ".")
                for i, p := range parts </span><span class="cov8" title="1">{
                        parts[i] = qs.Dialect.QuoteIdentifier(p)
                }</span>
                <span class="cov8" title="1">return strings.Join(parts, ".")</span>
        }
        <span class="cov8" title="1">return qs.Dialect.QuoteIdentifier(name)</span>
}

func (qs *QueryState) BuildSQL(queryType string) (string, []interface{}) <span class="cov8" title="1">{
        var sb strings.Builder
        var args []interface{}

        // 1. SELECT
        if queryType == "SELECT" </span><span class="cov8" title="1">{
                sb.WriteString("SELECT ")
                if len(qs.Columns) &gt; 0 </span><span class="cov8" title="1">{
                        quotedCols := make([]string, len(qs.Columns))
                        for i, c := range qs.Columns </span><span class="cov8" title="1">{
                                quotedCols[i] = qs.Quote(c)
                        }</span>
                        <span class="cov8" title="1">sb.WriteString(strings.Join(quotedCols, ", "))</span>
                } else<span class="cov8" title="1"> {
                        sb.WriteString("*")
                }</span>
        } else<span class="cov8" title="1"> if queryType == "COUNT" </span><span class="cov8" title="1">{
                sb.WriteString("SELECT COUNT(*)")
        }</span> else<span class="cov8" title="1"> if queryType == "DELETE" </span><span class="cov8" title="1">{
                sb.WriteString("DELETE")
        }</span>

        // 2. FROM
        <span class="cov8" title="1">sb.WriteString(" FROM ")
        sb.WriteString(qs.Dialect.QuoteIdentifier(qs.Table))

        // 3. JOINS
        for _, join := range qs.Joins </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf(" %s JOIN %s ON %s %s %s",
                        join.Type,
                        qs.Quote(join.Table),
                        qs.Quote(join.On[0]),
                        join.On[1],
                        qs.Quote(join.On[2]),
                ))
        }</span>

        // 4. WHERE
        <span class="cov8" title="1">if len(qs.Where) &gt; 0 </span><span class="cov8" title="1">{
                sb.WriteString(" WHERE ")
                for i, cond := range qs.Where </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                logical := cond.Logical
                                if logical == "" </span><span class="cov0" title="0">{
                                        logical = "AND"
                                }</span>
                                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf(" %s ", logical))</span>
                        }
                        // Handle IN / NOT IN
                        <span class="cov8" title="1">if strings.ToUpper(cond.Op) == "IN" || strings.ToUpper(cond.Op) == "NOT IN" </span><span class="cov8" title="1">{
                                // Expect Value to be slice
                                v := reflect.ValueOf(cond.Value)
                                var slice []interface{}
                                if v.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                                        for k := 0; k &lt; v.Len(); k++ </span><span class="cov8" title="1">{
                                                slice = append(slice, v.Index(k).Interface())
                                        }</span>
                                } else<span class="cov0" title="0"> if str, ok := cond.Value.(string); ok &amp;&amp; strings.HasPrefix(strings.TrimSpace(str), "[") </span><span class="cov0" title="0">{
                                        content := strings.TrimSpace(str)
                                        content = strings.TrimPrefix(content, "[")
                                        content = strings.TrimSuffix(content, "]")
                                        parts := strings.Split(content, ",")
                                        for _, p := range parts </span><span class="cov0" title="0">{
                                                slice = append(slice, strings.TrimSpace(p))
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // Fallback if single value
                                        slice = []interface{}{cond.Value}
                                }</span>

                                <span class="cov8" title="1">placeholders := make([]string, len(slice))
                                for j := range slice </span><span class="cov8" title="1">{
                                        placeholders[j] = qs.Dialect.Placeholder(len(args) + 1)
                                        args = append(args, slice[j])
                                }</span>
                                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%s %s (%s)",
                                        qs.Quote(cond.Column),
                                        cond.Op,
                                        strings.Join(placeholders, ", "),
                                ))</span>
                        } else<span class="cov8" title="1"> if strings.ToUpper(cond.Op) == "BETWEEN" || strings.ToUpper(cond.Op) == "NOT BETWEEN" </span><span class="cov8" title="1">{
                                // Expect Value to be slice of 2 items
                                v := reflect.ValueOf(cond.Value)
                                var val1, val2 interface{}

                                if v.Kind() == reflect.Slice &amp;&amp; v.Len() &gt;= 2 </span><span class="cov8" title="1">{
                                        val1 = v.Index(0).Interface()
                                        val2 = v.Index(1).Interface()
                                }</span> else<span class="cov8" title="1"> if str, ok := cond.Value.(string); ok &amp;&amp; strings.HasPrefix(strings.TrimSpace(str), "[") </span><span class="cov8" title="1">{
                                        content := strings.TrimSpace(str)
                                        content = strings.TrimPrefix(content, "[")
                                        content = strings.TrimSuffix(content, "]")
                                        parts := strings.Split(content, ",")
                                        if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                                                val1 = strings.TrimSpace(parts[0])
                                                val2 = strings.TrimSpace(parts[1])
                                        }</span>
                                }

                                // Apply bound values if valid
                                <span class="cov8" title="1">if val1 != nil &amp;&amp; val2 != nil </span><span class="cov8" title="1">{
                                        p1 := qs.Dialect.Placeholder(len(args) + 1)
                                        args = append(args, val1)
                                        p2 := qs.Dialect.Placeholder(len(args) + 1)
                                        args = append(args, val2)

                                        sb.WriteString(fmt.Sprintf("%s %s %s AND %s",
                                                qs.Quote(cond.Column),
                                                cond.Op,
                                                p1,
                                                p2,
                                        ))
                                }</span>
                        } else<span class="cov8" title="1"> if strings.ToUpper(cond.Op) == "NULL" </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("%s IS NULL", qs.Quote(cond.Column)))
                        }</span> else<span class="cov8" title="1"> if strings.ToUpper(cond.Op) == "NOT NULL" </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("%s IS NOT NULL", qs.Quote(cond.Column)))
                        }</span> else<span class="cov8" title="1"> {
                                sb.WriteString(fmt.Sprintf("%s %s %s",
                                        qs.Quote(cond.Column),
                                        cond.Op,
                                        qs.Dialect.Placeholder(len(args)+1)))
                                args = append(args, cond.Value)
                        }</span>
                }
        }

        // 5. GROUP BY
        <span class="cov8" title="1">if len(qs.GroupBy) &gt; 0 </span><span class="cov8" title="1">{
                sb.WriteString(" GROUP BY ")
                quotedGB := make([]string, len(qs.GroupBy))
                for i, c := range qs.GroupBy </span><span class="cov8" title="1">{
                        quotedGB[i] = qs.Quote(c)
                }</span>
                <span class="cov8" title="1">sb.WriteString(strings.Join(quotedGB, ", "))</span>
        }

        // 6. HAVING
        <span class="cov8" title="1">if len(qs.Having) &gt; 0 </span><span class="cov8" title="1">{
                sb.WriteString(" HAVING ")
                for i, cond := range qs.Having </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                sb.WriteString(" AND ")
                        }</span>
                        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%s %s %s",
                                qs.Quote(cond.Column),
                                cond.Op,
                                qs.Dialect.Placeholder(len(args)+1)))
                        args = append(args, cond.Value)</span>
                }
        }

        // 7. ORDER BY
        <span class="cov8" title="1">if qs.OrderBy != "" </span><span class="cov0" title="0">{
                sb.WriteString(" ORDER BY " + qs.OrderBy)
        }</span>

        // 8. LIMIT / OFFSET (Handled by Dialect, but appended here for non-delete)
        <span class="cov8" title="1">if queryType != "DELETE" &amp;&amp; queryType != "COUNT" </span><span class="cov8" title="1">{ // COUNT typically ignores limit
                sb.WriteString(qs.Dialect.Limit(qs.Limit, qs.Offset))
        }</span>

        <span class="cov8" title="1">return sb.String(), args</span>
}

func RegisterDBSlots(eng *engine.Engine, dbMgr *dbmanager.DBManager) <span class="cov8" title="1">{

        // DB.QUERY (Fluent Block-Style Builder)
        eng.Register("db.query", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // Main value: db.query: 'users' (table name)
                tableName := coerce.ToString(resolveValue(node.Value, scope))
                dbName := "default"

                // Cari nama opsional dan db di anak level atas
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "table" || c.Name == "name" </span><span class="cov0" title="0">{
                                tableName = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "db" </span><span class="cov0" title="0">{
                                dbName = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                <span class="cov8" title="1">dialect := dbMgr.GetDialect(dbName)

                // Create a local inner scope for this entire query building process
                // So "_query_state" doesn't leak into the global scope
                innerScope := engine.NewScope(scope)
                innerScope.Set("_query_state", &amp;QueryState{
                        Table:   tableName,
                        DBName:  dbName,
                        Dialect: dialect,
                })

                // Execute all children instructions inside the query block
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        // Skip basic configuration keys to avoid executing them as slots
                        if c.Name == "table" || c.Name == "name" || c.Name == "db" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // We dynamically adjust child names to append "db." prefix if missing
                        // Example: where { ... } becomes db.where { ... } in the engine's perspective
                        <span class="cov8" title="1">callName := c.Name
                        if !strings.HasPrefix(callName, "db.") </span><span class="cov8" title="1">{
                                callName = "db." + callName
                        }</span>

                        // Mock a node call for execution
                        <span class="cov8" title="1">callNode := &amp;engine.Node{
                                Name:     callName,
                                Value:    c.Value,
                                Children: c.Children,
                                Line:     c.Line,
                                Col:      c.Col,
                                Filename: c.Filename,
                        }

                        if err := eng.Execute(ctx, callNode, innerScope); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "A fluent block wrapper for constructing and executing a query on a specific table.",
                Example:     "db.query: 'users' {\n  where: { col: 'status', val: 'active' }\n  get: { as: $users }\n}",
        })

        // DB.TABLE
        <span class="cov8" title="1">eng.Register("db.table", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                // Main value: db.table: "users" (or $tablename)
                tableName := coerce.ToString(resolveValue(node.Value, scope))
                dbName := "default"

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "name" </span><span class="cov0" title="0">{
                                tableName = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "db" </span><span class="cov0" title="0">{
                                dbName = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }
                <span class="cov0" title="0">dialect := dbMgr.GetDialect(dbName)
                scope.Set("_query_state", &amp;QueryState{
                        Table:   tableName,
                        DBName:  dbName,
                        Dialect: dialect,
                })
                return nil</span>
        }, engine.SlotMeta{
                Description: "Set the table to be used for subsequent database operations.",
                Example:     "db.table: 'users'",
                Inputs: map[string]engine.InputMeta{
                        "name": {Description: "Table name (Optional if specified in main value)", Required: false},
                        "db":   {Description: "Database connection name (Default: 'default')", Required: false},
                },
        })

        // DB.COLUMNS (Select specific columns)
        <span class="cov8" title="1">eng.Register("db.columns", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)

                var cols []string
                // Check explicit columns list passed as value
                if node.Value != nil </span><span class="cov0" title="0">{
                        val := resolveValue(node.Value, scope)
                        v := reflect.ValueOf(val)
                        if v.Kind() == reflect.Slice </span><span class="cov0" title="0">{
                                for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                                        cols = append(cols, coerce.ToString(v.Index(i).Interface()))
                                }</span>
                        } else<span class="cov0" title="0"> if str, ok := val.(string); ok &amp;&amp; strings.HasPrefix(strings.TrimSpace(str), "[") </span><span class="cov0" title="0">{
                                // Fallback: Parse string representation "[ a, b ]"
                                content := strings.TrimSpace(str)
                                content = strings.TrimPrefix(content, "[")
                                content = strings.TrimSuffix(content, "]")
                                parts := strings.Split(content, ",")
                                for _, p := range parts </span><span class="cov0" title="0">{
                                        cols = append(cols, strings.TrimSpace(p))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cols = append(cols, coerce.ToString(val))
                        }</span>
                }
                // Also children
                <span class="cov0" title="0">for _, c := range node.Children </span><span class="cov0" title="0">{
                        cols = append(cols, coerce.ToString(parseNodeValue(c, scope)))
                }</span>
                <span class="cov0" title="0">qs.Columns = cols
                return nil</span>
        }, engine.SlotMeta{Example: "db.columns: ['id', 'name']"})

        // DB.JOIN / LEFT_JOIN
        <span class="cov8" title="1">joinHandler := func(joinType string) func(context.Context, *engine.Node, *engine.Scope) error </span><span class="cov8" title="1">{
                return func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                        qsVal, ok := scope.Get("_query_state")
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("db.join called without db.table")
                        }</span>
                        <span class="cov0" title="0">qs := qsVal.(*QueryState)

                        table := ""
                        var on []string

                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "table" </span><span class="cov0" title="0">{
                                        table = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                                <span class="cov0" title="0">if c.Name == "on" </span><span class="cov0" title="0">{
                                        val := parseNodeValue(c, scope)
                                        // Universal list handling
                                        var parts []string
                                        v := reflect.ValueOf(val)
                                        if v.Kind() == reflect.Slice </span><span class="cov0" title="0">{
                                                for k := 0; k &lt; v.Len(); k++ </span><span class="cov0" title="0">{
                                                        parts = append(parts, coerce.ToString(v.Index(k).Interface()))
                                                }</span>
                                        } else<span class="cov0" title="0"> if str, ok := val.(string); ok &amp;&amp; strings.HasPrefix(strings.TrimSpace(str), "[") </span><span class="cov0" title="0">{
                                                content := strings.TrimSpace(str)
                                                content = strings.TrimPrefix(content, "[")
                                                content = strings.TrimSuffix(content, "]")
                                                rawParts := strings.Split(content, ",")
                                                for _, p := range rawParts </span><span class="cov0" title="0">{
                                                        parts = append(parts, strings.TrimSpace(p))
                                                }</span>
                                        }

                                        <span class="cov0" title="0">if len(parts) == 3 </span><span class="cov0" title="0">{
                                                on = parts
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">if table != "" &amp;&amp; len(on) == 3 </span><span class="cov0" title="0">{
                                qs.Joins = append(qs.Joins, JoinDef{Type: joinType, Table: table, On: on})
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }
        <span class="cov8" title="1">eng.Register("db.join", joinHandler("INNER"), engine.SlotMeta{Example: "db.join {\n  table: posts\n  on: ['users.id', '=', 'posts.user_id']\n}"})
        eng.Register("db.left_join", joinHandler("LEFT"), engine.SlotMeta{Example: "db.left_join ..."})
        eng.Register("db.right_join", joinHandler("RIGHT"), engine.SlotMeta{})

        // DB.WHERE_IN
        eng.Register("db.where_in", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)

                col := ""
                var val interface{}

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "col" </span><span class="cov0" title="0">{
                                col = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "val" </span><span class="cov0" title="0">{
                                val = parseNodeValue(c, scope)
                        }</span>
                }

                <span class="cov0" title="0">if col != "" &amp;&amp; val != nil </span><span class="cov0" title="0">{
                        qs.Where = append(qs.Where, WhereCond{Column: col, Op: "IN", Value: val})
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{Example: "db.where_in {\n  col: id\n  val: [1, 2, 3]\n}"})

        // DB.WHERE_NULL
        <span class="cov8" title="1">eng.Register("db.where_null", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)
                col := coerce.ToString(resolveValue(node.Value, scope))
                if col != "" </span><span class="cov0" title="0">{
                        qs.Where = append(qs.Where, WhereCond{Column: col, Op: "NULL", Value: nil})
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{Example: "db.where_null: deleted_at"})

        // DB.WHERE_NOT_NULL
        <span class="cov8" title="1">eng.Register("db.where_not_null", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)
                col := coerce.ToString(resolveValue(node.Value, scope))
                if col != "" </span><span class="cov0" title="0">{
                        qs.Where = append(qs.Where, WhereCond{Column: col, Op: "NOT NULL", Value: nil})
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{Example: "db.where_not_null: created_at"})

        // DB.WHERE_NOT_IN
        <span class="cov8" title="1">eng.Register("db.where_not_in", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)

                col := ""
                var val interface{}

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "col" </span><span class="cov0" title="0">{
                                col = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "val" </span><span class="cov0" title="0">{
                                val = parseNodeValue(c, scope)
                        }</span>
                }

                <span class="cov0" title="0">if col != "" &amp;&amp; val != nil </span><span class="cov0" title="0">{
                        qs.Where = append(qs.Where, WhereCond{Column: col, Op: "NOT IN", Value: val})
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{Example: "db.where_not_in {\n  col: status\n  val: ['archived', 'deleted']\n}"})

        // DB.GROUP_BY
        <span class="cov8" title="1">eng.Register("db.group_by", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)

                if node.Value != nil </span><span class="cov0" title="0">{
                        qs.GroupBy = append(qs.GroupBy, coerce.ToString(resolveValue(node.Value, scope)))
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{Example: "db.group_by: 'status'"})

        // DB.HAVING
        <span class="cov8" title="1">eng.Register("db.having", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)

                col, op := "", "&gt;"
                var val interface{}

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "col" </span><span class="cov0" title="0">{
                                col = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "op" </span><span class="cov0" title="0">{
                                op = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "val" </span><span class="cov0" title="0">{
                                val = parseNodeValue(c, scope)
                        }</span>
                }
                <span class="cov0" title="0">if col != "" </span><span class="cov0" title="0">{
                        qs.Having = append(qs.Having, WhereCond{Column: col, Op: op, Value: val})
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{Example: "db.having {\n  col: count\n  op: '&gt;'\n  val: 5\n}"})

        // DB.WHERE
        <span class="cov8" title="1">eng.Register("db.where", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.where called without db.table")
                }</span>
                <span class="cov8" title="1">qs := qsVal.(*QueryState)

                col := ""
                op := "="
                var val interface{}

                if len(node.Children) &gt; 0 </span><span class="cov8" title="1">{
                        for _, c := range node.Children </span><span class="cov8" title="1">{
                                if c.Name == "col" </span><span class="cov8" title="1">{
                                        // [STANDARDIZATION] Use parseNodeValue so quotes are stripped &amp; variables supported
                                        col = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                                <span class="cov8" title="1">if c.Name == "op" </span><span class="cov0" title="0">{
                                        // [STANDARDIZATION] Same, so op: "LIKE" and op: LIKE are both valid
                                        op = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                                <span class="cov8" title="1">if c.Name == "val" </span><span class="cov0" title="0">{
                                        val = parseNodeValue(c, scope)
                                }</span>
                        }
                }

                <span class="cov8" title="1">if col != "" </span><span class="cov8" title="1">{
                        qs.Where = append(qs.Where, WhereCond{Logical: "AND", Column: col, Op: op, Value: val})
                        qs.Args = append(qs.Args, val)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Add a WHERE filter to the query.",
                Example:     "db.where\n  col: id\n  val: $user_id",
                Inputs: map[string]engine.InputMeta{
                        "col": {Description: "Column name", Required: false},
                        "op":  {Description: "Operator (Default: '=')", Required: false},
                        "val": {Description: "Filter value", Required: false},
                },
        })

        // DB.OR_WHERE
        <span class="cov8" title="1">eng.Register("db.or_where", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.or_where called without db.table")
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)

                col := ""
                op := "="
                var val interface{}

                if len(node.Children) &gt; 0 </span><span class="cov0" title="0">{
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "col" </span><span class="cov0" title="0">{
                                        col = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                                <span class="cov0" title="0">if c.Name == "op" </span><span class="cov0" title="0">{
                                        op = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                                <span class="cov0" title="0">if c.Name == "val" </span><span class="cov0" title="0">{
                                        val = parseNodeValue(c, scope)
                                }</span>
                        }
                }

                <span class="cov0" title="0">if col != "" </span><span class="cov0" title="0">{
                        qs.Where = append(qs.Where, WhereCond{Logical: "OR", Column: col, Op: op, Value: val})
                        qs.Args = append(qs.Args, val)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Add an OR WHERE filter to the query.",
                Example:     "db.or_where\n  col: role\n  val: 'admin'",
        })

        // DB.WHERE_BETWEEN
        <span class="cov8" title="1">eng.Register("db.where_between", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.where_between called without db.table")
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)

                col := ""
                var val interface{}

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "col" </span><span class="cov0" title="0">{
                                col = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "val" </span><span class="cov0" title="0">{
                                val = parseNodeValue(c, scope)
                        }</span>
                }

                <span class="cov0" title="0">if col != "" &amp;&amp; val != nil </span><span class="cov0" title="0">{
                        qs.Where = append(qs.Where, WhereCond{Logical: "AND", Column: col, Op: "BETWEEN", Value: val})
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Add a WHERE BETWEEN filter to the query.",
                Example:     "db.where_between\n  col: age\n  val: [18, 30]",
        })

        // DB.WHERE_NOT_BETWEEN
        <span class="cov8" title="1">eng.Register("db.where_not_between", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.where_not_between called without db.table")
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)

                col := ""
                var val interface{}

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "col" </span><span class="cov0" title="0">{
                                col = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "val" </span><span class="cov0" title="0">{
                                val = parseNodeValue(c, scope)
                        }</span>
                }

                <span class="cov0" title="0">if col != "" &amp;&amp; val != nil </span><span class="cov0" title="0">{
                        qs.Where = append(qs.Where, WhereCond{Logical: "AND", Column: col, Op: "NOT BETWEEN", Value: val})
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Add a WHERE NOT BETWEEN filter to the query.",
                Example:     "db.where_not_between\n  col: age\n  val: [18, 30]",
        })

        // DB.ORDER_BY
        <span class="cov8" title="1">eng.Register("db.order_by", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)

                // [STANDARISASI] Support variable ($sort) dan auto-clean quotes
                if node.Value != nil </span><span class="cov0" title="0">{
                        qs.OrderBy = coerce.ToString(resolveValue(node.Value, scope))
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{Example: "db.order_by: 'id DESC'"})

        // DB.LIMIT
        <span class="cov8" title="1">eng.Register("db.limit", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">qs := qsVal.(*QueryState)

                val := resolveValue(node.Value, scope)
                limit, _ := coerce.ToInt(val)
                qs.Limit = limit
                return nil</span>
        }, engine.SlotMeta{Example: "db.limit: $limit"})

        // DB.OFFSET
        <span class="cov8" title="1">eng.Register("db.offset", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)

                val := resolveValue(node.Value, scope)
                offset, _ := coerce.ToInt(val)
                qs.Offset = offset
                return nil</span>
        }, engine.SlotMeta{Example: "db.offset: $offset"})

        // =========================================================================
        // EXECUTION SLOTS
        // =========================================================================

        // DB.GET
        <span class="cov8" title="1">eng.Register("db.get", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.get called without db.table")
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)
                target := "rows"

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                // Use BuildSQL
                <span class="cov0" title="0">query, args := qs.BuildSQL("SELECT")

                executor, _, err := getExecutor(scope, dbMgr, qs.DBName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">rows, err := executor.QueryContext(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                cols, _ := rows.Columns()
                var results []map[string]interface{}

                for rows.Next() </span><span class="cov0" title="0">{
                        columns := make([]interface{}, len(cols))
                        columnPointers := make([]interface{}, len(cols))
                        for i := range columns </span><span class="cov0" title="0">{
                                columnPointers[i] = &amp;columns[i]
                        }</span>
                        <span class="cov0" title="0">if err := rows.Scan(columnPointers...); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">m := make(map[string]interface{})
                        for i, colName := range cols </span><span class="cov0" title="0">{
                                val := columns[i]
                                b, ok := val.([]byte)
                                if ok </span><span class="cov0" title="0">{
                                        m[colName] = string(b)
                                }</span> else<span class="cov0" title="0"> {
                                        m[colName] = val
                                }</span>
                        }
                        <span class="cov0" title="0">results = append(results, m)</span>
                }

                <span class="cov0" title="0">scope.Set(target, results)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Retrieve multiple rows from the database based on the current query state.",
                Example:     "db.get\n  as: $users",
                Inputs: map[string]engine.InputMeta{
                        "as": {Description: "Variable name to store results", Required: true},
                },
        })

        // DB.FIRST
        <span class="cov8" title="1">eng.Register("db.first", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.first called without db.table")
                }</span>
                <span class="cov8" title="1">qs := qsVal.(*QueryState)
                target := "row"
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                // Use BuildSQL
                // LIMIT 1 handling by dialect inside BuildSQL is tricky if we pass raw SELECT
                // We can override limit in state temporarily
                <span class="cov8" title="1">oldLimit := qs.Limit
                qs.Limit = 1
                query, args := qs.BuildSQL("SELECT")
                qs.Limit = oldLimit // Restore

                executor, _, err := getExecutor(scope, dbMgr, qs.DBName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">rows, err := executor.QueryContext(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer rows.Close()

                cols, _ := rows.Columns()
                if rows.Next() </span><span class="cov8" title="1">{
                        columns := make([]interface{}, len(cols))
                        columnPointers := make([]interface{}, len(cols))
                        for i := range columns </span><span class="cov8" title="1">{
                                columnPointers[i] = &amp;columns[i]
                        }</span>
                        <span class="cov8" title="1">rows.Scan(columnPointers...)
                        m := make(map[string]interface{})
                        for i, colName := range cols </span><span class="cov8" title="1">{
                                val := columns[i]
                                b, ok := val.([]byte)
                                if ok </span><span class="cov0" title="0">{
                                        m[colName] = string(b)
                                }</span> else<span class="cov8" title="1"> {
                                        m[colName] = val
                                }</span>
                        }
                        <span class="cov8" title="1">scope.Set(target, m)
                        scope.Set(target+"_found", true)</span>
                } else<span class="cov0" title="0"> {
                        scope.Set(target, nil)
                        scope.Set(target+"_found", false)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Retrieve the first row from the database based on the current query state.",
                Example:     "db.first\n  as: $user",
                Inputs: map[string]engine.InputMeta{
                        "as": {Description: "Variable name to store result", Required: true},
                },
        })

        // DB.INSERT
        <span class="cov8" title="1">eng.Register("db.insert", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.insert called without db.table")
                }</span>
                <span class="cov8" title="1">qs := qsVal.(*QueryState)
                var cols []string
                var vals []interface{}
                var placeholders []string

                for i, c := range node.Children </span><span class="cov8" title="1">{
                        cols = append(cols, qs.Dialect.QuoteIdentifier(c.Name))
                        placeholders = append(placeholders, qs.Dialect.Placeholder(i+1))
                        // Use parseNodeValue to support $variable
                        val := parseNodeValue(c, scope)
                        vals = append(vals, val)
                }</span>
                <span class="cov8" title="1">query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)",
                        qs.Dialect.QuoteIdentifier(qs.Table), strings.Join(cols, ", "), strings.Join(placeholders, ", "))

                executor, dialect, err := getExecutor(scope, dbMgr, qs.DBName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">res, err := executor.ExecContext(ctx, query, vals...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // [IMPORTANT] LastInsertId behavior is dialect-dependent.
                // Some DBs (Postgres) don't support it directly without RETURNING.
                // For now we keep it but it might return 0 or error on some DBs.
                <span class="cov8" title="1">if dialect.Name() != "postgres" </span><span class="cov8" title="1">{
                        id, _ := res.LastInsertId()
                        scope.Set("db_last_id", id)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{Example: "db.insert\n  name: $name"})

        // DB.UPDATE
        <span class="cov8" title="1">eng.Register("db.update", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.update called without db.table")
                }</span>
                <span class="cov8" title="1">qs := qsVal.(*QueryState)
                var sets []string
                var vals []interface{}
                for i, c := range node.Children </span><span class="cov8" title="1">{
                        sets = append(sets, fmt.Sprintf("%s = %s", qs.Dialect.QuoteIdentifier(c.Name), qs.Dialect.Placeholder(i+1)))
                        vals = append(vals, parseNodeValue(c, scope))
                }</span>

                <span class="cov8" title="1">whereClause := ""
                if len(qs.Where) &gt; 0 </span><span class="cov8" title="1">{
                        var whereParts []string
                        baseIdx := len(vals)
                        for i, cond := range qs.Where </span><span class="cov8" title="1">{
                                whereParts = append(whereParts, fmt.Sprintf("%s %s %s",
                                        qs.Dialect.QuoteIdentifier(cond.Column),
                                        cond.Op,
                                        qs.Dialect.Placeholder(baseIdx+i+1)))
                                vals = append(vals, cond.Value)
                        }</span>
                        <span class="cov8" title="1">whereClause = " WHERE " + strings.Join(whereParts, " AND ")</span>
                }

                <span class="cov8" title="1">query := fmt.Sprintf("UPDATE %s SET %s%s", qs.Dialect.QuoteIdentifier(qs.Table), strings.Join(sets, ", "), whereClause)
                executor, _, err := getExecutor(scope, dbMgr, qs.DBName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">_, err = executor.ExecContext(ctx, query, vals...)
                return err</span>
        }, engine.SlotMeta{Example: "db.update\n  status: 'active'"})

        // DB.DELETE
        <span class="cov8" title="1">eng.Register("db.delete", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.delete called without db.table")
                }</span>
                <span class="cov0" title="0">qs := qsVal.(*QueryState)
                target := ""
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                // Use BuildSQL
                <span class="cov0" title="0">query, args := qs.BuildSQL("DELETE")
                executor, _, err := getExecutor(scope, dbMgr, qs.DBName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">res, err := executor.ExecContext(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if target != "" </span><span class="cov0" title="0">{
                        count, _ := res.RowsAffected()
                        scope.Set(target, count)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{Example: "db.delete\n  as: $count"})

        // DB.COUNT
        <span class="cov8" title="1">eng.Register("db.count", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.count called without db.table")
                }</span>
                <span class="cov8" title="1">qs := qsVal.(*QueryState)
                target := "count"
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }
                // Use BuildSQL
                <span class="cov8" title="1">query, args := qs.BuildSQL("COUNT")

                executor, _, err := getExecutor(scope, dbMgr, qs.DBName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">var total int
                err = executor.QueryRowContext(ctx, query, args...).Scan(&amp;total)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">scope.Set(target, total)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Count the number of rows based on the current query state.",
                Example:     "db.count\n  as: $total",
                Inputs: map[string]engine.InputMeta{
                        "as": {Description: "Variable name to store result", Required: true},
                },
        })

        // DB.EXISTS
        <span class="cov8" title="1">eng.Register("db.exists", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.exists called without db.table")
                }</span>
                <span class="cov8" title="1">qs := qsVal.(*QueryState)
                target := "exists"
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">oldLimit := qs.Limit
                qs.Limit = 1
                query, args := qs.BuildSQL("SELECT")
                qs.Limit = oldLimit

                executor, _, err := getExecutor(scope, dbMgr, qs.DBName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">rows, err := executor.QueryContext(ctx, query, args...)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                exists := rows.Next()
                scope.Set(target, exists)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Check if at least one row exists based on the current query state.",
                Example:     "db.exists\n  as: $has_users",
        })

        // DB.DOESNT_EXIST
        <span class="cov8" title="1">eng.Register("db.doesnt_exist", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.doesnt_exist called without db.table")
                }</span>
                <span class="cov8" title="1">qs := qsVal.(*QueryState)
                target := "doesnt_exist"
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">oldLimit := qs.Limit
                qs.Limit = 1
                query, args := qs.BuildSQL("SELECT")
                qs.Limit = oldLimit

                executor, _, err := getExecutor(scope, dbMgr, qs.DBName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">rows, err := executor.QueryContext(ctx, query, args...)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                exists := rows.Next()
                scope.Set(target, !exists)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Check if no rows exist based on the current query state.",
                Example:     "db.doesnt_exist\n  as: $is_empty",
        })

        // AGGREGATE HANDLER GENERATOR
        <span class="cov8" title="1">aggregateHandler := func(funcName string) func(context.Context, *engine.Node, *engine.Scope) error </span><span class="cov8" title="1">{
                return func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                        qsVal, ok := scope.Get("_query_state")
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("db.%s called without db.table", strings.ToLower(funcName))
                        }</span>
                        <span class="cov8" title="1">qs := qsVal.(*QueryState)
                        target := strings.ToLower(funcName)
                        col := "*"

                        if node.Value != nil </span><span class="cov8" title="1">{
                                col = coerce.ToString(resolveValue(node.Value, scope))
                        }</span>

                        <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                                if c.Name == "col" </span><span class="cov0" title="0">{
                                        col = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                                <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                        target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                                }</span>
                        }

                        // We temporarily modify Columns to the aggregate, then switch back
                        <span class="cov8" title="1">oldCols := qs.Columns
                        qs.Columns = []string{fmt.Sprintf("%s(%s)", funcName, qs.Quote(col))}
                        query, args := qs.BuildSQL("SELECT")
                        qs.Columns = oldCols

                        executor, _, err := getExecutor(scope, dbMgr, qs.DBName)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">var result interface{}
                        err = executor.QueryRowContext(ctx, query, args...).Scan(&amp;result)
                        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        // Coerce to proper type based on funcName. sum/min/max usually float or int.
                        <span class="cov0" title="0">b, ok := result.([]byte)
                        if ok </span><span class="cov0" title="0">{
                                result = string(b)
                        }</span>

                        <span class="cov0" title="0">scope.Set(target, result)
                        return nil</span>
                }
        }

        <span class="cov8" title="1">eng.Register("db.sum", aggregateHandler("SUM"), engine.SlotMeta{Example: "db.sum: 'price'\n  as: $total_price"})
        eng.Register("db.avg", aggregateHandler("AVG"), engine.SlotMeta{Example: "db.avg: 'rating'\n  as: $average"})
        eng.Register("db.min", aggregateHandler("MIN"), engine.SlotMeta{Example: "db.min: 'age'\n  as: $youngest"})
        eng.Register("db.max", aggregateHandler("MAX"), engine.SlotMeta{Example: "db.max: 'age'\n  as: $oldest"})

        // DB.PLUCK
        eng.Register("db.pluck", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.pluck called without db.table")
                }</span>
                <span class="cov8" title="1">qs := qsVal.(*QueryState)

                col := ""
                target := "plucks"

                if node.Value != nil </span><span class="cov8" title="1">{
                        col = coerce.ToString(resolveValue(node.Value, scope))
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "col" </span><span class="cov0" title="0">{
                                col = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if col == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.pluck requires a column name")
                }</span>

                // Save old columns
                <span class="cov8" title="1">oldCols := qs.Columns
                qs.Columns = []string{qs.Quote(col)}
                query, args := qs.BuildSQL("SELECT")
                qs.Columns = oldCols

                executor, _, err := getExecutor(scope, dbMgr, qs.DBName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">rows, err := executor.QueryContext(ctx, query, args...)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                var results []interface{}

                for rows.Next() </span><span class="cov0" title="0">{
                        var val interface{}
                        if err := rows.Scan(&amp;val); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">b, ok := val.([]byte)
                        if ok </span><span class="cov0" title="0">{
                                val = string(b)
                        }</span>
                        <span class="cov0" title="0">results = append(results, val)</span>
                }

                <span class="cov0" title="0">scope.Set(target, results)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Retrieve a single column's values as a flat array.",
                Example:     "db.pluck: 'id'\n  as: $user_ids",
        })

        // DB.PAGINATE
        <span class="cov8" title="1">eng.Register("db.paginate", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                qsVal, ok := scope.Get("_query_state")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.paginate called without db.table")
                }</span>
                <span class="cov8" title="1">qs := qsVal.(*QueryState)

                target := "paginator"
                perPage := 15
                page := 1

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "per_page" </span><span class="cov0" title="0">{
                                val, _ := coerce.ToFloat64(parseNodeValue(c, scope))
                                perPage = int(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "page" </span><span class="cov8" title="1">{
                                val, _ := coerce.ToFloat64(parseNodeValue(c, scope))
                                page = int(val)
                        }</span>
                }
                <span class="cov8" title="1">if page &lt; 1 </span><span class="cov8" title="1">{
                        page = 1
                }</span>
                <span class="cov8" title="1">if perPage &lt; 1 </span><span class="cov0" title="0">{
                        perPage = 15
                }</span>

                <span class="cov8" title="1">executor, _, err := getExecutor(scope, dbMgr, qs.DBName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // 1. Get Total Count
                <span class="cov8" title="1">countQuery, countArgs := qs.BuildSQL("COUNT")
                var total int
                err = executor.QueryRowContext(ctx, countQuery, countArgs...).Scan(&amp;total)
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov8" title="1">{
                        return err
                }</span>

                // 2. Compute Pagination Meta
                // We avoid importing math by doing integer arithmetic
                <span class="cov0" title="0">lastPage := (total + perPage - 1) / perPage
                if lastPage &lt; 1 </span><span class="cov0" title="0">{
                        lastPage = 1
                }</span>

                // 3. Set Limit and Offset for actual query
                <span class="cov0" title="0">qs.Limit = perPage
                qs.Offset = (page - 1) * perPage
                query, args := qs.BuildSQL("SELECT")

                rows, err := executor.QueryContext(ctx, query, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                cols, _ := rows.Columns()
                var results []map[string]interface{}

                for rows.Next() </span><span class="cov0" title="0">{
                        columns := make([]interface{}, len(cols))
                        columnPointers := make([]interface{}, len(cols))
                        for i := range columns </span><span class="cov0" title="0">{
                                columnPointers[i] = &amp;columns[i]
                        }</span>
                        <span class="cov0" title="0">if err := rows.Scan(columnPointers...); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">m := make(map[string]interface{})
                        for i, colName := range cols </span><span class="cov0" title="0">{
                                val := columns[i]
                                b, ok := val.([]byte)
                                if ok </span><span class="cov0" title="0">{
                                        m[colName] = string(b)
                                }</span> else<span class="cov0" title="0"> {
                                        m[colName] = val
                                }</span>
                        }
                        <span class="cov0" title="0">results = append(results, m)</span>
                }

                <span class="cov0" title="0">paginator := map[string]interface{}{
                        "data":         results,
                        "total":        total,
                        "per_page":     perPage,
                        "current_page": page,
                        "last_page":    lastPage,
                        "from":         qs.Offset + 1,
                        "to":           qs.Offset + len(results),
                }
                if len(results) == 0 </span><span class="cov0" title="0">{
                        paginator["from"] = 0
                        paginator["to"] = 0
                }</span>

                <span class="cov0" title="0">scope.Set(target, paginator)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Retrieve rows paginated with metadata.",
                Example:     "db.paginate\n  page: 1\n  per_page: 20\n  as: $users_paginator",
        })
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package slots

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "net/http/httputil"
        "net/url"
        "os"
        "path/filepath"
        "strings"
        "time"
        "zeno/pkg/apidoc"
        "zeno/pkg/engine"
        hostPkg "zeno/pkg/host"
        "zeno/pkg/middleware"
        "zeno/pkg/utils/coerce"

        "github.com/go-chi/chi/v5"
)

// Key context untuk menyimpan router instance
type routerKey struct{}

func RegisterRouterSlots(eng *engine.Engine, rootRouter *chi.Mux) <span class="cov8" title="1">{

        // Helper: Ambil router aktif (Root atau Group)
        getCurrentRouter := func(ctx context.Context) chi.Router </span><span class="cov8" title="1">{
                if r, ok := ctx.Value(routerKey{}).(chi.Router); ok </span><span class="cov8" title="1">{
                        return r
                }</span>
                <span class="cov8" title="1">return rootRouter</span>
        }

        // Helper: Membuat Handler (Runtime Execution) - OPTIMIZED (Zero Runtime Overhead)
        // Auth is handled by native Chi middleware, injected via context
        <span class="cov8" title="1">createHandler := func(children []*engine.Node, baseScope *engine.Scope) http.HandlerFunc </span><span class="cov8" title="1">{
                return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // 1. Get Arena from pool for this request
                        arena := engine.GetArena()
                        defer engine.PutArena(arena)

                        // 2. Create Request Scope in the Arena
                        reqScope := arena.AllocScope(baseScope)

                        // 2. Inject URL Params (e.g., /news/{id} -&gt; $id)
                        rctx := chi.RouteContext(r.Context())
                        if rctx != nil &amp;&amp; len(rctx.URLParams.Keys) &gt; 0 </span><span class="cov0" title="0">{
                                params := engine.GetMap()
                                defer engine.PutMap(params)

                                for i, key := range rctx.URLParams.Keys </span><span class="cov0" title="0">{
                                        val := rctx.URLParams.Values[i]
                                        // Set as global scope variable: $id
                                        reqScope.Set(key, val)
                                        // Set also in params map: $params.id
                                        params[key] = val
                                }</span>
                                <span class="cov0" title="0">reqScope.Set("params", params)</span>
                        }

                        // 3. Inject Form Data (POST/PUT)
                        <span class="cov8" title="1">r.ParseMultipartForm(32 &lt;&lt; 20) // 32 MB limit

                        formData := engine.GetMap()
                        defer engine.PutMap(formData)

                        for k, v := range r.Form </span><span class="cov0" title="0">{
                                if len(v) == 1 </span><span class="cov0" title="0">{
                                        formData[k] = v[0]
                                }</span> else<span class="cov0" title="0"> {
                                        formData[k] = v
                                }</span>
                        }

                        <span class="cov8" title="1">reqScope.Set("form", formData)

                        // 4. Parse JSON Body (for API requests)
                        var bodyData map[string]interface{}
                        if r.Method == "POST" || r.Method == "PUT" || r.Method == "PATCH" </span><span class="cov8" title="1">{
                                contentType := r.Header.Get("Content-Type")
                                if strings.Contains(contentType, "application/json") </span><span class="cov8" title="1">{
                                        bodyData = engine.GetMap()
                                        defer engine.PutMap(bodyData)

                                        decoder := json.NewDecoder(r.Body)
                                        if err := decoder.Decode(&amp;bodyData); err == nil </span>{<span class="cov0" title="0">
                                                // Successfully parsed JSON
                                        }</span> else<span class="cov8" title="1"> {
                                                // If JSON parse fails, use empty map
                                                bodyData = make(map[string]interface{})
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        bodyData = make(map[string]interface{})
                                }</span>
                        } else<span class="cov8" title="1"> {
                                bodyData = make(map[string]interface{})
                        }</span>

                        // 5. Build $request object
                        <span class="cov8" title="1">requestObj := engine.GetMap()
                        defer engine.PutMap(requestObj)

                        requestObj["method"] = r.Method
                        requestObj["url"] = r.URL.String()
                        requestObj["path"] = r.URL.Path
                        requestObj["body"] = bodyData

                        // Shortcut variables
                        reqScope.Set("path", r.URL.Path)
                        reqScope.Set("method", r.Method)

                        // Add headers as map
                        headersMap := engine.GetMap()
                        defer engine.PutMap(headersMap)
                        for k, v := range r.Header </span><span class="cov8" title="1">{
                                if len(v) == 1 </span><span class="cov8" title="1">{
                                        headersMap[k] = v[0]
                                }</span> else<span class="cov0" title="0"> {
                                        headersMap[k] = v
                                }</span>
                        }
                        <span class="cov8" title="1">requestObj["headers"] = headersMap

                        // Add query params
                        queryMap := engine.GetMap()
                        defer engine.PutMap(queryMap)

                        for k, v := range r.URL.Query() </span><span class="cov0" title="0">{
                                if len(v) == 1 </span><span class="cov0" title="0">{
                                        queryMap[k] = v[0]
                                }</span> else<span class="cov0" title="0"> {
                                        queryMap[k] = v
                                }</span>
                        }
                        <span class="cov8" title="1">requestObj["query"] = queryMap

                        reqScope.Set("request", requestObj)

                        // 6. Inject HTTP context (for middleware/slots that need it)
                        ctx := context.WithValue(r.Context(), "httpRequest", r)
                        ctx = context.WithValue(ctx, "httpWriter", w)

                        // [NEW] 6.1. Add timeout to prevent infinite loops
                        // Default: 30 seconds, configurable via ZENO_REQUEST_TIMEOUT
                        timeoutStr := os.Getenv("ZENO_REQUEST_TIMEOUT")
                        if timeoutStr == "" </span><span class="cov8" title="1">{
                                timeoutStr = "30s" // Default timeout
                        }</span>
                        <span class="cov8" title="1">timeout, err := time.ParseDuration(timeoutStr)
                        if err != nil </span><span class="cov0" title="0">{
                                timeout = 30 * time.Second // Fallback to 30s if parsing fails
                        }</span>

                        // Create timeout context
                        <span class="cov8" title="1">timeoutCtx, cancel := context.WithTimeout(ctx, timeout)
                        defer cancel()

                        // [NEW] 7. Inject Auth from Chi middleware context to ZenoLang scope
                        // This bridges native Chi middleware (MultiTenantAuth) to ZenoLang scope
                        middleware.InjectAuthToScope(r, reqScope)

                        // 8. Execute Children (Route Logic) - Auth already injected from Chi middleware
                        for _, child := range children </span><span class="cov8" title="1">{
                                if err := eng.Execute(timeoutCtx, child, reqScope); err != nil </span><span class="cov0" title="0">{
                                        // [NEW] Handle ErrReturn (Normal Halt)
                                        if errors.Is(err, ErrReturn) || strings.Contains(err.Error(), "return") </span><span class="cov0" title="0">{
                                                return
                                        }</span>

                                        // Check if error is due to timeout
                                        <span class="cov0" title="0">if timeoutCtx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                                                http.Error(w, fmt.Sprintf("Request timeout exceeded (%s)", timeout), http.StatusRequestTimeout)
                                                return
                                        }</span>
                                        <span class="cov0" title="0">panic(err)</span> // Will be caught by recovery middleware
                                }
                        }
                }
        }

        // Helper: Parse Path dari Node (Standardized)
        <span class="cov8" title="1">getPath := func(node *engine.Node, scope *engine.Scope) string </span><span class="cov8" title="1">{
                path := coerce.ToString(resolveValue(node.Value, scope))
                if path == "" </span><span class="cov0" title="0">{
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "path" || c.Name == "url" </span><span class="cov0" title="0">{
                                        path = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                        }
                }
                <span class="cov8" title="1">return path</span>
        }

        // Helper context for path tracking
        <span class="cov8" title="1">type pathPrefixKey struct{}

        getCurrentPath := func(ctx context.Context) string </span><span class="cov8" title="1">{
                if p, ok := ctx.Value(pathPrefixKey{}).(string); ok </span><span class="cov0" title="0">{
                        return p
                }</span>
                <span class="cov8" title="1">return ""</span>
        }

        <span class="cov8" title="1">joinPath := func(base, sub string) string </span><span class="cov8" title="1">{
                if base == "" </span><span class="cov8" title="1">{
                        return sub
                }</span>
                <span class="cov0" title="0">if base == "/" &amp;&amp; sub == "/" </span><span class="cov0" title="0">{
                        return "/"
                }</span>
                // Remove trailing slash from base
                <span class="cov0" title="0">base = strings.TrimSuffix(base, "/")
                if !strings.HasPrefix(sub, "/") </span><span class="cov0" title="0">{
                        sub = "/" + sub
                }</span>
                <span class="cov0" title="0">return base + sub</span>
        }

        // ==========================================
        // 0. HOST / DOMAIN GROUP
        // ==========================================
        <span class="cov8" title="1">eng.Register("http.host", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                host := coerce.ToString(resolveValue(node.Value, scope))
                if host == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.host: domain/host is required")
                }</span>

                // Create host-specific router
                <span class="cov0" title="0">hostRouter := chi.NewRouter()

                // [AUTOMATIC] Register to Native Host Map (O(1) lookup)
                // This is much faster than linear middleware checks
                hostPkg.GlobalManager.RegisterRouter(host, hostRouter)

                // Logic: Cari 'do'. Jika tidak ada, pakai 'node' itu sendiri (Implicit)
                var childrenToExec []*engine.Node
                var doNode *engine.Node

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "do" </span><span class="cov0" title="0">{
                                doNode = c
                                break</span>
                        }
                }

                <span class="cov0" title="0">if doNode != nil </span><span class="cov0" title="0">{
                        childrenToExec = doNode.Children
                }</span> else<span class="cov0" title="0"> {
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name != "summary" &amp;&amp; c.Name != "desc" </span><span class="cov0" title="0">{
                                        childrenToExec = append(childrenToExec, c)
                                }</span>
                        }
                }

                // Create new context with host-router
                <span class="cov0" title="0">hostCtx := context.WithValue(ctx, routerKey{}, hostRouter)

                // Execute children in host context
                for _, child := range childrenToExec </span><span class="cov0" title="0">{
                        eng.Execute(hostCtx, child, scope)
                }</span>

                <span class="cov0" title="0">fmt.Printf("    [VHOST] Registered domain: %s\n", host)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Mengelompokkan route berdasarkan Domain atau Subdomain tertentu.",
                Example:     "http.host: \"api.zeno.dev\"\n  do:\n    http.get: \"/v1/users\" { ... }",
        })

        // ==========================================
        // 1. ROUTE GROUP (Mendukung Implicit Do)
        // ==========================================
        <span class="cov8" title="1">eng.Register("http.group", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                path := getPath(node, scope)

                // Check if group has middleware
                middlewareName := ""
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "middleware" </span><span class="cov0" title="0">{
                                middlewareName = coerce.ToString(resolveValue(c.Value, scope))
                        }</span>
                }

                // Logic: Cari 'do'. Jika tidak ada, pakai 'node' itu sendiri (Implicit)
                <span class="cov0" title="0">var childrenToExec []*engine.Node
                var doNode *engine.Node

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "do" </span><span class="cov0" title="0">{
                                doNode = c
                                break</span>
                        }
                }

                <span class="cov0" title="0">if doNode != nil </span><span class="cov0" title="0">{
                        childrenToExec = doNode.Children
                }</span> else<span class="cov0" title="0"> {
                        // Implicit Mode: filter out config nodes
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name != "middleware" &amp;&amp; c.Name != "summary" &amp;&amp; c.Name != "desc" </span><span class="cov0" title="0">{
                                        childrenToExec = append(childrenToExec, c)
                                }</span>
                        }
                }

                // Create sub-router
                <span class="cov0" title="0">subRouter := chi.NewRouter()

                // [NEW] Apply native Chi middleware if auth is specified
                if middlewareName == "auth" </span><span class="cov0" title="0">{
                        // Use JWT_SECRET from environment (same as auth controller)
                        jwtSecret := os.Getenv("JWT_SECRET")
                        if jwtSecret == "" </span><span class="cov0" title="0">{
                                // Fallback to .env default
                                jwtSecret = "458127c2cffdd41a448b5d37b825188bf12db10e5c98cb03b681da667ac3b294_pekalongan_kota_2025_!@#_jgn_disebar"
                                fmt.Printf("     Using default JWT_SECRET\n")
                        }</span>
                        <span class="cov0" title="0">subRouter.Use(middleware.MultiTenantAuth(jwtSecret))
                        fmt.Printf("    [GROUP MIDDLEWARE] Applied native Chi auth to group %s\n", path)</span>
                }

                // Mount sub-router
                <span class="cov0" title="0">getCurrentRouter(ctx).Mount(path, subRouter)

                // Create new context with sub-router
                groupCtx := context.WithValue(ctx, routerKey{}, subRouter)

                // Execute children in group context
                for _, child := range childrenToExec </span><span class="cov0" title="0">{
                        eng.Execute(groupCtx, child, scope)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{})

        // ==========================================
        // 2. STANDARD HTTP METHODS (Mendukung Implicit Do)
        // ==========================================
        <span class="cov8" title="1">methods := []string{"GET", "POST", "PUT", "DELETE", "PATCH"}
        for _, method := range methods </span><span class="cov8" title="1">{
                m := method // capture loop var
                eng.Register("http."+strings.ToLower(m), func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                        path := getPath(node, scope)

                        // 2. Metadata Extraction &amp; Clean Children

                        // Resolve Full Path for Documentation
                        fullDocPath := joinPath(getCurrentPath(ctx), path)

                        routeDoc := &amp;apidoc.RouteDoc{
                                Method:    m,
                                Path:      fullDocPath,
                                Responses: make(map[string]apidoc.ResponseDoc),
                        }

                        var doNode *engine.Node
                        var middlewareName string

                        // Scan for Metadata and Logic Container
                        for _, c := range node.Children </span><span class="cov8" title="1">{
                                if c.Name == "do" </span><span class="cov8" title="1">{
                                        doNode = c
                                }</span>

                                // Metadata Extraction
                                <span class="cov8" title="1">if c.Name == "summary" </span><span class="cov0" title="0">{
                                        routeDoc.Summary = coerce.ToString(resolveValue(c.Value, scope))
                                }</span>
                                <span class="cov8" title="1">if c.Name == "desc" || c.Name == "description" </span><span class="cov0" title="0">{
                                        routeDoc.Description = coerce.ToString(resolveValue(c.Value, scope))
                                }</span>
                                <span class="cov8" title="1">if c.Name == "tags" </span><span class="cov0" title="0">{
                                        val := resolveValue(c.Value, scope)
                                        if list, err := coerce.ToSlice(val); err == nil </span><span class="cov0" title="0">{
                                                tags := make([]string, len(list))
                                                for i, v := range list </span><span class="cov0" title="0">{
                                                        tags[i] = coerce.ToString(v)
                                                }</span>
                                                <span class="cov0" title="0">routeDoc.Tags = tags</span>
                                        }
                                }

                                // Capture Middleware (Metadata Level)
                                // Support both: middleware: "auth" AND middleware with parameters as route attributes
                                <span class="cov8" title="1">if c.Name == "middleware" </span><span class="cov0" title="0">{
                                        if c.Value != nil </span><span class="cov0" title="0">{
                                                middlewareName = coerce.ToString(resolveValue(c.Value, scope))
                                        }</span>
                                }

                                // Extract Query Params
                                <span class="cov8" title="1">if c.Name == "query" </span><span class="cov0" title="0">{
                                        if m, ok := parseNodeValue(c, scope).(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                for k, v := range m </span><span class="cov0" title="0">{
                                                        desc := coerce.ToString(v)
                                                        pType := "string"
                                                        required := false

                                                        // Simple syntax parsing: "Description|type|required"
                                                        parts := strings.Split(desc, "|")
                                                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                                                desc = parts[0]
                                                        }</span>
                                                        <span class="cov0" title="0">if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                                                pType = parts[1]
                                                        }</span>
                                                        <span class="cov0" title="0">if strings.Contains(desc, "required") || (len(parts) &gt; 2 &amp;&amp; parts[2] == "required") </span><span class="cov0" title="0">{
                                                                required = true
                                                        }</span>

                                                        <span class="cov0" title="0">routeDoc.Params = append(routeDoc.Params, apidoc.ParamDoc{
                                                                Name:        k,
                                                                In:          "query",
                                                                Description: desc,
                                                                Type:        pType,
                                                                Required:    required,
                                                        })</span>
                                                }
                                        }
                                }

                                // Extract Path Params
                                <span class="cov8" title="1">if c.Name == "params" </span><span class="cov0" title="0">{
                                        if m, ok := parseNodeValue(c, scope).(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                for k, v := range m </span><span class="cov0" title="0">{
                                                        desc := coerce.ToString(v)
                                                        pType := "string"
                                                        // Path params are always required

                                                        parts := strings.Split(desc, "|")
                                                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                                                desc = parts[0]
                                                        }</span>
                                                        <span class="cov0" title="0">if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                                                pType = parts[1]
                                                        }</span>

                                                        <span class="cov0" title="0">routeDoc.Params = append(routeDoc.Params, apidoc.ParamDoc{
                                                                Name:        k,
                                                                In:          "path",
                                                                Description: desc,
                                                                Type:        pType,
                                                                Required:    true,
                                                        })</span>
                                                }
                                        }
                                }
                        }

                        // Prepare execution children (filtering config nodes)
                        <span class="cov8" title="1">var execChildren []*engine.Node
                        if doNode != nil </span><span class="cov8" title="1">{
                                for _, child := range doNode.Children </span><span class="cov8" title="1">{
                                        execChildren = append(execChildren, child)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                for _, child := range node.Children </span><span class="cov0" title="0">{
                                        name := child.Name
                                        if name == "do" || name == "summary" || name == "desc" || name == "tags" || name == "body" || name == "query" || name == "middleware" </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">execChildren = append(execChildren, child)</span>
                                }
                        }

                        // [NEW] Apply Native Chi Middleware using r.With() pattern
                        // This is the idiomatic Go/Chi way for route-specific middleware
                        <span class="cov8" title="1">targetRouter := getCurrentRouter(ctx)

                        if middlewareName == "auth" </span><span class="cov0" title="0">{
                                // Create a new router chain with middleware applied
                                // Use JWT_SECRET from environment (same as auth controller)
                                jwtSecret := os.Getenv("JWT_SECRET")
                                if jwtSecret == "" </span><span class="cov0" title="0">{
                                        // Fallback to .env default
                                        jwtSecret = "458127c2cffdd41a448b5d37b825188bf12db10e5c98cb03b681da667ac3b294_pekalongan_kota_2025_!@#_jgn_disebar"
                                        fmt.Printf("     Using default JWT_SECRET\n")
                                }</span>
                                <span class="cov0" title="0">targetRouter = targetRouter.With(middleware.MultiTenantAuth(jwtSecret))
                                fmt.Printf("    [MIDDLEWARE] Applied native Chi auth via r.With() to %s\n", fullDocPath)</span>
                        }

                        // Register Documentation
                        <span class="cov8" title="1">apidoc.Registry.Register(m, fullDocPath, routeDoc)

                        fmt.Printf("    [ROUTE] %-6s %s\n", m, fullDocPath)

                        // Register route handler on the middleware-enabled router chain
                        targetRouter.MethodFunc(m, path, createHandler(execChildren, scope))
                        return nil</span>
                }, engine.SlotMeta{})
        }

        // ==========================================
        // 3. REVERSE PROXY SLOT (Caddy-Style)
        // ==========================================
        <span class="cov8" title="1">eng.Register("http.proxy", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                targetStr := coerce.ToString(resolveValue(node.Value, scope))
                if targetStr == "" </span><span class="cov0" title="0">{
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "to" || c.Name == "target" </span><span class="cov0" title="0">{
                                        targetStr = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                        }
                }

                <span class="cov0" title="0">if targetStr == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.proxy: target URL is required")
                }</span>

                <span class="cov0" title="0">targetURL, err := url.Parse(targetStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.proxy: invalid target URL: %v", err)
                }</span>

                <span class="cov0" title="0">path := "/"
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "path" </span><span class="cov0" title="0">{
                                path = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                // Create Reverse Proxy
                <span class="cov0" title="0">proxy := httputil.NewSingleHostReverseProxy(targetURL)

                // [OPTIONAL] Customizing the Director to handle headers correctly
                originalDirector := proxy.Director
                proxy.Director = func(req *http.Request) </span><span class="cov0" title="0">{
                        originalDirector(req)
                        req.Host = targetURL.Host // Critical for some backends
                        req.Header.Set("X-Forwarded-Host", req.Header.Get("Host"))
                }</span>

                // Register to router
                <span class="cov0" title="0">getCurrentRouter(ctx).Handle(path+"*", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Strip prefix if not root
                        if path != "/" </span><span class="cov0" title="0">{
                                http.StripPrefix(strings.TrimSuffix(path, "/"), proxy).ServeHTTP(w, r)
                        }</span> else<span class="cov0" title="0"> {
                                proxy.ServeHTTP(w, r)
                        }</span>
                }))

                <span class="cov0" title="0">fmt.Printf("    [PROXY] Registered proxy: %s -&gt; %s\n", path, targetStr)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Meneruskan request ke backend service lain (Reverse Proxy).",
                Example:     "http.proxy: \"http://localhost:8080\"\n  path: \"/api\"",
        })

        // ==========================================
        // 4. STATIC / SPA HOSTING SLOT
        // ==========================================
        <span class="cov8" title="1">eng.Register("http.static", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                root := coerce.ToString(resolveValue(node.Value, scope))
                path := "/"
                isSPA := false

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "root" || c.Name == "dir" </span><span class="cov0" title="0">{
                                root = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "path" </span><span class="cov8" title="1">{
                                path = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "spa" </span><span class="cov8" title="1">{
                                isSPA, _ = coerce.ToBool(parseNodeValue(c, scope))
                        }</span>
                }

                <span class="cov8" title="1">if root == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.static: root directory is required")
                }</span>

                // Ensure path ends with * for Chi wildcard matching
                <span class="cov8" title="1">routePath := path
                if !strings.HasSuffix(routePath, "/") </span><span class="cov8" title="1">{
                        routePath += "/"
                }</span>

                <span class="cov8" title="1">fileServer := http.FileServer(http.Dir(root))

                getCurrentRouter(ctx).Handle(routePath+"*", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // 1. Clean path and check if file exists
                        cleanPath := filepath.Join(root, strings.TrimPrefix(r.URL.Path, path))

                        // [SECURITY] Prevent Path Traversal
                        // Ensure cleanPath is effectively inside root
                        // We use filepath.Rel to check if the path attempts to go above root
                        rel, err := filepath.Rel(root, cleanPath)
                        if err != nil || strings.HasPrefix(rel, "..") </span><span class="cov8" title="1">{
                                // Traversal attempt detected
                                if isSPA </span><span class="cov8" title="1">{
                                        // For SPA, treat traversal as "page not found" -&gt; serve index
                                        // This prevents Oracle attacks (distinguishing files via 404 vs 200)
                                        http.ServeFile(w, r, filepath.Join(root, "index.html"))
                                        return
                                }</span>
                                // For non-SPA, return 404
                                <span class="cov0" title="0">http.NotFound(w, r)
                                return</span>
                        }

                        <span class="cov8" title="1">_, err = os.Stat(cleanPath)

                        // 2. If SPA and file not found, serve index.html
                        if isSPA &amp;&amp; os.IsNotExist(err) </span><span class="cov0" title="0">{
                                http.ServeFile(w, r, filepath.Join(root, "index.html"))
                                return
                        }</span>

                        // 3. Regular file serving
                        <span class="cov8" title="1">if path != "/" </span><span class="cov8" title="1">{
                                http.StripPrefix(strings.TrimSuffix(path, "/"), fileServer).ServeHTTP(w, r)
                        }</span> else<span class="cov0" title="0"> {
                                fileServer.ServeHTTP(w, r)
                        }</span>
                }))

                <span class="cov8" title="1">mode := "Static Site"
                if isSPA </span><span class="cov8" title="1">{
                        mode = "SPA (Single Page App)"
                }</span>
                <span class="cov8" title="1">fmt.Printf("    [STATIC] Registered %s: %s -&gt; %s\n", mode, path, root)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Hosting aplikasi SPA (React/Vue) atau Static Site.",
                Example:     "http.static: \"./dist\"\n  path: \"/\"\n  spa: true",
        })
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package slots

import (
        "context"
        "fmt"
        "strings"
        "zeno/pkg/dbmanager"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

type ColumnDef struct {
        Name          string
        Type          string
        IsPrimary     bool
        IsNullable    bool
        AutoIncrement bool
        DefaultValue  string
}

type TableSchema struct {
        Name    string
        Columns []ColumnDef
}

func RegisterSchemaSlots(eng *engine.Engine, dbMgr *dbmanager.DBManager) <span class="cov8" title="1">{

        // SCHEMA.CREATE: 'table_name' { ... columns ... }
        eng.Register("schema.create", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                tableName := coerce.ToString(resolveValue(node.Value, scope))
                dbName := "default"

                // Target: Collect column definitions from children execution
                schema := &amp;TableSchema{
                        Name: tableName,
                }

                // Set temporary state for column slots to collect data
                oldSchema, hasOld := scope.Get("_schema_draft")
                scope.Set("_schema_draft", schema)
                defer func() </span><span class="cov8" title="1">{
                        if hasOld </span><span class="cov0" title="0">{
                                scope.Set("_schema_draft", oldSchema)
                        }</span> else<span class="cov8" title="1"> {
                                scope.Delete("_schema_draft")
                        }</span>
                }()

                // Execute children to fill schema columns
                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "db" || c.Name == "connection" </span><span class="cov0" title="0">{
                                dbName = coerce.ToString(parseNodeValue(c, scope))
                                continue</span>
                        }
                        // Execute other children (column slots)
                        <span class="cov8" title="1">if err := eng.Execute(ctx, c, scope); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">if schema.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("schema.create: table name is required")
                }</span>

                // Build SQL DDL based on Dialect
                <span class="cov8" title="1">dialect := dbMgr.GetDialect(dbName)
                ddl := buildCreateSQL(schema, dialect)

                // Execute DDL
                executor, _, err := getExecutor(scope, dbMgr, dbName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">_, err = executor.ExecContext(ctx, ddl)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("schema.create error: %v\nSQL: %s", err, ddl)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Create a new database table using fluent schema builder.",
                Example:     "schema.create: 'users' {\n  column.id: 'id'\n  column.string: 'name'\n}",
        })

        // Helper for column slots
        <span class="cov8" title="1">registerColumn := func(typeName string, defaultType string) </span><span class="cov8" title="1">{
                eng.Register("column."+typeName, func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                        val, _ := scope.Get("_schema_draft")
                        if val == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("column.%s must be called inside schema.create", typeName)
                        }</span>
                        <span class="cov8" title="1">schema := val.(*TableSchema)

                        colName := coerce.ToString(resolveValue(node.Value, scope))
                        col := ColumnDef{
                                Name: colName,
                                Type: defaultType,
                        }

                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "name" </span><span class="cov0" title="0">{
                                        col.Name = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                                <span class="cov0" title="0">if c.Name == "primary" </span><span class="cov0" title="0">{
                                        col.IsPrimary, _ = coerce.ToBool(parseNodeValue(c, scope))
                                }</span>
                                <span class="cov0" title="0">if c.Name == "nullable" </span><span class="cov0" title="0">{
                                        col.IsNullable, _ = coerce.ToBool(parseNodeValue(c, scope))
                                }</span>
                                <span class="cov0" title="0">if c.Name == "default" </span><span class="cov0" title="0">{
                                        col.DefaultValue = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                        }

                        <span class="cov8" title="1">if typeName == "id" </span><span class="cov8" title="1">{
                                col.IsPrimary = true
                                col.AutoIncrement = true
                        }</span>

                        <span class="cov8" title="1">schema.Columns = append(schema.Columns, col)
                        return nil</span>
                }, engine.SlotMeta{})
        }

        <span class="cov8" title="1">registerColumn("id", "INTEGER")
        registerColumn("string", "VARCHAR(255)")
        registerColumn("text", "TEXT")
        registerColumn("integer", "INTEGER")
        registerColumn("boolean", "BOOLEAN")
        registerColumn("datetime", "DATETIME")

        // Special: Timestamps
        eng.Register("column.timestamps", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                val, _ := scope.Get("_schema_draft")
                if val == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("column.timestamps must be called inside schema.create")
                }</span>
                <span class="cov0" title="0">schema := val.(*TableSchema)

                schema.Columns = append(schema.Columns, ColumnDef{Name: "created_at", Type: "TIMESTAMP", DefaultValue: "CURRENT_TIMESTAMP"})
                schema.Columns = append(schema.Columns, ColumnDef{Name: "updated_at", Type: "TIMESTAMP", DefaultValue: "CURRENT_TIMESTAMP"})
                return nil</span>
        }, engine.SlotMeta{})
}

func buildCreateSQL(schema *TableSchema, dialect dbmanager.Dialect) string <span class="cov8" title="1">{
        var sb strings.Builder
        sb.WriteString("CREATE TABLE IF NOT EXISTS ")
        sb.WriteString(dialect.QuoteIdentifier(schema.Name))
        sb.WriteString(" (\n")

        var colStrings []string
        for _, col := range schema.Columns </span><span class="cov8" title="1">{
                s := fmt.Sprintf("    %s %s", dialect.QuoteIdentifier(col.Name), translateType(col.Type, dialect))
                if col.IsPrimary </span><span class="cov8" title="1">{
                        // Dialect specific primary key / auto increment
                        if dialect.Name() == "sqlite" &amp;&amp; col.AutoIncrement </span><span class="cov8" title="1">{
                                s += " PRIMARY KEY AUTOINCREMENT"
                        }</span> else<span class="cov0" title="0"> if col.IsPrimary </span><span class="cov0" title="0">{
                                s += " PRIMARY KEY"
                        }</span>
                }
                <span class="cov8" title="1">if !col.IsNullable &amp;&amp; !col.IsPrimary </span><span class="cov8" title="1">{
                        s += " NOT NULL"
                }</span>
                <span class="cov8" title="1">if col.DefaultValue != "" </span><span class="cov0" title="0">{
                        s += " DEFAULT " + col.DefaultValue
                }</span>
                <span class="cov8" title="1">colStrings = append(colStrings, s)</span>
        }

        <span class="cov8" title="1">sb.WriteString(strings.Join(colStrings, ",\n"))
        sb.WriteString("\n);")

        return sb.String()</span>
}

func translateType(typeName string, dialect dbmanager.Dialect) string <span class="cov8" title="1">{
    // Simple mapping for now
    if dialect.Name() == "postgres" </span><span class="cov0" title="0">{
        if typeName == "TIMESTAMP" </span><span class="cov0" title="0">{ return "TIMESTAMPTZ" }</span>
    }
    <span class="cov8" title="1">return typeName</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package slots

import (
        "context"
        "crypto/sha256"
        "crypto/subtle"
        "encoding/base64"
        "encoding/binary"
        "fmt"
        "net/http"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"

        "github.com/gorilla/csrf"
        "golang.org/x/crypto/bcrypt"
        "golang.org/x/crypto/pbkdf2"
)

func RegisterSecuritySlots(eng *engine.Engine) <span class="cov0" title="0">{

        // 1. CRYPTO.HASH
        eng.Register("crypto.hash", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                // Value utama (shorthand): crypto.hash: $password
                input := coerce.ToString(resolveValue(node.Value, scope))
                target := "hash_result"

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "text" || c.Name == "val" </span><span class="cov0" title="0">{
                                input = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">if input == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("crypto.hash: input text is required")
                }</span>

                <span class="cov0" title="0">bytes, err := bcrypt.GenerateFromPassword([]byte(input), 10)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">scope.Set(target, string(bytes))
                return nil</span>
        }, engine.SlotMeta{Example: "crypto.hash: $pass\n  as: $hashed"})

        // 2. CRYPTO.VERIFY
        <span class="cov0" title="0">eng.Register("crypto.verify", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                var hash, text string
                target := "verify_result"

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "hash" </span><span class="cov0" title="0">{
                                hash = coerce.ToString(val)
                        }</span>
                        <span class="cov0" title="0">if c.Name == "text" </span><span class="cov0" title="0">{
                                text = coerce.ToString(val)
                        }</span>
                        <span class="cov0" title="0">if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(text))
                isValid := (err == nil)
                scope.Set(target, isValid)
                return nil</span>
        }, engine.SlotMeta{Example: "crypto.verify\n  hash: $h\n  text: $p"})

        // 3. SEC.CSRF_TOKEN
        <span class="cov0" title="0">eng.Register("sec.csrf_token", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                reqVal := ctx.Value("httpRequest")
                if reqVal == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("httpRequest not found in context")
                }</span>
                <span class="cov0" title="0">r := reqVal.(*http.Request)
                token := csrf.Token(r)

                target := "csrf_token"
                if node.Value != nil </span><span class="cov0" title="0">{
                        target = strings.TrimPrefix(coerce.ToString(node.Value), "$")
                }</span>

                <span class="cov0" title="0">scope.Set(target, token)
                return nil</span>
        }, engine.SlotMeta{Example: "sec.csrf_token: $token"})

        // 4. CRYPTO.VERIFY_ASPNET (Identity V3)
        <span class="cov0" title="0">eng.Register("crypto.verify_aspnet", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                var hash, password string
                target := "verify_result"

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "hash" </span><span class="cov0" title="0">{
                                hash = coerce.ToString(val)
                        }</span>
                        <span class="cov0" title="0">if c.Name == "password" </span><span class="cov0" title="0">{
                                password = coerce.ToString(val)
                        }</span>
                        <span class="cov0" title="0">if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">if hash == "" || password == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("crypto.verify_aspnet: hash and password are required")
                }</span>

                <span class="cov0" title="0">isValid := VerifyAspNetHash(hash, password)
                scope.Set(target, isValid)
                return nil</span>
        }, engine.SlotMeta{Example: "crypto.verify_aspnet\n  hash: $db_hash\n  password: $input_pass"})
}

// VerifyAspNetHash verifies ASP.NET Identity V3 password hashes
// Format: 0x01 (1 byte) | Prf (1 byte) | IterCount (4 bytes) | SaltLen (4 bytes) | Salt | Subkey
func VerifyAspNetHash(hashedPassword, providedPassword string) bool <span class="cov8" title="1">{
        decoded, err := base64.StdEncoding.DecodeString(hashedPassword)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if len(decoded) &lt; 13 </span><span class="cov8" title="1">{
                return false // Too short to be valid V3
        }</span>

        // Verify version byte (0x01)
        <span class="cov8" title="1">if decoded[0] != 0x01 </span><span class="cov0" title="0">{
                return false // Not Identity V3
        }</span>

        // Read header info
        // prf := decoded[1] // 0=SHA1, 1=SHA256, 2=SHA512. We assume SHA256 (1) for Identity V3 default.
        <span class="cov8" title="1">iterCount := int(binary.BigEndian.Uint32(decoded[5:9])) // Note: ASP.NET uses BigEndian for these ints in the binary blob
        saltLen := int(binary.BigEndian.Uint32(decoded[9:13]))

        if len(decoded) &lt; 13+saltLen </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">salt := decoded[13 : 13+saltLen]
        expectedSubkey := decoded[13+saltLen:]

        // Hash the provided password with the same parameters
        // PRF: HMAC-SHA256 (default for V3)
        // KeyLen: 32 bytes (256 bits)
        dk := pbkdf2.Key([]byte(providedPassword), salt, iterCount, 32, sha256.New)

        return subtle.ConstantTimeCompare(dk, expectedSubkey) == 1</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package slots

import (
        "context"
        "fmt"
        "net"
        "net/http"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/middleware"
        "zeno/pkg/utils/coerce"
)

func RegisterIPSecuritySlots(eng *engine.Engine) <span class="cov8" title="1">{

        // 1. SEC.BLOCK_IP
        eng.Register("sec.block_ip", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var ip string

                // Value can be direct: sec.block_ip: "192.168.1.1"
                if node.Value != nil </span><span class="cov8" title="1">{
                        val := resolveValue(node.Value, scope)
                        ip = coerce.ToString(val)
                }</span>

                // Or via children: sec.block_ip: { ip: "..." }
                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "ip" </span><span class="cov0" title="0">{
                                val := parseNodeValue(c, scope)
                                ip = coerce.ToString(val)
                        }</span>
                }

                // If no IP provided, try to block current request IP
                <span class="cov8" title="1">if ip == "" </span><span class="cov8" title="1">{
                        reqVal := ctx.Value("httpRequest")
                        if reqVal != nil </span><span class="cov8" title="1">{
                                r := reqVal.(*http.Request)
                                host, _, err := net.SplitHostPort(r.RemoteAddr)
                                if err == nil </span><span class="cov8" title="1">{
                                        ip = host
                                }</span> else<span class="cov0" title="0"> {
                                        ip = r.RemoteAddr
                                }</span>
                        }
                }

                <span class="cov8" title="1">if ip == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("sec.block_ip: IP address required")
                }</span>

                // Block the IP
                <span class="cov8" title="1">middleware.GlobalBlockList.Add(ip)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Add an IP address to the global blocklist.",
                Example:     "sec.block_ip: $request.ip",
        })

        // 2. SEC.UNBLOCK_IP
        <span class="cov8" title="1">eng.Register("sec.unblock_ip", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var ip string
                if node.Value != nil </span><span class="cov8" title="1">{
                        val := resolveValue(node.Value, scope)
                        ip = coerce.ToString(val)
                }</span>

                <span class="cov8" title="1">if ip == "" </span><span class="cov0" title="0">{
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "ip" </span><span class="cov0" title="0">{
                                        ip = coerce.ToString(parseNodeValue(c, scope))
                                }</span>
                        }
                }

                <span class="cov8" title="1">if ip == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("sec.unblock_ip: IP address required")
                }</span>

                <span class="cov8" title="1">middleware.GlobalBlockList.Remove(ip)
                return nil</span>
        }, engine.SlotMeta{Example: "sec.unblock_ip: '1.2.3.4'"})

        // 3. SEC.IS_BLOCKED
        <span class="cov8" title="1">eng.Register("sec.is_blocked", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var ip string
                target := "is_blocked"

                if node.Value != nil </span><span class="cov8" title="1">{
                        val := resolveValue(node.Value, scope)
                        ip = coerce.ToString(val)
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "ip" </span><span class="cov0" title="0">{
                                ip = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if ip == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("sec.is_blocked: IP address required")
                }</span>

                <span class="cov8" title="1">blocked := middleware.GlobalBlockList.IsBlocked(ip)
                scope.Set(target, blocked)
                return nil</span>
        }, engine.SlotMeta{Example: "sec.is_blocked: $ip\n  as: $banned"})
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package slots

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

// FlashSessionKeyPrefix is the prefix for flash cookies
const FlashSessionKeyPrefix = "_flash_"

// RegisterSessionSlots registers session related slots
func RegisterSessionSlots(eng *engine.Engine) <span class="cov0" title="0">{

        // 1. SESSION.FLASH - Store data for next request (via Cookie)
        eng.Register("session.flash", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("session.flash: not in http context")
                }</span>

                <span class="cov0" title="0">var key string
                var val interface{}

                // Parse arguments
                if node.Value != nil </span><span class="cov0" title="0">{
                        val = resolveValue(node.Value, scope)
                }</span>

                <span class="cov0" title="0">for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "key" </span><span class="cov0" title="0">{
                                key = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "val" || c.Name == "value" </span><span class="cov0" title="0">{
                                val = parseNodeValue(c, scope)
                        }</span>
                }

                <span class="cov0" title="0">if key == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("session.flash: key is required")
                }</span>

                // Encode value to JSON string
                <span class="cov0" title="0">jsonBytes, err := json.Marshal(val)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("session.flash: failed to marshal value: %v", err)
                }</span>

                // URL Encode to be safe in cookie
                <span class="cov0" title="0">cookieVal := url.QueryEscape(string(jsonBytes))

                // Set Cookie (Short lived, e.g. 5 minutes to allow redirect)
                http.SetCookie(w, &amp;http.Cookie{
                        Name:     FlashSessionKeyPrefix + key,
                        Value:    cookieVal,
                        Path:     "/",
                        HttpOnly: true,
                        MaxAge:   300,
                })

                return nil</span>
        }, engine.SlotMeta{
                Description: "Flash data to the session (cookie) for the next request.",
                Example:     "session.flash: { key: 'error', val: 'Invalid credentials' }",
        })

        // 2. SESSION.GET_FLASH - Retrieve and delete flash data
        <span class="cov0" title="0">eng.Register("session.get_flash", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                reqVal := ctx.Value("httpRequest")
                if reqVal == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">r := reqVal.(*http.Request)
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)

                // If we can't write (read-only context?), we can still read cookie but can't delete it.
                // Detailed logic: Read cookie, then Set-Cookie MaxAge=-1 to delete it.

                var key string
                target := "flash_data"

                // Parse arguments
                if node.Value != nil </span><span class="cov0" title="0">{
                        key = coerce.ToString(resolveValue(node.Value, scope))
                        target = key // Default target same as key name if shorthand used
                }</span>

                <span class="cov0" title="0">for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "key" </span><span class="cov0" title="0">{
                                key = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">if key == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("session.get_flash: key is required")
                }</span>

                <span class="cov0" title="0">cookieName := FlashSessionKeyPrefix + key
                cookie, err := r.Cookie(cookieName)

                if err != nil || cookie.Value == "" </span><span class="cov0" title="0">{
                        // Not found
                        scope.Set(target, nil)
                        return nil
                }</span>

                // Decode value
                <span class="cov0" title="0">jsonStr, err := url.QueryUnescape(cookie.Value)
                if err != nil </span><span class="cov0" title="0">{
                        scope.Set(target, nil)
                        return nil
                }</span>

                <span class="cov0" title="0">var val interface{}
                if err := json.Unmarshal([]byte(jsonStr), &amp;val); err != nil </span><span class="cov0" title="0">{
                        // If not valid JSON, maybe raw string?
                        val = jsonStr
                }</span>

                <span class="cov0" title="0">scope.Set(target, val)

                // Delete Cookie (Flash is read-once)
                if ok </span><span class="cov0" title="0">{
                        http.SetCookie(w, &amp;http.Cookie{
                                Name:     cookieName,
                                Value:    "",
                                Path:     "/",
                                HttpOnly: true,
                                MaxAge:   -1,
                        })
                }</span>

                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Retrieve flash data and remove it from session.",
                Example:     "session.get_flash: 'error' { as: $error_msg }",
        })

        // 3. SESSION.KEEP - Keep flash data for another request (Not implemented yet - re-set cookie?)
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package slots

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "zeno/pkg/engine"
        "zeno/pkg/fastjson"
        "zeno/pkg/utils/coerce"
)

// RegisterSSESlots registers Server-Sent Events slots
func RegisterSSESlots(eng *engine.Engine) <span class="cov8" title="1">{

        // 1. SSE.STREAM - Start SSE connection
        eng.Register("sse.stream", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("sse.stream: not in http context")
                }</span>

                // Set SSE headers
                <span class="cov8" title="1">w.Header().Set("Content-Type", "text/event-stream")
                w.Header().Set("Cache-Control", "no-cache")
                w.Header().Set("Connection", "keep-alive")
                w.Header().Set("Access-Control-Allow-Origin", "*")

                // Get flusher
                flusher, ok := w.(http.Flusher)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("sse.stream: streaming not supported")
                }</span>

                // Store flusher in scope for sse.send to use
                <span class="cov8" title="1">scope.Set("__sse_writer", w)
                scope.Set("__sse_flusher", flusher)
                scope.Set("__sse_active", true)

                // Create a mutex for thread-safe writing (needed for keepalive)
                // We use a channel as a mutex to avoid importing sync/atomic or passing pointer complexities
                // Actually, standard sync.Mutex is fine as long as we store the pointer
                // We need to import "sync"
                var mu sync.Mutex
                scope.Set("__sse_mutex", &amp;mu)

                // Execute children (sse.send, sse.loop, etc.)
                for _, child := range node.Children </span><span class="cov8" title="1">{
                        if err := eng.Execute(ctx, child, scope); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Start Server-Sent Events stream",
                Example: `sse.stream {
    sse.send {
        event: "message"
        data: "Hello from SSE"
    }
}`,
        })

        // 2. SSE.SEND - Send SSE message
        <span class="cov8" title="1">eng.Register("sse.send", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                w, ok := scope.Get("__sse_writer")
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("sse.send: must be inside sse.stream")
                }</span>
                <span class="cov8" title="1">writer := w.(http.ResponseWriter)

                flusher, _ := scope.Get("__sse_flusher")
                flush := flusher.(http.Flusher)

                // Get Mutex
                muObj, ok := scope.Get("__sse_mutex")
                if ok </span><span class="cov8" title="1">{
                        mu := muObj.(*sync.Mutex)
                        mu.Lock()
                        defer mu.Unlock()
                }</span>

                <span class="cov8" title="1">var eventName string
                var data interface{}
                var id string
                var retry int

                // Parse attributes
                for _, child := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(child, scope)
                        switch child.Name </span>{
                        case "event":<span class="cov8" title="1">
                                eventName = coerce.ToString(val)</span>
                        case "data":<span class="cov8" title="1">
                                data = val</span>
                        case "id":<span class="cov8" title="1">
                                id = coerce.ToString(val)</span>
                        case "retry":<span class="cov0" title="0">
                                retry, _ = coerce.ToInt(val)</span>
                        }
                }

                // Send event name
                <span class="cov8" title="1">if eventName != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(writer, "event: %s\n", eventName)
                }</span>

                // Send ID
                <span class="cov8" title="1">if id != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(writer, "id: %s\n", id)
                }</span>

                // Send retry
                <span class="cov8" title="1">if retry &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Fprintf(writer, "retry: %d\n", retry)
                }</span>

                // Send data (JSON if object/array, string otherwise)
                <span class="cov8" title="1">if data != nil </span><span class="cov8" title="1">{
                        switch v := data.(type) </span>{
                        case string:<span class="cov8" title="1">
                                fmt.Fprintf(writer, "data: %s\n", v)</span>
                        case map[string]interface{}, []interface{}:<span class="cov0" title="0">
                                jsonData, _ := fastjson.Marshal(v)
                                fmt.Fprintf(writer, "data: %s\n", string(jsonData))</span>
                        default:<span class="cov0" title="0">
                                fmt.Fprintf(writer, "data: %v\n", v)</span>
                        }
                }

                // End message
                <span class="cov8" title="1">fmt.Fprintf(writer, "\n")
                flush.Flush()

                return nil</span>
        }, engine.SlotMeta{
                Description: "Send SSE message to client",
                Inputs: map[string]engine.InputMeta{
                        "event": {Description: "Event name", Type: "string"},
                        "data":  {Description: "Data to send", Type: "any"},
                        "id":    {Description: "Event ID", Type: "string"},
                        "retry": {Description: "Retry interval (ms)", Type: "int"},
                },
                Example: `sse.send {
    event: "notification"
    data: { message: "New update!" }
}`,
        })

        // 3. SSE.LOOP - Keep connection alive with periodic updates
        <span class="cov8" title="1">eng.Register("sse.loop", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                active, ok := scope.Get("__sse_active")
                if !ok || !active.(bool) </span><span class="cov0" title="0">{
                        return fmt.Errorf("sse.loop: must be inside sse.stream")
                }</span>

                // Get interval (default 1 second)
                <span class="cov8" title="1">interval := 1000
                var maxIterations int

                for _, child := range node.Children </span><span class="cov8" title="1">{
                        if child.Name == "interval" </span><span class="cov8" title="1">{
                                val := parseNodeValue(child, scope)
                                interval, _ = coerce.ToInt(val)
                        }</span>
                        <span class="cov8" title="1">if child.Name == "max" </span><span class="cov8" title="1">{
                                val := parseNodeValue(child, scope)
                                maxIterations, _ = coerce.ToInt(val)
                        }</span>
                }

                <span class="cov8" title="1">ticker := time.NewTicker(time.Duration(interval) * time.Millisecond)
                defer ticker.Stop()

                iterations := 0
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return nil</span>
                        case &lt;-ticker.C:<span class="cov8" title="1">
                                // Execute loop body
                                for _, child := range node.Children </span><span class="cov8" title="1">{
                                        if child.Name == "do" </span><span class="cov8" title="1">{
                                                for _, doChild := range child.Children </span><span class="cov8" title="1">{
                                                        if err := eng.Execute(ctx, doChild, scope); err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                }
                                        }
                                }

                                <span class="cov8" title="1">iterations++
                                if maxIterations &gt; 0 &amp;&amp; iterations &gt;= maxIterations </span><span class="cov8" title="1">{
                                        return nil
                                }</span>
                        }
                }
        }, engine.SlotMeta{
                Description: "Loop with periodic SSE updates",
                Inputs: map[string]engine.InputMeta{
                        "interval": {Description: "Interval in milliseconds", Type: "int"},
                        "max":      {Description: "Max iterations (0 = infinite)", Type: "int"},
                },
                Example: `sse.loop {
    interval: 1000
    do {
        sse.send {
            data: $currentTime
        }
    }
}`,
        })

        // 4. SSE.KEEPALIVE - Send periodic keepalive pings
        <span class="cov8" title="1">eng.Register("sse.keepalive", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                w, ok := scope.Get("__sse_writer")
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">writer := w.(http.ResponseWriter)

                flusher, _ := scope.Get("__sse_flusher")
                flush := flusher.(http.Flusher)

                // Get Mutex
                muObj, _ := scope.Get("__sse_mutex")
                var mu *sync.Mutex
                if muObj != nil </span><span class="cov0" title="0">{
                        mu = muObj.(*sync.Mutex)
                }</span>

                // Default 30 seconds
                <span class="cov0" title="0">interval := 30000
                if node.Value != nil </span><span class="cov0" title="0">{
                        interval, _ = coerce.ToInt(resolveValue(node.Value, scope))
                }</span>

                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        ticker := time.NewTicker(time.Duration(interval) * time.Millisecond)
                        defer ticker.Stop()

                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case &lt;-ticker.C:<span class="cov0" title="0">
                                        if mu != nil </span><span class="cov0" title="0">{
                                                mu.Lock()
                                        }</span>
                                        <span class="cov0" title="0">fmt.Fprintf(writer, ": keepalive\n\n")
                                        flush.Flush()
                                        if mu != nil </span><span class="cov0" title="0">{
                                                mu.Unlock()
                                        }</span>
                                }
                        }

                }()

                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Send periodic keepalive pings",
                Example:     "sse.keepalive: 30000",
        })
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package slots

import (
        "context"
        "fmt"
        "reflect"
        "sync"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

// TestStats tracks the results of the test execution
type TestStats struct {
        Total  int
        Passed int
        Failed int
        Errors []string
        mu     sync.Mutex
}

func (s *TestStats) AddPass() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.Total++
        s.Passed++
}</span>

func (s *TestStats) AddFail(name string, err error) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.Total++
        s.Failed++
        s.Errors = append(s.Errors, fmt.Sprintf("FAIL [%s]: %v", name, err))
}</span>

type contextKey string

const statsKey contextKey = "testStats"

// WithTestStats injects the stats into the context
func WithTestStats(ctx context.Context, stats *TestStats) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, statsKey, stats)
}</span>

func RegisterTestSlots(eng *engine.Engine) <span class="cov8" title="1">{
        // SLOT: test
        eng.Register("test", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                testName := coerce.ToString(node.Value)
                if testName == "" </span><span class="cov0" title="0">{
                        testName = "Unnamed Test"
                }</span>

                <span class="cov8" title="1">fmt.Printf("RUN   %s...\n", testName)

                // Execute children (assertions)
                var err error
                for _, child := range node.Children </span><span class="cov8" title="1">{
                        if e := eng.Execute(ctx, child, scope); e != nil </span><span class="cov8" title="1">{
                                err = e
                                break</span> // Stop on first failure in a test case? Or continue? Usually stop.
                        }
                }

                <span class="cov8" title="1">stats, ok := ctx.Value(statsKey).(*TestStats)
                if ok </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov8" title="1">{
                                fmt.Printf("FAIL  %s\n", testName)
                                stats.AddFail(testName, err)
                                // We return nil to allow other independent tests to run.
                                // The error is recorded in stats.
                                return nil
                        }</span> else<span class="cov8" title="1"> {
                                fmt.Printf("PASS  %s\n", testName)
                                stats.AddPass()
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{Example: "test: 'My Test' { ... }"})

        // SLOT: assert.eq
        <span class="cov8" title="1">eng.Register("assert.eq", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // Expect 2 args.
                // If used as property: assert.eq: $actual { expected: 10 }
                // If used as expression logic (not fully supported by parser yet, assuming children/attributes)

                var actual, expected interface{}

                // Style 1: assert.eq: $val, 10 (Not supported by standard parser easily without custom parsing)
                // Style 2: assert.eq: $val { expected: 10 }

                actual = resolveValue(node.Value, scope)

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "expected" || c.Name == "val" </span><span class="cov8" title="1">{
                                expected = parseNodeValue(c, scope)
                        }</span>
                }

                // Fallback: If node.Value acts as expected and we have actual in children? No, conventionally Value is the subject.

                // Comparison
                <span class="cov8" title="1">if !reflect.DeepEqual(actual, expected) </span><span class="cov8" title="1">{
                        // Try coercing to string for loose comparison if types differ
                        if coerce.ToString(actual) != coerce.ToString(expected) </span><span class="cov8" title="1">{
                                return fmt.Errorf("expected %v, got %v", expected, actual)
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{Example: "assert.eq: $result { expected: 10 }"})

        // SLOT: assert.neq
        <span class="cov8" title="1">eng.Register("assert.neq", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                var actual, expected interface{}
                actual = resolveValue(node.Value, scope)
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "expected" || c.Name == "val" </span><span class="cov0" title="0">{
                                expected = parseNodeValue(c, scope)
                        }</span>
                }

                <span class="cov0" title="0">if reflect.DeepEqual(actual, expected) </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected value to NOT be %v", actual)
                }</span>
                // Loose check
                <span class="cov0" title="0">if coerce.ToString(actual) == coerce.ToString(expected) </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected value to NOT be %v", actual)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{})

        // SLOT: call
        // Usage: call: math.add { val: 10; val: 20; as: $res }
        <span class="cov8" title="1">eng.Register("call", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                slotName := coerce.ToString(node.Value)

                // Create a dynamic node to execute
                // We copy children to the new node to pass arguments
                callNode := &amp;engine.Node{
                        Name:     slotName,
                        Children: node.Children,
                }

                return eng.Execute(ctx, callNode, scope)
        }</span>, engine.SlotMeta{Example: "call: math.add { val: 1; as: $res }"})
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package slots

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

func RegisterTimeSlots(eng *engine.Engine) <span class="cov8" title="1">{
        // 1. DATE.NOW
        eng.Register("date.now", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                now := time.Now()
                target := "now"
                layout := time.RFC3339

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "layout" || c.Name == "format" </span><span class="cov8" title="1">{
                                layout = resolveLayout(coerce.ToString(parseNodeValue(c, scope)))
                        }</span>
                }

                // Support simple string output by default or object if requested
                <span class="cov8" title="1">formattedText := now.Format(layout)
                scope.Set(target, formattedText)
                scope.Set(target+"_obj", now)

                // [FIX] Support Blade Echo: Write to writer if in template context
                if w, ok := ctx.Value("httpWriter").(http.ResponseWriter); ok </span><span class="cov0" title="0">{
                        // If target is default "now" or "as" was NOT explicitly provided by child
                        hasAs := false
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "as" </span><span class="cov0" title="0">{
                                        hasAs = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !hasAs </span><span class="cov0" title="0">{
                                w.Write([]byte(formattedText))
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Mengambil waktu saat ini.",
                Example:     "date.now: { as: $skarang }",
                Inputs: map[string]engine.InputMeta{
                        "as":     {Description: "Variabel penyimpan hasil string"},
                        "layout": {Description: "Format tanggal (RFC3339, Human, dll)"},
                        "format": {Description: "Alias untuk layout"},
                },
        })

        // 2. DATE.FORMAT
        <span class="cov8" title="1">eng.Register("date.format", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var input interface{}
                layout := "2006-01-02 15:04:05"
                target := "formatted_date"

                if node.Value != nil </span><span class="cov8" title="1">{
                        val, err := MustResolveValue(node.Value, scope, coerce.ToString(node.Value))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">input = val</span>
                }

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "val" || c.Name == "date" </span><span class="cov0" title="0">{
                                input = parseNodeValue(c, scope)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "layout" || c.Name == "format" </span><span class="cov8" title="1">{
                                layout = resolveLayout(coerce.ToString(parseNodeValue(c, scope)))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if input == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("date.format: input date is required")
                }</span>

                <span class="cov8" title="1">var t time.Time
                switch v := input.(type) </span>{
                case time.Time:<span class="cov8" title="1">
                        t = v</span>
                case string:<span class="cov0" title="0">
                        parsed, err := parseFlexDate(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("date.format: failed to parse input string '%s': %v", v, err)
                        }</span>
                        <span class="cov0" title="0">t = parsed</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("date.format: invalid input type %T", input)</span>
                }

                <span class="cov8" title="1">scope.Set(target, t.Format(layout))
                return nil</span>
        }, engine.SlotMeta{
                Description: "Memformat objek tanggal atau string tanggal.",
                Example:     "date.format: $created_at { layout: 'Human'; as: $tgl }",
                Inputs: map[string]engine.InputMeta{
                        "val":    {Description: "Objek atau string tanggal"},
                        "date":   {Description: "Alias untuk val"},
                        "layout": {Description: "Format tujuan"},
                        "format": {Description: "Alias untuk layout"},
                        "as":     {Description: "Variabel penyimpan hasil"},
                },
        })

        // 3. DATE.PARSE
        <span class="cov8" title="1">eng.Register("date.parse", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                input := coerce.ToString(resolveValue(node.Value, scope))
                layout := ""
                target := "parsed_date"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "val" || c.Name == "input" </span><span class="cov0" title="0">{
                                input = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "layout" || c.Name == "format" </span><span class="cov0" title="0">{
                                layout = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if input == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("date.parse: input string is required")
                }</span>

                <span class="cov8" title="1">var t time.Time
                var err error
                if layout != "" </span><span class="cov0" title="0">{
                        t, err = time.Parse(resolveLayout(layout), input)
                }</span> else<span class="cov8" title="1"> {
                        t, err = parseFlexDate(input)
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("date.parse: %v", err)
                }</span>

                <span class="cov8" title="1">scope.Set(target, t)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Mengubah string menjadi objek tanggal.",
                Example:     "date.parse: '2023-12-25' { as: $tgl_obj }",
                Inputs: map[string]engine.InputMeta{
                        "input":  {Description: "String tanggal"},
                        "val":    {Description: "Alias untuk input"},
                        "layout": {Description: "Format sumber"},
                        "format": {Description: "Alias untuk layout"},
                        "as":     {Description: "Variabel penyimpan hasil"},
                },
        })

        // 4. DATE.ADD
        <span class="cov8" title="1">eng.Register("date.add", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var input interface{}
                durationStr := ""
                target := "shifted_date"

                if node.Value != nil </span><span class="cov8" title="1">{
                        input = resolveValue(node.Value, scope)
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "val" || c.Name == "date" </span><span class="cov0" title="0">{
                                input = parseNodeValue(c, scope)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "duration" || c.Name == "add" </span><span class="cov8" title="1">{
                                durationStr = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">if input == nil </span><span class="cov0" title="0">{
                        input = time.Now()
                }</span>

                <span class="cov8" title="1">var t time.Time
                switch v := input.(type) </span>{
                case time.Time:<span class="cov8" title="1">
                        t = v</span>
                case string:<span class="cov0" title="0">
                        parsed, err := parseFlexDate(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("date.add: invalid date string '%s'", v)
                        }</span>
                        <span class="cov0" title="0">t = parsed</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("date.add: invalid input type")</span>
                }

                <span class="cov8" title="1">d, err := time.ParseDuration(durationStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("date.add: invalid duration '%s' (use 1h, 30m, etc)", durationStr)
                }</span>

                <span class="cov8" title="1">scope.Set(target, t.Add(d))
                return nil</span>
        }, engine.SlotMeta{
                Description: "Menambah durasi ke tanggal.",
                Example:     "date.add: $now { duration: '2h'; as: $future }",
                Inputs: map[string]engine.InputMeta{
                        "date":     {Description: "Objek tanggal sumber"},
                        "val":      {Description: "Alias untuk date"},
                        "duration": {Description: "Durasi (1h, 30m, 10s)"},
                        "add":      {Description: "Alias untuk duration"},
                        "as":       {Description: "Variabel penyimpan hasil"},
                },
        })

        // 5. TIME.SLEEP
        <span class="cov8" title="1">eng.Register("time.sleep", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                durationStr := ""
                if node.Value != nil </span><span class="cov0" title="0">{
                        durationStr = coerce.ToString(resolveValue(node.Value, scope))
                }</span>

                <span class="cov0" title="0">for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "duration" </span><span class="cov0" title="0">{
                                durationStr = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                <span class="cov0" title="0">if durationStr == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("time.sleep: duration is required")
                }</span>

                <span class="cov0" title="0">d, err := time.ParseDuration(durationStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("time.sleep: invalid duration '%s'", durationStr)
                }</span>

                // Check for context cancellation during sleep
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-time.After(d):<span class="cov0" title="0">
                        return nil</span>
                }
        }, engine.SlotMeta{
                Description: "Pause execution for a duration.",
                Example:     "time.sleep: '1s'",
        })
}

// Helper: Resolve human aliases to Go layouts
func resolveLayout(layout string) string <span class="cov8" title="1">{
        switch strings.ToLower(layout) </span>{
        case "human":<span class="cov0" title="0">
                return "02 Jan 2006 15:04"</span>
        case "date":<span class="cov0" title="0">
                return "2006-01-02"</span>
        case "time":<span class="cov0" title="0">
                return "15:04:05"</span>
        case "rfc3339":<span class="cov0" title="0">
                return time.RFC3339</span>
        case "full":<span class="cov0" title="0">
                return "Monday, 02 January 2006 15:04:05"</span>
        default:<span class="cov8" title="1">
                // Jika mengandung token seperti yyyy, MM, dd, anggap format custom ala C#/PHP
                if strings.ContainsAny(layout, "yMdHms") </span><span class="cov8" title="1">{
                        return translateCustomLayout(layout)
                }</span>
                <span class="cov0" title="0">return layout</span>
        }
}

// translateCustomLayout mengonversi token umum (yyyy, MM, dd, HH, mm, ss) ke layout Go (2006, 01, 02, 15, 04, 05)
func translateCustomLayout(layout string) string <span class="cov8" title="1">{
        replacer := strings.NewReplacer(
                "yyyy", "2006",
                "yy", "06",
                "MMMM", "January",
                "MMM", "Jan",
                "MM", "01",
                "M", "1",
                "dddd", "Monday",
                "ddd", "Mon",
                "dd", "02",
                "d", "2",
                "HH", "15",
                "hh", "03",
                "h", "3",
                "mm", "04",
                "m", "4",
                "ss", "05",
                "s", "5",
                "tt", "PM",
        )

        return replacer.Replace(layout)
}</span>

// Helper: Try multiple common layouts
func parseFlexDate(s string) (time.Time, error) <span class="cov8" title="1">{
        layouts := []string{
                time.RFC3339,
                "2006-01-02 15:04:05",
                "2006-01-02",
                "02-01-2006",
                "02/01/2006",
                "02 Jan 2006",
        }
        for _, l := range layouts </span><span class="cov8" title="1">{
                if t, err := time.Parse(l, s); err == nil </span><span class="cov8" title="1">{
                        return t, nil
                }</span>
        }
        <span class="cov0" title="0">return time.Time{}, fmt.Errorf("unsupported date format")</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package slots

import (
        "context"
        "fmt"
        "zeno/pkg/dbmanager"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

func RegisterTransactionSlots(eng *engine.Engine, dbMgr *dbmanager.DBManager) <span class="cov8" title="1">{

        // DB.TRANSACTION
        eng.Register("db.transaction", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                // 1. Tentukan Nama Database
                dbName := "default"

                // Support: db.transaction: "analytics" (atau $dbname)
                if node.Value != nil </span><span class="cov0" title="0">{
                        dbName = coerce.ToString(resolveValue(node.Value, scope))
                }</span>

                <span class="cov8" title="1">var doNode *engine.Node

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "db" </span><span class="cov0" title="0">{
                                dbName = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "do" </span><span class="cov8" title="1">{
                                doNode = c
                        }</span>
                }

                // 2. Ambil Koneksi
                <span class="cov8" title="1">db := dbMgr.GetConnection(dbName)
                if db == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("db.transaction: database '%s' not found", dbName)
                }</span>

                // 3. Mulai Transaksi
                <span class="cov8" title="1">tx, err := db.BeginTx(ctx, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Simpan state transaksi lama (untuk support nested transaction di masa depan)
                // Saat ini kita replace saja.
                <span class="cov8" title="1">scope.Set("_active_tx", tx)

                // Defer cleanup: Pastikan _active_tx dihapus setelah blok selesai
                defer scope.Set("_active_tx", nil)

                // 4. Eksekusi Blok
                var execErr error

                // Jika ada node 'do', eksekusi isinya.
                // Jika tidak, eksekusi children langsung (shorthand).
                nodesToExec := node.Children
                if doNode != nil </span><span class="cov8" title="1">{
                        nodesToExec = doNode.Children
                }</span>

                <span class="cov8" title="1">for _, child := range nodesToExec </span><span class="cov8" title="1">{
                        // Skip node konfigurasi 'db' atau 'do' wrapper saat looping direct children
                        if doNode == nil &amp;&amp; (child.Name == "db" || child.Name == "do") </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if err := eng.Execute(ctx, child, scope); err != nil </span><span class="cov8" title="1">{
                                execErr = err
                                break</span>
                        }
                }

                // 5. Commit atau Rollback
                <span class="cov8" title="1">if execErr != nil </span><span class="cov8" title="1">{
                        // Jika ada error di script user, batalkan semua perubahan DB
                        tx.Rollback()
                        return execErr
                }</span>

                <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Menjalankan blok kode dalam database transaction (ACID).",
                Example:     "db.transaction\n  do:\n    db.insert: ...\n    db.update: ...",
        })
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package slots

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strings" // [WAJIB] Jangan lupa import strings
        "time"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

func RegisterUploadSlots(eng *engine.Engine) <span class="cov8" title="1">{
        // ==========================================
        // SLOT: HTTP.UPLOAD
        // ==========================================
        eng.Register("http.upload", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                r, ok := ctx.Value("httpRequest").(*http.Request)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.upload: request context not found")
                }</span>

                // 1. Ambil Parameter
                <span class="cov8" title="1">field := "file"
                destDir := "public/uploads"
                targetVar := "uploaded_file"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "field" </span><span class="cov8" title="1">{
                                field = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "dest" </span><span class="cov8" title="1">{
                                destDir = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                // [FIX UTAMA] Bersihkan awalan $ agar variable tersimpan dengan benar
                                targetVar = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                // 2. Ambil File dari Form
                <span class="cov8" title="1">file, header, err := r.FormFile(field)
                if err != nil </span><span class="cov8" title="1">{
                        // Jika user tidak upload file (saat edit), biarkan kosong
                        scope.Set(targetVar, "")
                        return nil
                }</span>
                <span class="cov8" title="1">defer file.Close()

                // 3. Buat Folder Tujuan (jika belum ada)
                if _, err := os.Stat(destDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        os.MkdirAll(destDir, 0755)
                }</span>

                // 4. Generate Nama File Unik (timestamp_filename)
                // Bersihkan nama file dari spasi agar URL aman
                <span class="cov8" title="1">cleanName := strings.ReplaceAll(header.Filename, " ", "_")
                filename := fmt.Sprintf("%d_%s", time.Now().Unix(), cleanName)
                dstPath := filepath.Join(destDir, filename)

                // 5. Simpan File
                dst, err := os.Create(dstPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.upload: failed to create file: %v", err)
                }</span>
                <span class="cov8" title="1">defer dst.Close()

                if _, err := io.Copy(dst, file); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.upload: failed to save file: %v", err)
                }</span>

                // 6. Return HANYA nama file ke variable (agar sesuai logika DB)
                <span class="cov8" title="1">scope.Set(targetVar, filename)
                return nil</span>
        }, engine.SlotMeta{Example: "http.upload:\n  field: image\n  as: $new_file"})
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package slots

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "strings"
        "time"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"

        "github.com/gosimple/slug"
        "github.com/microcosm-cc/bluemonday"
)

// (STRICT MODE: String Literal diprioritaskan daripada Variable)
func parseNodeValue(n *engine.Node, scope *engine.Scope) interface{} <span class="cov8" title="1">{
        // 1. Nested Object (Map)
        if len(n.Children) &gt; 0 </span><span class="cov0" title="0">{
                m := make(map[string]interface{})
                for _, c := range n.Children </span><span class="cov0" title="0">{
                        m[c.Name] = parseNodeValue(c, scope)
                }</span>
                <span class="cov0" title="0">return m</span>
        }

        <span class="cov8" title="1">valStr := strings.TrimSpace(fmt.Sprintf("%v", n.Value))

        // 2. [PRIORITAS UTAMA] CEK STRING LITERAL (Kutip)
        if len(valStr) &gt;= 2 </span><span class="cov8" title="1">{
                if (strings.HasPrefix(valStr, "\"") &amp;&amp; strings.HasSuffix(valStr, "\"")) ||
                        (strings.HasPrefix(valStr, "'") &amp;&amp; strings.HasSuffix(valStr, "'")) </span><span class="cov8" title="1">{
                        return valStr[1 : len(valStr)-1]
                }</span>
        }

        // 3. BARU CEK VARIABLE ($)
        <span class="cov8" title="1">if strings.HasPrefix(valStr, "$") </span><span class="cov8" title="1">{
                // [NEW] Support Null Coalesce: $var ?? 'default'
                if strings.Contains(valStr, "??") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(valStr, "??", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                v1 := strings.TrimSpace(parts[0])
                                v2 := strings.TrimSpace(parts[1])

                                res1 := parseNodeValue(&amp;engine.Node{Value: v1}, scope)
                                if res1 != nil &amp;&amp; fmt.Sprintf("%v", res1) != "" &amp;&amp; fmt.Sprintf("%v", res1) != "&lt;nil&gt;" </span><span class="cov0" title="0">{
                                        return res1
                                }</span>
                                <span class="cov0" title="0">return parseNodeValue(&amp;engine.Node{Value: v2}, scope)</span>
                        }
                }

                // [NEW] Support Ternary: $var ? 'trueVal' : 'falseVal'
                <span class="cov8" title="1">if strings.Contains(valStr, " ? ") &amp;&amp; strings.Contains(valStr, " : ") </span><span class="cov8" title="1">{
                        parts := strings.SplitN(valStr, " ? ", 2)
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                condStr := strings.TrimSpace(parts[0])
                                rest := strings.SplitN(parts[1], " : ", 2)
                                if len(rest) == 2 </span><span class="cov8" title="1">{
                                        trueStr := strings.TrimSpace(rest[0])
                                        falseStr := strings.TrimSpace(rest[1])

                                        condVal := parseNodeValue(&amp;engine.Node{Value: condStr}, scope)
                                        var b bool
                                        if condVal != nil </span><span class="cov8" title="1">{
                                                if bVal, err := coerce.ToBool(condVal); err == nil </span><span class="cov8" title="1">{
                                                        b = bVal
                                                }</span> else<span class="cov0" title="0"> {
                                                        strVal := coerce.ToString(condVal)
                                                        b = (strVal != "" &amp;&amp; strVal != "false" &amp;&amp; strVal != "0" &amp;&amp; strVal != "&lt;nil&gt;")
                                                }</span>
                                        }

                                        <span class="cov8" title="1">if b </span><span class="cov8" title="1">{
                                                return parseNodeValue(&amp;engine.Node{Value: trueStr}, scope)
                                        }</span>
                                        <span class="cov8" title="1">return parseNodeValue(&amp;engine.Node{Value: falseStr}, scope)</span>
                                }
                        }
                }

                <span class="cov8" title="1">key := strings.TrimPrefix(valStr, "$")
                // fmt.Println("DEBUG RESOLVE:", key)

                // A. Check Dot Notation OR Bracket Notation
                if strings.Contains(key, ".") || strings.Contains(key, "[") </span><span class="cov8" title="1">{
                        // Normalize Bracket Notation: users[0] -&gt; users.0
                        normalizedKey := key
                        if strings.Contains(normalizedKey, "[") </span><span class="cov0" title="0">{
                                normalizedKey = strings.ReplaceAll(normalizedKey, "[", ".")
                                normalizedKey = strings.ReplaceAll(normalizedKey, "]", "")
                        }</span>

                        <span class="cov8" title="1">parts := strings.Split(normalizedKey, ".")
                        rootKey := strings.TrimSpace(parts[0])

                        if rootVal, ok := scope.Get(rootKey); ok </span><span class="cov8" title="1">{
                                curr := rootVal
                                isValidPath := true
                                for i := 1; i &lt; len(parts); i++ </span><span class="cov8" title="1">{
                                        targetKey := strings.TrimSpace(parts[i])
                                        if targetKey == "" </span><span class="cov0" title="0">{
                                                continue</span>
                                        }

                                        // 1. Handle Maps
                                        <span class="cov8" title="1">if m, ok := curr.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                                if val, exists := m[targetKey]; exists </span><span class="cov8" title="1">{
                                                        curr = val
                                                        continue</span>
                                                }
                                        }

                                        // 2. Handle Arrays/Slices
                                        <span class="cov0" title="0">if list, err := coerce.ToSlice(curr); err == nil </span><span class="cov0" title="0">{
                                                if idx, err := coerce.ToInt(targetKey); err == nil </span><span class="cov0" title="0">{
                                                        if idx &gt;= 0 &amp;&amp; idx &lt; len(list) </span><span class="cov0" title="0">{
                                                                curr = list[idx]
                                                                continue</span>
                                                        }
                                                }
                                        }

                                        <span class="cov0" title="0">isValidPath = false
                                        break</span>
                                }
                                <span class="cov8" title="1">if isValidPath </span><span class="cov8" title="1">{
                                        return curr
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }

                // B. Cek Variabel Biasa
                <span class="cov8" title="1">if v, ok := scope.Get(strings.TrimSpace(key)); ok </span><span class="cov8" title="1">{
                        return v
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // 4. FALLBACK (Nilai mentah)
        <span class="cov8" title="1">return n.Value</span>
}

// Helper: Resolusi Nilai Tunggal
func resolveValue(val interface{}, scope *engine.Scope) interface{} <span class="cov8" title="1">{
        return parseNodeValue(&amp;engine.Node{Value: val}, scope)
}</span>

// MustResolveValue returns an error if the value is nil or not found.
// Useful for strict validation in slots.
func MustResolveValue(val interface{}, scope *engine.Scope, name string) (interface{}, error) <span class="cov8" title="1">{
        res := resolveValue(val, scope)
        if res == nil || coerce.ToString(res) == "nil" || coerce.ToString(res) == "&lt;nil&gt;" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("variable or value '%s' is nil or not found in scope", name)
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}

func RegisterUtilSlots(eng *engine.Engine) <span class="cov8" title="1">{
        // 1. LOG
        eng.Register("log", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                val := resolveValue(node.Value, scope)
                fmt.Println("[LOG]:", val)
                return nil
        }</span>, engine.SlotMeta{Example: "log: $user.name"})

        // 2. STRINGS CONCAT
        <span class="cov8" title="1">eng.Register("strings.concat", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var builder strings.Builder
                target := ""

                if node.Value != nil </span><span class="cov8" title="1">{
                        builder.WriteString(coerce.ToString(resolveValue(node.Value, scope)))
                }</span>

                // 2. Include children
                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" || c.Name == "target" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                                continue</span>
                        }
                        // General children (val, arg, or just positional)
                        <span class="cov8" title="1">val := parseNodeValue(c, scope)
                        builder.WriteString(coerce.ToString(val))</span>
                }

                <span class="cov8" title="1">result := builder.String()
                if target != "" </span><span class="cov8" title="1">{
                        scope.Set(target, result)
                }</span> else<span class="cov0" title="0"> {
                        if w, ok := ctx.Value("httpWriter").(http.ResponseWriter); ok </span><span class="cov0" title="0">{
                                w.Write([]byte(result))
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("[LOG]:", result)
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Menggabungkan beberapa string menjadi satu secara fleksibel.",
                Example:     "strings.concat: 'Hello '\n  val: $name\n  as: $greeting",
        })

        // 2.5 STRINGS REPLACE
        <span class="cov8" title="1">eng.Register("string.replace", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                original := coerce.ToString(resolveValue(node.Value, scope))
                var find, replace string
                target := "replace_result"
                limit := -1

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)
                        if c.Name == "find" </span><span class="cov8" title="1">{
                                find = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "replace" </span><span class="cov8" title="1">{
                                replace = coerce.ToString(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "limit" </span><span class="cov0" title="0">{
                                limit, _ = coerce.ToInt(val)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">result := strings.Replace(original, find, replace, limit)
                scope.Set(target, result)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Mengganti substring dalam string dengan string lain.",
                Example:     "string.replace: $text\n  find: 'old'\n  replace: 'new'\n  as: $result",
                Inputs: map[string]engine.InputMeta{
                        "find":    {Description: "Substring yang dicari", Required: true},
                        "replace": {Description: "Substring pengganti", Required: true},
                        "limit":   {Description: "Jumlah penggantian maksimum (-1 untuk semua)", Required: false},
                        "as":      {Description: "Variabel penyimpan hasil", Required: false},
                },
        })

        // 3. TEXT SLUGIFY
        <span class="cov8" title="1">eng.Register("text.slugify", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                input := coerce.ToString(resolveValue(node.Value, scope))
                target := "slug_result"
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                // [FIX] Bersihkan awalan $
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                        <span class="cov8" title="1">if c.Name == "text" || c.Name == "val" </span><span class="cov0" title="0">{
                                input = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }
                <span class="cov8" title="1">scope.Set(target, slug.Make(input))
                return nil</span>
        }, engine.SlotMeta{
                Description: "Mengubah teks menjadi format URL-friendly slug.",
                Example:     "text.slugify: 'Halo Dunia'\n  as: $my_slug",
                Inputs: map[string]engine.InputMeta{
                        "text": {Description: "Teks sumber", Required: false},
                        "val":  {Description: "Alias untuk text", Required: false},
                        "as":   {Description: "Variabel penyimpan hasil", Required: false},
                },
        })

        // 4. TEXT SANITIZE
        <span class="cov8" title="1">eng.Register("text.sanitize", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                p := bluemonday.UGCPolicy()
                var input, target string
                target = "clean_text"
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "input" || c.Name == "val" </span><span class="cov0" title="0">{
                                input = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                        <span class="cov0" title="0">if c.Name == "as" </span><span class="cov0" title="0">{
                                // [FIX] Bersihkan awalan $
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }
                <span class="cov0" title="0">scope.Set(target, p.Sanitize(input))
                return nil</span>
        }, engine.SlotMeta{
                Description: "Membersihkan teks dari tag HTML berbahaya (XSS prevention).",
                Example:     "text.sanitize: $user_input\n  as: $clean_input",
                Inputs: map[string]engine.InputMeta{
                        "input": {Description: "Teks sumber", Required: false},
                        "val":   {Description: "Alias untuk input", Required: false},
                        "as":    {Description: "Variabel penyimpan hasil", Required: false},
                },
        })

        // 5. SYS INCLUDE
        <span class="cov8" title="1">eng.Register("include", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                path := coerce.ToString(resolveValue(node.Value, scope))
                root, err := engine.LoadScript(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return eng.Execute(ctx, root, scope)</span>
        }, engine.SlotMeta{})

        <span class="cov8" title="1">eng.Register("system.env", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                envKey := coerce.ToString(node.Value)
                val := os.Getenv(envKey)
                targetBucket := envKey // Default: use env key as var name

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                targetBucket = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">scope.Set(targetBucket, val)
                return nil</span>
        }, engine.SlotMeta{})

        // 6.5 SYSTEM ARGS
        <span class="cov8" title="1">eng.Register("system.args", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                args, ok := ctx.Value("zenoArgs").([]string)
                if !ok </span><span class="cov0" title="0">{
                        args = []string{}
                }</span>

                // Convert to []interface{} for better compatibility with coerce.ToSlice
                <span class="cov0" title="0">ifaceArgs := make([]interface{}, len(args))
                for i, v := range args </span><span class="cov0" title="0">{
                        ifaceArgs[i] = v
                }</span>

                <span class="cov0" title="0">target := "args"
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">scope.Set(target, ifaceArgs)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Mengambil argument command line yang dilewatkan ke script.",
                Example:     "system.args: { as: $my_args }",
        })

        // 7. HTTP RESPONSE
        <span class="cov8" title="1">eng.Register("http.response", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.response: not in http context")
                }</span>

                <span class="cov0" title="0">status := 200
                var data interface{}

                if node.Value != nil </span><span class="cov0" title="0">{
                        status, _ = coerce.ToInt(node.Value)
                }</span>
                <span class="cov0" title="0">for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "status" </span><span class="cov0" title="0">{
                                status, _ = coerce.ToInt(c.Value)
                        }</span>
                        <span class="cov0" title="0">if c.Name == "data" || c.Name == "body" </span><span class="cov0" title="0">{
                                data = parseNodeValue(c, scope)
                        }</span>
                }

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(status)
                return json.NewEncoder(w).Encode(data)</span>
        }, engine.SlotMeta{
                Description: "Mengirim response HTTP dalam format JSON.",
                Example:     "http.response: 200\n  data: $user_info",
                Inputs: map[string]engine.InputMeta{
                        "status": {Description: "HTTP Status Code", Required: false},
                        "data":   {Description: "Data JSON (Alias untuk body)", Required: false},
                        "body":   {Description: "Data JSON", Required: false},
                },
        })

        // 8. HTTP REDIRECT
        <span class="cov8" title="1">eng.Register("http.redirect", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                w, ok := ctx.Value("httpWriter").(http.ResponseWriter)
                r, ok2 := ctx.Value("httpRequest").(*http.Request)
                if !ok || !ok2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("http.redirect: context missing")
                }</span>

                <span class="cov0" title="0">url := coerce.ToString(resolveValue(node.Value, scope))
                http.Redirect(w, r, url, http.StatusSeeOther)
                return nil</span>
        }, engine.SlotMeta{})

        // 9. IF (UPGRADED: Support ==, !=, &gt;, &lt;, &gt;=, &lt;=)
        <span class="cov8" title="1">eng.Register("if", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                expression := coerce.ToString(node.Value)
                isTrue := false

                // Helper untuk parsing bagian kiri dan kanan operator
                parseParts := func(expr, op string) (interface{}, interface{}) </span><span class="cov8" title="1">{
                        parts := strings.SplitN(expr, op, 2)
                        left := resolveValue(strings.TrimSpace(parts[0]), scope)
                        right := resolveValue(strings.TrimSpace(parts[1]), scope)
                        return left, right
                }</span>

                <span class="cov8" title="1">if strings.Contains(expression, "==") </span><span class="cov0" title="0">{
                        left, right := parseParts(expression, "==")
                        // Handle Explicit Nil Check
                        if (left == nil &amp;&amp; coerce.ToString(right) == "nil") || (right == nil &amp;&amp; coerce.ToString(left) == "nil") </span><span class="cov0" title="0">{
                                isTrue = true
                        }</span> else<span class="cov0" title="0"> {
                                isTrue = (coerce.ToString(left) == coerce.ToString(right))
                        }</span>

                } else<span class="cov8" title="1"> if strings.Contains(expression, "!=") </span><span class="cov0" title="0">{
                        left, right := parseParts(expression, "!=")
                        isTrue = (coerce.ToString(left) != coerce.ToString(right))

                }</span> else<span class="cov8" title="1"> if strings.Contains(expression, "&gt;=") </span><span class="cov0" title="0">{
                        left, right := parseParts(expression, "&gt;=")
                        l, err1 := coerce.ToFloat64(left)
                        r, err2 := coerce.ToFloat64(right)
                        if err1 == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                                isTrue = (l &gt;= r)
                        }</span>
                } else<span class="cov8" title="1"> if strings.Contains(expression, "&lt;=") </span><span class="cov0" title="0">{
                        left, right := parseParts(expression, "&lt;=")
                        l, err1 := coerce.ToFloat64(left)
                        r, err2 := coerce.ToFloat64(right)
                        if err1 == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                                isTrue = (l &lt;= r)
                        }</span>
                } else<span class="cov8" title="1"> if strings.Contains(expression, "&gt;") </span><span class="cov8" title="1">{
                        left, right := parseParts(expression, "&gt;")
                        l, err1 := coerce.ToFloat64(left)
                        r, err2 := coerce.ToFloat64(right)
                        if err1 == nil &amp;&amp; err2 == nil </span><span class="cov8" title="1">{
                                isTrue = (l &gt; r)
                        }</span>
                } else<span class="cov0" title="0"> if strings.Contains(expression, "&lt;") </span><span class="cov0" title="0">{
                        left, right := parseParts(expression, "&lt;")
                        l, err1 := coerce.ToFloat64(left)
                        r, err2 := coerce.ToFloat64(right)
                        if err1 == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                                isTrue = (l &lt; r)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Logic: Truthy Check (Single Value)
                        val := resolveValue(node.Value, scope)
                        if b, err := coerce.ToBool(val); err == nil </span><span class="cov0" title="0">{
                                isTrue = b
                        }</span> else<span class="cov0" title="0"> {
                                s := coerce.ToString(val)
                                isTrue = (s != "" &amp;&amp; s != "false" &amp;&amp; s != "0" &amp;&amp; s != "&lt;nil&gt;")
                        }</span>
                }

                // Eksekusi Blok Then/Else
                <span class="cov8" title="1">var target *engine.Node
                if isTrue </span><span class="cov8" title="1">{
                        for _, c := range node.Children </span><span class="cov8" title="1">{
                                if c.Name == "then" </span><span class="cov8" title="1">{
                                        target = c
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        for _, c := range node.Children </span><span class="cov0" title="0">{
                                if c.Name == "else" </span><span class="cov0" title="0">{
                                        target = c
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">if target != nil </span><span class="cov8" title="1">{
                        for _, c := range target.Children </span><span class="cov8" title="1">{
                                if err := eng.Execute(ctx, c, scope); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }, engine.SlotMeta{
                Description: "Kondisional if-then-else. Support: ==, !=, &gt;, &lt;, &gt;=, &lt;=",
                Inputs: map[string]engine.InputMeta{
                        "then": {Description: "Blok kode jika kondisi benar", Required: false},
                        "else": {Description: "Blok kode jika kondisi salah", Required: false},
                },
                RequiredBlocks: []string{"then"},
        })

        // 10. ARRAY LENGTH
        <span class="cov8" title="1">eng.Register("arrays.length", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                val := resolveValue(node.Value, scope)
                list, _ := coerce.ToSlice(val)
                target := fmt.Sprintf("%v_length", node.Value)
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "as" </span><span class="cov8" title="1">{
                                // [FIX] Bersihkan awalan $
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }
                <span class="cov8" title="1">scope.Set(target, len(list))
                return nil</span>
        }, engine.SlotMeta{
                Description: "Mengambil jumlah elemen dalam sebuah array atau list.",
                Example:     "arrays.length: $users\n  as: $count",
                Inputs: map[string]engine.InputMeta{
                        "as": {Description: "Variabel penyimpan hasil", Required: true},
                },
        })

        // SLOT: VAR
        <span class="cov8" title="1">eng.Register("var", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                rawName := coerce.ToString(node.Value)
                varName := strings.TrimPrefix(rawName, "$")

                if varName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("var: variable name required (usage: var: $name)")
                }</span>

                <span class="cov8" title="1">var val interface{}
                var expectedType string
                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "val" || c.Name == "value" </span><span class="cov8" title="1">{
                                val = parseNodeValue(c, scope)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "type" </span><span class="cov0" title="0">{
                                expectedType = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                // [ENFORCEMENT] Validate type if provided
                <span class="cov8" title="1">if expectedType != "" &amp;&amp; expectedType != "any" </span><span class="cov0" title="0">{
                        if e, ok := ctx.Value("engine").(*engine.Engine); ok </span><span class="cov0" title="0">{
                                if err := e.ValidateValueType(val, expectedType, node, "var"); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov8" title="1">scope.Set(varName, val)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Membuat atau mengubah nilai variabel dalam scope saat ini.",
                Example:     "var: $count\n  val: 10\n  type: 'int'",
                Inputs: map[string]engine.InputMeta{
                        "val":   {Description: "Nilai variabel", Required: false, Type: "any"},
                        "value": {Description: "Alias untuk val", Required: false, Type: "any"},
                        "type":  {Description: "Tipe data (opsional)", Required: false, Type: "string"},
                },
        })

        // 10.5 SCHEMA (Type Locking/Schema Check)
        <span class="cov8" title="1">eng.Register("schema", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                rawName := coerce.ToString(node.Value)
                varName := strings.TrimPrefix(rawName, "$")

                if varName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("schema: variable name required (usage: schema: $name)")
                }</span>

                <span class="cov0" title="0">val, ok := scope.Get(varName)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("schema: variable '$%s' not found", varName)
                }</span>

                <span class="cov0" title="0">var expectedType string
                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "type" </span><span class="cov0" title="0">{
                                expectedType = coerce.ToString(parseNodeValue(c, scope))
                        }</span>
                }

                <span class="cov0" title="0">if expectedType != "" &amp;&amp; expectedType != "any" </span><span class="cov0" title="0">{
                        if e, ok := ctx.Value("engine").(*engine.Engine); ok </span><span class="cov0" title="0">{
                                if err := e.ValidateValueType(val, expectedType, node, "schema"); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">return nil</span>
        }, engine.SlotMeta{
                Description: "Memvalidasi tipe data variabel yang sudah ada.",
                Example:     "schema: $user_id { type: 'int' }",
                Inputs: map[string]engine.InputMeta{
                        "type": {Description: "Tipe data yang diharapkan", Required: true, Type: "string"},
                },
        })
        // 11. SLEEP
        <span class="cov8" title="1">eng.Register("sleep", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                ms, _ := coerce.ToInt(node.Value)
                time.Sleep(time.Duration(ms) * time.Millisecond)
                return nil
        }</span>, engine.SlotMeta{
                Description: "Menghentikan eksekusi selama beberapa milidetik.",
                Example:     "sleep: 1000",
                ValueType:   "int",
        })

        // ==========================================
        // SLOT: COALESCE (Null Safety)
        // ==========================================
        <span class="cov8" title="1">eng.Register("coalesce", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var val, def interface{}
                target := "coalesce_result"

                // Support value as main input
                if node.Value != nil </span><span class="cov0" title="0">{
                        val = resolveValue(node.Value, scope)
                }</span>

                <span class="cov8" title="1">for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "value" || c.Name == "val" </span><span class="cov0" title="0">{
                                val = parseNodeValue(c, scope)
                        }</span>
                        // Default value
                        <span class="cov8" title="1">if c.Name == "default" || c.Name == "def" </span><span class="cov8" title="1">{
                                def = parseNodeValue(c, scope)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">result := val

                // Check for true nil or string "nil"
                if result == nil || coerce.ToString(result) == "nil" || coerce.ToString(result) == "&lt;nil&gt;" </span><span class="cov8" title="1">{
                        result = def
                }</span>

                <span class="cov8" title="1">scope.Set(target, result)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Mengembalikan nilai default jika input bernilai null.",
                Example:     "coalesce: $user.name { default: 'Guest'; as: $name }",
        })

        // ==========================================
        // SLOT: IS_NULL
        // ==========================================
        <span class="cov8" title="1">eng.Register("is_null", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov0" title="0">{
                val := resolveValue(node.Value, scope)
                target := "is_null"

                for _, c := range node.Children </span><span class="cov0" title="0">{
                        if c.Name == "val" || c.Name == "value" </span><span class="cov0" title="0">{
                                val = parseNodeValue(c, scope)
                        }</span>
                        <span class="cov0" title="0">if c.Name == "as" </span><span class="cov0" title="0">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov0" title="0">scope.Set(target, val == nil)
                return nil</span>
        }, engine.SlotMeta{})

        // ==========================================
        // SLOT: CAST.TO_INT
        // ==========================================
        <span class="cov8" title="1">eng.Register("cast.to_int", func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                val := resolveValue(node.Value, scope)
                target := "cast_result"

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        if c.Name == "val" || c.Name == "value" </span><span class="cov0" title="0">{
                                val = parseNodeValue(c, scope)
                        }</span>
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                        }</span>
                }

                <span class="cov8" title="1">res, err := coerce.ToInt(val)
                if err != nil </span><span class="cov0" title="0">{
                        // Jika gagal, set 0 atau null? Default 0 aman untuk ID.
                        res = 0
                }</span>
                <span class="cov8" title="1">scope.Set(target, res)
                return nil</span>
        }, engine.SlotMeta{
                Description: "Mengubah variabel menjadi Integer.",
                Example:     "cast.to_int: $id { as: $id_int }",
        })
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package slots

import (
        "context"
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"
        "zeno/pkg/dbmanager"
        "zeno/pkg/engine"
        "zeno/pkg/utils/coerce"
)

func RegisterValidatorSlots(eng *engine.Engine, dbMgr *dbmanager.DBManager) <span class="cov8" title="1">{

        // 1. VALIDATOR.VALIDATE &amp; VALIDATE (Alias)
        validateHandler := func(ctx context.Context, node *engine.Node, scope *engine.Scope) error </span><span class="cov8" title="1">{
                var inputData map[string]interface{}
                var rules map[string]interface{}
                target := "errors"

                // Support Shorthand: validate: $form_data
                if node.Value != nil </span><span class="cov8" title="1">{
                        val := resolveValue(node.Value, scope)
                        if m, ok := val.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                inputData = m
                        }</span>
                }

                // Prepare implicit data map
                <span class="cov8" title="1">implicitData := make(map[string]interface{})

                for _, c := range node.Children </span><span class="cov8" title="1">{
                        val := parseNodeValue(c, scope)

                        if c.Name == "input" || c.Name == "data" </span><span class="cov0" title="0">{
                                if m, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        inputData = m
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov8" title="1">if c.Name == "rules" </span><span class="cov8" title="1">{
                                if m, ok := val.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        rules = m
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }
                        <span class="cov8" title="1">if c.Name == "as" </span><span class="cov8" title="1">{
                                target = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                                continue</span>
                        }

                        // Treat other children as data fields
                        <span class="cov8" title="1">implicitData[c.Name] = val</span>
                }

                // Merge implicit data if inputData is still nil
                <span class="cov8" title="1">if inputData == nil </span><span class="cov0" title="0">{
                        inputData = implicitData
                }</span>

                <span class="cov8" title="1">if inputData == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("validate: input data is missing or not a map")
                }</span>

                <span class="cov8" title="1">errors := make(map[string]string)
                emailRegex := regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,4}$`)
                urlRegex := regexp.MustCompile(`^(http|https)://[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,}(?:/[^ "]+)?$`)
                alphaNumRegex := regexp.MustCompile(`^[a-zA-Z0-9]+$`)

                // Iterate Rules
                for field, ruleRaw := range rules </span><span class="cov8" title="1">{
                        ruleStr := coerce.ToString(ruleRaw) // e.g. "required|email|min:5"
                        ruleParts := strings.Split(ruleStr, "|")

                        val, exists := inputData[field]
                        strVal := coerce.ToString(val)

                        for _, r := range ruleParts </span><span class="cov8" title="1">{
                                // 1. REQUIRED
                                if r == "required" </span><span class="cov8" title="1">{
                                        if !exists || strVal == "" </span><span class="cov8" title="1">{
                                                errors[field] = fmt.Sprintf("%s is required", field)
                                                break</span>
                                        }
                                }

                                // Skip check if empty and not required
                                <span class="cov8" title="1">if strVal == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // 2. EMAIL
                                <span class="cov8" title="1">if r == "email" </span><span class="cov8" title="1">{
                                        if !emailRegex.MatchString(strVal) </span><span class="cov8" title="1">{
                                                errors[field] = fmt.Sprintf("%s must be a valid email", field)
                                                break</span>
                                        }
                                }

                                // 3. NUMERIC
                                <span class="cov8" title="1">if r == "numeric" </span><span class="cov8" title="1">{
                                        if _, err := strconv.ParseFloat(strVal, 64); err != nil </span><span class="cov0" title="0">{
                                                errors[field] = fmt.Sprintf("%s must be a number", field)
                                                break</span>
                                        }
                                }

                                // 4. MIN:X (Length or Value)
                                <span class="cov8" title="1">if strings.HasPrefix(r, "min:") </span><span class="cov8" title="1">{
                                        param := strings.TrimPrefix(r, "min:")
                                        minVal, _ := strconv.ParseFloat(param, 64)

                                        // Jika input angka, cek value. Jika string, cek panjang.
                                        if num, err := strconv.ParseFloat(strVal, 64); err == nil </span><span class="cov8" title="1">{
                                                if num &lt; minVal </span><span class="cov8" title="1">{
                                                        errors[field] = fmt.Sprintf("%s must be at least %v", field, minVal)
                                                        break</span>
                                                }
                                        } else<span class="cov8" title="1"> {
                                                if float64(len(strVal)) &lt; minVal </span><span class="cov8" title="1">{
                                                        errors[field] = fmt.Sprintf("%s must be at least %v characters", field, minVal)
                                                        break</span>
                                                }
                                        }
                                }

                                // 5. MAX:X
                                <span class="cov8" title="1">if strings.HasPrefix(r, "max:") </span><span class="cov8" title="1">{
                                        param := strings.TrimPrefix(r, "max:")
                                        maxVal, _ := strconv.ParseFloat(param, 64)

                                        if num, err := strconv.ParseFloat(strVal, 64); err == nil </span><span class="cov8" title="1">{
                                                if num &gt; maxVal </span><span class="cov8" title="1">{
                                                        errors[field] = fmt.Sprintf("%s must not exceed %v", field, maxVal)
                                                        break</span>
                                                }
                                        } else<span class="cov8" title="1"> {
                                                if float64(len(strVal)) &gt; maxVal </span><span class="cov8" title="1">{
                                                        errors[field] = fmt.Sprintf("%s must not exceed %v characters", field, maxVal)
                                                        break</span>
                                                }
                                        }
                                }

                                // 6. CONFIRMED
                                <span class="cov8" title="1">if r == "confirmed" </span><span class="cov0" title="0">{
                                        confirmField := field + "_confirmation"
                                        confirmVal, ok := inputData[confirmField]
                                        if !ok || coerce.ToString(confirmVal) != strVal </span><span class="cov0" title="0">{
                                                errors[field] = fmt.Sprintf("%s confirmation does not match", field)
                                                break</span>
                                        }
                                }

                                // 7. ALPHA_NUM
                                <span class="cov8" title="1">if r == "alpha_num" </span><span class="cov0" title="0">{
                                        if !alphaNumRegex.MatchString(strVal) </span><span class="cov0" title="0">{
                                                errors[field] = fmt.Sprintf("%s must contain only letters and numbers", field)
                                                break</span>
                                        }
                                }

                                // 8. URL
                                <span class="cov8" title="1">if r == "url" </span><span class="cov0" title="0">{
                                        if !urlRegex.MatchString(strVal) </span><span class="cov0" title="0">{
                                                errors[field] = fmt.Sprintf("%s must be a valid URL", field)
                                                break</span>
                                        }
                                }

                                // 9. DATE
                                <span class="cov8" title="1">if r == "date" </span><span class="cov0" title="0">{
                                        // Default format YYYY-MM-DD
                                        if _, err := time.Parse("2006-01-02", strVal); err != nil </span><span class="cov0" title="0">{
                                                errors[field] = fmt.Sprintf("%s must be a valid date (YYYY-MM-DD)", field)
                                                break</span>
                                        }
                                }

                                // 10. IN:foo,bar,baz
                                <span class="cov8" title="1">if strings.HasPrefix(r, "in:") </span><span class="cov0" title="0">{
                                        param := strings.TrimPrefix(r, "in:")
                                        options := strings.Split(param, ",")
                                        found := false
                                        for _, opt := range options </span><span class="cov0" title="0">{
                                                if strVal == strings.TrimSpace(opt) </span><span class="cov0" title="0">{
                                                        found = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                                errors[field] = fmt.Sprintf("%s is invalid", field)
                                                break</span>
                                        }
                                }

                                // 11. UNIQUE:table,column
                                <span class="cov8" title="1">if strings.HasPrefix(r, "unique:") </span><span class="cov0" title="0">{
                                        if dbMgr == nil </span><span class="cov0" title="0">{
                                                // Skip if DB not available (e.g. testing without DB)
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">param := strings.TrimPrefix(r, "unique:")
                                        parts := strings.Split(param, ",")
                                        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                                                table := parts[0]
                                                column := parts[1]

                                                // Basic check to prevent SQL injection in table/column names
                                                // Allow only alphanumeric and underscores
                                                if !alphaNumRegex.MatchString(table) || !alphaNumRegex.MatchString(column) </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }

                                                // Use default connection
                                                <span class="cov0" title="0">db := dbMgr.GetConnection("default")
                                                if db != nil </span><span class="cov0" title="0">{
                                                        var count int
                                                        // EXCEPTION: If validating update, ignore own ID
                                                        // unique:users,email,id,1  (ignore id=1)
                                                        query := fmt.Sprintf("SELECT COUNT(*) FROM %s WHERE %s = ?", table, column)
                                                        args := []interface{}{strVal}

                                                        if len(parts) &gt;= 4 </span><span class="cov0" title="0">{
                                                                ignoreCol := parts[2]
                                                                ignoreVal := parts[3]
                                                                if alphaNumRegex.MatchString(ignoreCol) </span><span class="cov0" title="0">{
                                                                        query += fmt.Sprintf(" AND %s != ?", ignoreCol)
                                                                        args = append(args, ignoreVal)
                                                                }</span>
                                                        }

                                                        <span class="cov0" title="0">err := db.QueryRow(query, args...).Scan(&amp;count)
                                                        if err == nil &amp;&amp; count &gt; 0 </span><span class="cov0" title="0">{
                                                                errors[field] = fmt.Sprintf("%s has already been taken", field)
                                                                break</span>
                                                        }
                                                }
                                        }
                                }

                                // 12. EXISTS:table,column
                                <span class="cov8" title="1">if strings.HasPrefix(r, "exists:") </span><span class="cov0" title="0">{
                                        if dbMgr == nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">param := strings.TrimPrefix(r, "exists:")
                                        parts := strings.Split(param, ",")
                                        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                                                table := parts[0]
                                                column := parts[1]

                                                if !alphaNumRegex.MatchString(table) || !alphaNumRegex.MatchString(column) </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }

                                                <span class="cov0" title="0">db := dbMgr.GetConnection("default")
                                                if db != nil </span><span class="cov0" title="0">{
                                                        var count int
                                                        query := fmt.Sprintf("SELECT COUNT(*) FROM %s WHERE %s = ?", table, column)
                                                        err := db.QueryRow(query, strVal).Scan(&amp;count)
                                                        if err == nil &amp;&amp; count == 0 </span><span class="cov0" title="0">{
                                                                errors[field] = fmt.Sprintf("%s is invalid", field)
                                                                break</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }

                // Set Result
                <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                        scope.Set(target, errors)
                        scope.Set(target+"_any", true) // Flag helper untuk IF check
                }</span> else<span class="cov8" title="1"> {
                        scope.Set(target, nil)
                        scope.Set(target+"_any", false)

                        // Helper: Safe Data (Whitelist)
                        // Return only fields that are in 'rules'
                        safeTarget := ""
                        for _, c := range node.Children </span><span class="cov8" title="1">{
                                if c.Name == "as_safe" </span><span class="cov8" title="1">{
                                        safeTarget = strings.TrimPrefix(coerce.ToString(c.Value), "$")
                                }</span>
                        }

                        <span class="cov8" title="1">if safeTarget != "" </span><span class="cov8" title="1">{
                                safeData := make(map[string]interface{})
                                for field := range rules </span><span class="cov8" title="1">{
                                        if val, ok := inputData[field]; ok </span><span class="cov8" title="1">{
                                                safeData[field] = val
                                        }</span>
                                }
                                <span class="cov8" title="1">scope.Set(safeTarget, safeData)</span>
                        }
                }

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">meta := engine.SlotMeta{
                Example: `validate: $form
  rules:
    email: "required|email|unique:users,email"
    password: "required|confirmed|min:8"
    role: "in:admin,user"
  as: $errs
  as_safe: $valid_data`}

        eng.Register("validator.validate", validateHandler, meta)
        eng.Register("validate", validateHandler, meta)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
