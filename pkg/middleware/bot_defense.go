package middleware

import (
	"crypto/sha256"
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"
)

const (
	cookieName   = "zeno_bot_token"
	challengePath = "/_zeno/challenge"
)

// BotDefense implements a simple JS challenge to stop basic bots
func BotDefense(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// 1. Check if enabled
		if os.Getenv("BOT_DEFENSE_ENABLED") != "true" {
			next.ServeHTTP(w, r)
			return
		}

		// 2. Allow static assets and challenge endpoint to bypass
		if r.URL.Path == challengePath || isStaticAsset(r.URL.Path) {
			next.ServeHTTP(w, r)
			return
		}

		// 3. Check for valid token
		cookie, err := r.Cookie(cookieName)
		if err == nil && validateToken(cookie.Value) {
			next.ServeHTTP(w, r)
			return
		}

		// 4. Serve Challenge Page
		serveChallenge(w, r)
	})
}

// BotChallengeHandler handles the POST request from the challenge page
func BotChallengeHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Verify solution
	solution := r.FormValue("solution")
	originalURL := r.FormValue("original_url")

	// Simple validation: The challenge is essentially "can you run JS to submit this form?"
	// In a real scenario, we'd verify a hash or PoW.
	// Here we just check if they submitted the expected static "zeno-shield-active" string
	// which is generated by the JS.
	if solution == "zeno-shield-active" {
		// Set cookie
		token := generateToken()
		http.SetCookie(w, &http.Cookie{
			Name:     cookieName,
			Value:    token,
			Path:     "/",
			HttpOnly: true,
			SameSite: http.SameSiteLaxMode,
			MaxAge:   3600, // 1 hour
		})

		// Redirect back
		// [SECURITY] Prevent Open Redirect: Ensure URL is relative
		if originalURL == "" || !strings.HasPrefix(originalURL, "/") || strings.HasPrefix(originalURL, "//") {
			originalURL = "/"
		}
		http.Redirect(w, r, originalURL, http.StatusFound)
		return
	}

	w.WriteHeader(http.StatusForbidden)
	w.Write([]byte("Bot detected or challenge failed"))
}

func serveChallenge(w http.ResponseWriter, r *http.Request) {
	html := `<!DOCTYPE html>
<html>
<head>
	<title>Security Check - ZenoEngine</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style>
		body { font-family: system-ui, sans-serif; display: flex; align-items: center; justify-content: center; height: 100vh; background: #f0f0f0; margin:0; }
		.box { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); text-align: center; max-width: 400px; }
		.spinner { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 20px auto; }
		@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
	</style>
</head>
<body>
	<div class="box">
		<h2>üõ°Ô∏è Security Check</h2>
		<p>Please wait while we verify you are human...</p>
		<div class="spinner"></div>
		<form id="challenge-form" action="` + challengePath + `" method="POST" style="display:none;">
			<input type="hidden" name="solution" id="solution" value="">
			<input type="hidden" name="original_url" value="` + r.URL.String() + `">
		</form>
	</div>
	<script>
		setTimeout(function() {
			// Simple Proof: If JS runs, we assume it's a browser (basic level)
			document.getElementById('solution').value = "zeno-shield-active";
			document.getElementById('challenge-form').submit();
		}, 800);
	</script>
</body>
</html>`

	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(http.StatusServiceUnavailable) // 503 is often used for challenges to prevent indexing
	w.Write([]byte(html))
}

func isStaticAsset(path string) bool {
	// Simple check for common static extensions
	exts := []string{".css", ".js", ".png", ".jpg", ".jpeg", ".gif", ".ico", ".svg", ".woff", ".woff2"}
	for _, ext := range exts {
		if len(path) > len(ext) && path[len(path)-len(ext):] == ext {
			return true
		}
	}
	return false
}

func generateToken() string {
	// In production, sign this with a secret key + timestamp
	day := time.Now().Format("2006-01-02")

	secret := os.Getenv("BOT_TOKEN_SECRET")
	if secret == "" {
		// Fallback for dev/demo, but predictable
		secret = "zeno-default-secret"
	}

	hash := sha256.Sum256([]byte(secret + "-" + day))
	return fmt.Sprintf("%x", hash)
}

func validateToken(token string) bool {
	expected := generateToken()
	return token == expected
}
