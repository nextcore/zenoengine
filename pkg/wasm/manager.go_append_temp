
// ReloadPlugin reloads a specific plugin by name
func (pm *PluginManager) ReloadPlugin(name string) error {
	slog.Info("Reloading plugin...", "name", name)

	// 1. Get plugin path and verify existence
	pm.mu.RLock()
	plugin, exists := pm.plugins[name]
	pm.mu.RUnlock()

	if !exists {
		return fmt.Errorf("plugin %s not found", name)
	}

	path := plugin.Path

	// 2. Unload existing plugin
	// Note: We remove from map first to allow LoadPlugin to succeed
	pm.mu.Lock()
	delete(pm.plugins, name)
	pm.mu.Unlock()

	// Unload from runtime
	if err := pm.runtime.UnloadModule(name); err != nil {
		slog.Warn("Failed to unload module during reload", "name", name, "error", err)
		// Continue anyway to try loading new version
	}

	// 3. Load plugin again
	if err := pm.LoadPlugin(path); err != nil {
		// If load fails, try to restore old plugin entry (best effort)
		pm.mu.Lock()
		pm.plugins[name] = plugin
		pm.mu.Unlock()
		return fmt.Errorf("failed to reload plugin: %w", err)
	}

	slog.Info("✅ Plugin reloaded successfully", "name", name)
	return nil
}

// ReloadAllPlugins reloads all currently loaded plugins
func (pm *PluginManager) ReloadAllPlugins() map[string]error {
	slog.Info("Reloading all plugins...")

	// Get list of plugins to reload
	pm.mu.RLock()
	plugins := make([]string, 0, len(pm.plugins))
	for name := range pm.plugins {
		plugins = append(plugins, name)
	}
	pm.mu.RUnlock()

	errors := make(map[string]error)
	for _, name := range plugins {
		if err := pm.ReloadPlugin(name); err != nil {
			slog.Error("Failed to reload plugin", "name", name, "error", err)
			errors[name] = err
		}
	}

	if len(errors) > 0 {
		slog.Warn("Reload completed with errors", "errors", len(errors))
	} else {
		slog.Info("✅ All plugins reloaded successfully")
	}

	return errors
}
