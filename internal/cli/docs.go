package cli

import (
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"strings"
	"zeno/internal/app"
	"zeno/pkg/engine"
)

// HandleDocs generates API documentation from the engine's registry.
// Usage: zeno docs [--format=json|md]
func HandleDocs(args []string) {
	format := "json"
	for _, arg := range args {
		if strings.HasPrefix(arg, "--format=") {
			format = strings.TrimPrefix(arg, "--format=")
		}
	}

	// 1. Initialize Engine (Minimal for Docs)
	eng := engine.NewEngine()

	// 2. Register ALL Slots
	// We pass nil for dependencies because we only need the metadata,
	// and Register calls typically don't panic on nil deps unless executed.
	// However, if Register functions try to use deps immediately (e.g. for config),
	// we might need mocks. Let's try nil first.
	// Queue is interface, so nil is fine.
	// DBMgr is pointer, nil is fine.
	// Router is pointer, nil is fine.
	// SetConfig func is nil, check job.go (it checks for nil).

	// Create mock func for setConfig
	mockSetConfig := func(cfg []string) {}

	app.RegisterAllSlots(eng, nil, nil, nil, mockSetConfig)

	// 3. Output
	// Get all docs
	docs := eng.GetDocumentation()

	if format == "md" || format == "markdown" {
		printMarkdown(docs)
	} else {
		// Default JSON
		bytes, err := json.MarshalIndent(docs, "", "  ")
		if err != nil {
			fmt.Printf("Error generating JSON: %v\n", err)
			os.Exit(1)
		}
		fmt.Println(string(bytes))
	}
}

func printMarkdown(docs map[string]engine.SlotMeta) {
	// Group by Group
	groups := make(map[string][]string)
	var groupList []string

	for name, meta := range docs {
		group := meta.Group
		if group == "" {
			group = "General"
		}
		if _, exists := groups[group]; !exists {
			groupList = append(groupList, group)
			groups[group] = make([]string, 0)
		}
		groups[group] = append(groups[group], name)
	}
	sort.Strings(groupList)

	fmt.Println("# Zeno Engine Documentation")
	fmt.Println("> Auto-generated by `zeno docs`")
	fmt.Println()

	for _, g := range groupList {
		fmt.Printf("## %s\n\n", g)

		slotNames := groups[g]
		sort.Strings(slotNames)

		for _, name := range slotNames {
			meta := docs[name]
			fmt.Printf("### `%s`\n", name)
			if meta.Description != "" {
				fmt.Printf("%s\n\n", meta.Description)
			}

			if len(meta.Inputs) > 0 {
				fmt.Println("**Inputs:**")
				// Sort inputs
				var inputKeys []string
				for k := range meta.Inputs {
					inputKeys = append(inputKeys, k)
				}
				sort.Strings(inputKeys)

				for _, k := range inputKeys {
					in := meta.Inputs[k]
					req := ""
					if in.Required {
						req = "*(required)*"
					}
					desc := in.Description
					if desc == "" {
						desc = "-"
					}
					fmt.Printf("- `%s` %s: %s\n", k, req, desc)
				}
				fmt.Println()
			}

			if meta.Returns != "" {
				fmt.Printf("**Returns:** %s\n\n", meta.Returns)
			}

			if meta.Example != "" {
				fmt.Println("**Example:**")
				fmt.Println("```yaml")
				fmt.Println(meta.Example)
				fmt.Println("```")
			}
			fmt.Println("---")
		}
	}
}
