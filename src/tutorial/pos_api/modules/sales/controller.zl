// Body Format:
// {
//     "items": [
//         { "product_id": 1, "qty": 2 },
//         { "product_id": 5, "qty": 1 }
//     ]
// }

fn: create_sale {
    log: "ðŸ›’ Creating new sale transaction"
    
    // Extract tenant ID from header
    http.header: "X-Tenant-ID" { as: $tenant_id }
    
    // Build database connection name
    strings.concat: {
        val: "tenant_"
        val: $tenant_id
        as: $db_name
    }
    
    // Extract user_id from JWT token (set by auth middleware)
    $my_user_id : $auth.user_id
    
    // Validate user is authenticated
    if: !$my_user_id {
        then: {
            log: "ERROR: User not authenticated"
            http.unauthorized: {
                message: "Authentication required"
                error: "UNAUTHORIZED"
            }
            stop
        }
    }

    $items : $request.body.items
    
    // VALIDATION 1: Items array cannot be empty
    if: !$items || $items.length == 0 {
        then: {
            log: "ERROR: Sale creation failed - Items array is empty"
            http.bad_request: {
                message: "Items array cannot be empty"
                error: "EMPTY_ITEMS"
            }
            stop
        }
    }
    
    log: "Processing sale with multiple items"
    
    // VALIDATION 2: Validate all items before processing
    foreach: $items {
        as: $item
        do: {
            if: !$item.product_id || $item.product_id <= 0 {
                then: {
                    log: "ERROR: Sale creation failed - Invalid product_id"
                    http.bad_request: {
                        message: "Invalid product_id in items"
                        error: "INVALID_PRODUCT_ID"
                    }
                    stop
                }
            }
            
            if: !$item.qty || $item.qty <= 0 {
                then: {
                    log: "ERROR: Sale creation failed - Invalid quantity"
                    http.bad_request: {
                        message: "Quantity must be greater than 0"
                        error: "INVALID_QUANTITY"
                    }
                    stop
                }
            }
        }
    }
    
    log: "âœ“ Input validation passed"
    $total_amount : 0
    
    // 1. START DATABASE TRANSACTION
    // All operations in this block are atomic
    // Using the active Tenant DB
    // Initialize variables OUTSIDE transaction to ensure scope persistence
    $total_amount : 0
    $subtotal : 0.0
    // Generate Date String OUTSIDE transaction (Scope fix)
    date.now {
        as: $now_obj
    }
    
    date.format {
        val: $now_obj
        layout: "yyyyMMdd"
        as: $date_str
    }
    
    log: "Date String Generated"
    
    $seq_str : ""
    $invoice_no : ""
    
    // Use active Tenant DB
    db.transaction: $db_name {
        do: {
            // A. Generate Sequential Invoice Number (INSIDE TRANSACTION to prevent race condition)
            
            strings.concat: { val: "INV-"; val: $date_str; val: "%"; as: $inv_pattern }
            
            // FIX: Use FOR UPDATE to lock the count query
            db.query: "SELECT COUNT(id) as total FROM sales WHERE invoice_number LIKE ?" {
                db: $db_name
                bind: { val: $inv_pattern }
                first: true
                as: $last_inv
            }

            
            log: "Last invoice data retrieved"
            
            // Extract total to simple variable
            $last_total : $last_inv.total
            
            // Increment sequence using math.calc
            math.calc: "$last_total + 1" { as: $seq }
            
            log: "Next sequence calculated"
            
             // Padding Logic
            math.calc: "$seq < 10 ? '000' : ($seq < 100 ? '00' : ($seq < 1000 ? '0' : ''))" { as: $padding }
            
            strings.concat: {
                val: "INV-"
                val: $date_str
                val: "-"
                val: $padding
                val: $seq
                as: $invoice_no
            }
            
             log: "Generated invoice number: " + $invoice_no
            
            // B. Prepare Sale Header first (Pending amount) - Use raw SQL
            db.execute: "INSERT INTO sales (invoice_number, user_id, total_amount, status, created_at) VALUES (?, ?, 0, 'completed', CURRENT_TIMESTAMP)" {
                db: $db_name
                bind: {
                    val: $invoice_no
                    val: $my_user_id
                }
            }
            $sale_id : $db_last_id
            
            log: "Sale header created"
            
            // C. Loop Items for Insert Detail & Stock Reduction
            foreach: $items {
                as: $item
                do: {
                    // Get current price & check stock
                    db.query: "SELECT id, sku, name, price, stock FROM products WHERE id = ?" {
                        db: $db_name
                        bind: { val: $item.product_id }
                        first: true
                        as: $prod
                    }
                    
                    if: !$prod {
                        then: {
                            strings.concat { val: "Product not found: "; val: $item.product_id; as: $err_msg }
                            log: "ERROR: " + $err_msg
                            error: $err_msg
                            stop
                        }
                        else: {
                            // Check Stock
                            if: $prod.stock < $item.qty {
                                then: {
                                    strings.concat { val: "Insufficient stock for: "; val: $prod.name; as: $err_msg }
                                    log: $err_msg
                                    error: $err_msg
                                    stop
                                }
                                else: {
                                    // Extract values for calculation
                                    $p_price : $prod.price
                                    $i_qty : $item.qty
                                    
                                    // Calculate Subtotal (Financial Math)
                                    money.calc: "$p_price * $i_qty" { as: $subtotal }
                                    
                                    // Accumulate Total Amount DIRECTLY TO DB
                                    db.execute: "UPDATE sales SET total_amount = total_amount + ? WHERE id = ?" {
                                        db: $db_name
                                        bind: {
                                            val: $subtotal
                                            val: $sale_id
                                        }
                                    }
                                    
                                    log: "Item valid, subtotal calculated"
                                    
                                    // Decrease Stock
                                    math.calc: "$prod.stock - $item.qty" { as: $new_stock }
                                    
                                    db.execute: "UPDATE products SET stock = ? WHERE id = ?" {
                                        db: $db_name
                                        bind: { val: $new_stock; val: $prod.id }
                                    }
                                    
                                    // Insert Item
                                    db.execute: "INSERT INTO sale_items (sale_id, product_id, quantity, price, subtotal) VALUES (?, ?, ?, ?, ?)" {
                                        db: $db_name
                                        bind: { 
                                            val: $sale_id
                                            val: $prod.id 
                                            val: $item.qty
                                            val: $prod.price
                                            val: $subtotal
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            log: "All items processed"
            
            // D. Fetch Final Total from DB (Source of Truth)
            db.query: "SELECT total_amount FROM sales WHERE id = ?" {
                db: $db_name
                bind: { val: $sale_id }
                first: true
                as: $final_sale
            }
            $total_amount : $final_sale.total_amount
            
            // E. AUDIT LOG
            log: "AUDIT: Sale completed successfully"
            
            // F. Return Invoice Data
            $final_invoice : {
                invoice: $invoice_no
                sale_id: $sale_id
                total: $total_amount
                items_count: $items.length
            }
            
            // If successful, COMMIT is automatically executed
            http.ok: { 
                message: "Sale transaction completed successfully"
                data: $final_invoice 
            }
        }
        catch: {
            // If any error/exception occurs in 'do' block:
            // 1. ROLLBACK is automatically executed
            // 2. Stock is preserved
            // 3. Partial sale data is discarded
            
            log: "AUDIT: Sale transaction FAILED"
            
            http.bad_request: {
                message: "Transaction failed"
                detail: $error.message
                error: "TRANSACTION_FAILED"
            }
        }
    }
}

fn: get_daily_report {
    log: "ðŸ“Š Generating daily sales report"
    
    // Extract tenant ID from header
    http.header: "X-Tenant-ID" { as: $tenant_id }
    
    // Build database connection name
    strings.concat: {
        val: "tenant_"
        val: $tenant_id
        as: $db_name
    }
    
    // Validate date parameters
    if: !$request.query.start_date || !$request.query.end_date {
        then: {
            log: "ERROR: Report generation failed - Missing date parameters"
            http.bad_request: {
                message: "start_date and end_date are required"
                error: "MISSING_DATE_PARAMS"
            }
            stop
        }
    }
    
    // Complex query with aggregate
    $sql : "
        SELECT 
            DATE(s.created_at) as sale_date,
            COUNT(s.id) as total_transactions,
            SUM(s.total_amount) as revenue
        FROM sales s
        WHERE s.created_at >= ? AND s.created_at <= ?
        GROUP BY sale_date
        ORDER BY sale_date DESC
    "
    
    // Raw Execution
    db.query: $sql {
        db: $db_name
        bind: {
            val: $request.query.start_date
            val: $request.query.end_date
        }
        as: $report
    }
    
    log: "Report generated for specified period"
    
    http.ok: { 
        data: $report,
        meta: {
            start_date: $request.query.start_date
            end_date: $request.query.end_date
            tenant: $tenant_id
        }
    }
}
