# ZenoVM Documentation

**Status**: Production Ready (v1.0)  
**Architecture**: Stack-based Virtual Machine  
**Bytecode Format**: `.zbc` (Zeno Bytecode)

---

## üöÄ Overview

ZenoVM is a high-performance, stack-based virtual machine designed to execute ZenoLang scripts efficiently. Unlike the legacy tree-walking interpreter (AST Interpreter), ZenoVM compiles source code into compact bytecode instructions that are executed by a tight loop.

**Key Features:**
- **Performance**: Faster execution due to linear instruction cache and minimized pointer chasing.
- **Portability**: Designed with a strictly decoupled interface (`vm_bridge.go`) to allow easy porting to Rust/Zig in the future.
- **Scalability**: Supports massive scripts with >65,000 constants (16-bit addressing).
- **Serialization**: Can save/load compiled bytecode (`.zbc`) for faster startup and code protection.

---

## üõ†Ô∏è Usage

### Running in VM Mode
To run any `.zl` script using the VM:
```bash
zeno run src/main.zl --vm
```

### Compiling to Bytecode
To compile a script into a binary `.zbc` file (Offline Compilation):
```bash
zeno compile src/main.zl
# Creates src/main.zbc
```

### Running Bytecode
You can run the compiled `.zbc` file directly. The VM detects the format automatically.
```bash
zeno run src/main.zbc --vm
```

---

## üèóÔ∏è Architecture

### 1. The Compiler
The compiler takes the AST (Abstract Syntax Tree) generated by the parser and emits **Opcodes**.
- It handles scope resolution (Local vs Global).
- It flattens control flow (If/Else, Loops) into Jump instructions.
- It optimizes constants (Strings, Numbers) into a `Constant Pool`.

### 2. The Chunk
A `Chunk` is the unit of execution. It contains:
- **Code**: `[]byte` (Stream of opcodes and operands).
- **Constants**: `[]Value` (Pool of strings, numbers, functions).
- **Lines**: `[]int` (Source map for debugging).

### 3. The Value System
ZenoVM uses a tagged union `Value` struct for type safety and easy translation to C-like languages:
```go
type Value struct {
    Type   ValueType
    Number float64
    String string
    Bool   bool
    List   []Value
    Map    map[string]Value
    // ...
}
```

### 4. Stack & Frames
- **Operand Stack**: Data is pushed/popped for operations.
- **Call Frames**: Each function call creates a `CallFrame` that tracks the return address (`ip`) and the base pointer for local variables.
- **Scope Isolation**: Functions are compiled as "Constants" (ValFunction) containing their own separate Chunks.

---

## ‚ö° Low-Level Details

### 16-bit Support ("Limitless" Architecture)
Originally, ZenoVM used 1-byte operands (max 255 constants).
**Update (v0.5.5)**: The VM now automatically switches to **Long Opcodes** when needed.

| Short Opcode (8-bit) | Long Opcode (16-bit) | Description |
|----------------------|----------------------|-------------|
| `OpConstant` (idx) | `OpConstantLong` (idx) | Load constant from pool |
| `OpGetGlobal` (idx) | `OpGetGlobalLong` (idx) | Get global variable |
| `OpCallSlot` (idx, n) | `OpCallSlotLong` (idx, n) | Call native Go slot |

This allows chunks to effectively hold infinite constants (up to memory limits), enabling massive enterprise applications like `Demo MAX` to run without issues.

### Instruction Set (Partial)
- `OpConstant`: Push constant to stack.
- `OpAdd`, `OpSub`, `OpMul`, `OpDiv`: Arithmetic.
- `OpCall`: Call a ZenoLang function.
- `OpCallSlot`: Call a host function (e.g., `db.query`).
- `OpJump`, `OpJumpIfFalse`: Control flow.
- `OpGetLocal`, `OpSetLocal`: Fast local variable access (stack-indexed).

---

## üîÑ Future Roadmap (Portability)

The VM is architected for "Drop-in Replacement".
The `pkg/engine/vm_bridge.go` file acts as the adapter between the Go Engine and the VM.
To port to Rust/Zig:
1. Rewrite `vm.go` and `compiler.go` in Rust.
2. Expose a C-ABI from the Rust library.
3. Use CGO in `vm_bridge.go` to call the Rust VM.

4. The rest of ZenoEngine remains untouched.
